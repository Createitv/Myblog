[{"categories":["前端","Javascript"],"content":"Createitv","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"数组常用方法总结 01_数组常用方法1.html =\u003e 数组基础方法 =\u003e push() =\u003e pop() =\u003e unshift() =\u003e shift() 02_数组常用方法2.html =\u003e ES3.0, IE 6 7 8 可以是使用 =\u003e reverse() =\u003e sort() =\u003e splice() =\u003e join() =\u003e slice() =\u003e concat() 03_数组常用方法3.html =\u003e ES5.0, IE 6 7 8 不好使了 =\u003e indexOf() =\u003e lastIndexOf() =\u003e forEach() =\u003e map() =\u003e fliter() =\u003e every() =\u003e some() 04_数组常用方法4.html =\u003e ES2015(ES6) 以后, 标准浏览器, IE 10 以上 =\u003e fill() =\u003e copyWithin() =\u003e includes() =\u003e flat() =\u003e flatMap() =\u003e find() =\u003e findIndex() ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:0:1","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"push, pop, unshift ,shift // -----------pop----------- const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato']; console.log(plants.pop()); // expected output: \"tomato\" console.log(plants); // expected output: Array [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"] plants.pop(); console.log(plants); // expected output: Array [\"broccoli\", \"cauliflower\", \"cabbage\"] // -----------push----------- const animals = ['pigs', 'goats', 'sheep']; const count = animals.push('cows'); console.log(count); // expected output: 4 console.log(animals); // expected output: Array [\"pigs\", \"goats\", \"sheep\", \"cows\"] animals.push('chickens', 'cats', 'dogs'); console.log(animals); // expected output: Array [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"] // -----------unshift----------- // unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 const array1 = [1, 2, 3]; console.log(array1.unshift(4, 5)); // expected output: 5 console.log(array1); // expected output: Array [4, 5, 1, 2, 3] // -----------shift----------- //shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 const array1 = [1, 2, 3]; const firstElement = array1.shift(); console.log(array1); // expected output: Array [2, 3] console.log(firstElement); // expected output: 1 ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:1:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"reverse, sort, splice, join, slice, concat // -----------reverse----------- // reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。 const array1 = ['one', 'two', 'three']; console.log('array1:', array1); // expected output: \"array1:\" Array [\"one\", \"two\", \"three\"] const reversed = array1.reverse(); console.log('reversed:', reversed); // expected output: \"reversed:\" Array [\"three\", \"two\", \"one\"] // Careful: reverse is destructive -- it changes the original array. console.log('array1:', array1); // expected output: \"array1:\" Array [\"three\", \"two\", \"one\"] // -----------sort----------- // sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 const months = ['March', 'Jan', 'Feb', 'Dec']; months.sort(); console.log(months); // expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // expected output: Array [1, 100000, 21, 30, 4] // ----------sort()比大小------- var numbers = [4, 2, 5, 1, 3]; numbers.sort(function(a, b) { return a - b; }); console.log(numbers); 也可以写成： var numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =\u003e a - b); console.log(numbers); // [1, 2, 3, 4, 5] // -----------splice----------- // splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组 const months = ['Jan', 'March', 'April', 'June']; months.splice(1, 0, 'Feb'); // inserts at index 1 console.log(months); // expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"] months.splice(4, 1, 'May'); // replaces 1 element at index 4 console.log(months); // expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"] // 从第 2 位开始删除 0 个元素，插入“drum” var myFish = [\"angel\", \"clown\", \"mandarin\", \"sturgeon\"]; var removed = myFish.splice(2, 0, \"drum\"); // 运算后的 myFish: [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"] // 被删除的元素: [], 没有元素被删除 // -----------join------------- // join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 const elements = ['Fire', 'Air', 'Water']; console.log(elements.join()); // expected output: \"Fire,Air,Water\" console.log(elements.join('')); // expected output: \"FireAirWater\" console.log(elements.join('-')); // expected output: \"Fire-Air-Water\" // -----------slice------------ // slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 const animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice(2)); // expected output: Array [\"camel\", \"duck\", \"elephant\"] console.log(animals.slice(2, 4)); // expected output: Array [\"camel\", \"duck\"] console.log(animals.slice(1, 5)); // expected output: Array [\"bison\", \"camel\", \"duck\", \"elephant\"] // -----------concat----------- // concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 const array1 = ['a', 'b', 'c']; const array2 = ['d', 'e', 'f']; const array3 = array1.concat(array2); console.log(array3); // expected output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:2:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"indexOf, lastIndexOf, forEach, map, filter, every, some // -------------------indexOf-------------------- // indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 const beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 // start from index 2 console.log(beasts.indexOf('bison', 2)); // expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 // -------------------lastIndexOf-------------------- // lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo']; console.log(animals.lastIndexOf('Dodo')); // expected output: 3 console.log(animals.lastIndexOf('Tiger')); // expected output: 1 // -------------------forEach-------------------- // forEach() 方法对数组的每个元素执行一次给定的函数。返回undefined const array1 = ['a', 'b', 'c']; array1.forEach(element =\u003e console.log(element)); // expected output: \"a\" // expected output: \"b\" // expected output: \"c\" // -------------------map-------------------- // map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x =\u003e x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] // -------------------filter-------------------- // filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter(word =\u003e word.length \u003e 6); console.log(result); // expected output: Array [\"exuberant\", \"destruction\", \"present\"] // -------------------every-------------------- // every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 const isBelowThreshold = (currentValue) =\u003e currentValue \u003c 40; const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true // 检测数组中的所有元素是否都大于 10。 function isBigEnough(element, index, array) { return element \u003e= 10; } [12, 5, 8, 130, 44].every(isBigEnough); // false [12, 54, 18, 130, 44].every(isBigEnough); // true // -------------------some-------------------- // some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 const array = [1, 2, 3, 4, 5]; // checks whether an element is even const even = (element) =\u003e element % 2 === 0; console.log(array.some(even)); // expected output: true //下面的例子检测在数组中是否有元素大于 10。 function isBiggerThan10(element, index, array) { return element \u003e 10; } [2, 5, 8, 1, 4].some(isBiggerThan10); // false [12, 5, 8, 1, 4].some(isBiggerThan10); // true ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:3:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"fill, copyWithin, includes, flat, flatMap, find, findIndex // -------------------fill-------------------- // fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 const array1 = [1, 2, 3, 4]; // fill with 0 from position 2 until position 4 console.log(array1.fill(0, 2, 4)); // expected output: [1, 2, 0, 0] // fill with 5 from position 1 console.log(array1.fill(5, 1)); // expected output: [1, 5, 5, 5] console.log(array1.fill(6)); // expected output: [6, 6, 6, 6] // -------------------copyWithin-------------------- // copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 const array1 = ['a', 'b', 'c', 'd', 'e']; // copy to index 0 the element at index 3 console.log(array1.copyWithin(0, 3, 4)); // expected output: Array [\"d\", \"b\", \"c\", \"d\", \"e\"] // copy to index 1 all elements from index 3 to the end console.log(array1.copyWithin(1, 3)); // expected output: Array [\"d\", \"d\", \"e\", \"d\", \"e\"] // -------------------includes-------------------- // includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 const array1 = [1, 2, 3]; console.log(array1.includes(2)); // expected output: true const pets = ['cat', 'dog', 'bat']; console.log(pets.includes('cat')); // expected output: true console.log(pets.includes('at')); // expected output: false // -------------------flat-------------------- // flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 const arr1 = [0, 1, 2, [3, 4]]; console.log(arr1.flat()); // expected output: [0, 1, 2, 3, 4] const arr2 = [0, 1, 2, [[[3, 4]]]]; console.log(arr2.flat(2)); // expected output: [0, 1, 2, [3, 4]] // -------------------flatMap-------------------- // flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 let arr1 = [\"it's Sunny in\", \"\", \"California\"]; arr1.map(x =\u003e x.split(\" \")); // [[\"it's\",\"Sunny\",\"in\"],[\"\"],[\"California\"]] arr1.flatMap(x =\u003e x.split(\" \")); // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"] // -------------------find-------------------- // find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 const array1 = [5, 12, 8, 130, 44]; const found = array1.find(element =\u003e element \u003e 10); console.log(found); // expected output: 12 // -------------------findIndex-------------------- // findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 const array1 = [5, 12, 8, 130, 44]; const isLargeNumber = (element) =\u003e element \u003e 13; console.log(array1.findIndex(isLargeNumber)); // expected output: 3 ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:4:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["浏览器"],"content":"Createitv","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"浏览器特性 现代浏览器的特性主要包含如下几部分： 网络 浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。 资源管理 浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。 网页浏览 浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。 多页面管理 浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。 插件和扩展 现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。 账户和同步 现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。 安全机制 现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。 开发者工具 开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。 浏览器结构 目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构： 浏览器的抽象分层结构图中将浏览器分成了以下8个子系统： 用户界面（User Interface） 用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。 用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。 浏览器引擎（Browser Engine） 浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。 浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。 浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。 浏览器引擎还允许查询/修改渲染引擎设置。 渲染引擎（Rendering Engine） 渲染引擎为指定的URI生成可视化的表示。 渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。 渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。 渲染引擎内部包含HTML解析器。 网络（Networking） 网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。 JavaScript解释器（JavaScript Interpreter） JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。 XML解析器（XML Parser） XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。 显示后端（Display Backend） 显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。 数据持久层（Data Persistence） 数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。 这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？ 原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。 渲染引擎 浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用： 渲染引擎 浏览器 Trident IE、Edge Gecko Firefox WebKit Safari、Chromium/Chrome ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:0:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"渲染引擎工作流程 如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。 Parsing HTML to Construct DOM Tree 渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。 同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。 Render Tree construction 渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。 渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 Layout of Render Tree 渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 Painting Render Tree 渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。 ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:1:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"渲染引擎组成模块 下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 从图中可以看出，渲染引擎主要包含（或调用）的模块有： HTML（XML）解析器 解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。 CSS解析器 将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。 JavaScript解释器 使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。 布局 DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。 绘图 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。 ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:2:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["python"],"content":"Createitv","date":"2021-05-15","objectID":"/posts/intermediatepython/","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"IntermediatePython ","date":"2021-05-15","objectID":"/posts/intermediatepython/:1:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"*args和**kwargs 并不是必须写成*args 和**kwargs。 只有变量前面的 *(星号)才是必须的. 你也可以写成*var 和**vars. 而写成*args 和**kwargs只是一个通俗的命名约定。 *args的用法 args和**kwargs用于函数不定数量的参数传递，在函数使用者不知道会传递多少个参数下可使用 def test_var_args(f_arg, *argv): print(\"first normal arg:\", f_arg) for arg in argv: print(\"another arg through *argv:\", arg) \u003e\u003e\u003etest_var_args('yasoob', 'python', 'eggs', 'test') first normal arg: yasoob another arg through *argv: python another arg through *argv: eggs another arg through *argv: test **kwargs的用法 **kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 def greet_me(**kwargs): for key, value in kwargs.items(): print(\"{0}=={1}\".format(key, value)) \u003e\u003e\u003egreet_me(name='yasoob') name == yasoob 使用args和**kwargs来调用函数 def test_args_kwargs(arg1, arg2, arg3): print(\"arg1:\", arg1) print('arg2:', arg2) print(\"arg3:\", arg3) # 首先使用*args \u003e\u003e\u003eargs = (\"two\", 3, 5) \u003e\u003e\u003etest_args_kwargs(**kwargs) arg1: two arg2: 3 arg3: 5 #再使用**kwargs \u003e\u003e\u003e kwargs = {\"arg3\": 3, \"arg2\": \"two\", \"arg1\": 5} \u003e\u003e\u003e test_args_kwargs(**kwargs) arg1: 5 arg2: two arg3: 3 标准参数、缺省参数、*args、**kwargs在使用时候的顺序 some_function(argument, argument=' ', *args, **kwargs ) 什么时候使用 根据需求而定：最常见在装饰起之中捕获修饰函数的不定参数 def use_logging(func): def wrapper(*args, **kwargs): # Look this logging.warn(\"%sis running\" % func.__name__) return func(*args) return wrapper @use_logging def foo(): print(\"i am foo\") @use_logging def bar(): print(\"i am bar\") bar() ","date":"2021-05-15","objectID":"/posts/intermediatepython/:2:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"调试Debugging 利用好调试，能大大提高你捕捉代码Bug的。大部分新人忽略了Python debugger(pdb)的重要性。 从命令行启动 $ python -m pdb my_script.py 从脚本内部启动 import pdb def make_bread(): pdb.set_trace() #设置断点 return \"I don't have time\" print(make_bread()) 命令列表： c: 继续执行 w: 显示当前正在执行的代码行的上下文信息 a: 打印当前函数的参数列表 s: 执行当前代码行，并停在第一个能停的地方（相当于单步进入） n: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过） ","date":"2021-05-15","objectID":"/posts/intermediatepython/:3:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"生成器Generators 迭代器(iterators)是一个让程序员可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。 可迭代对象(Iterable)——形容词 迭代器(Iterator)——名词 迭代(Iteration)——动词 可迭代对象(Iterable) Python中任意的对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。 迭代器(Iterator) 任意对象，只要定义了next(Python2) 或者__next__方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration) 迭代(Iteration) 从某个地方（比如一个列表）不断取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。 生成器(Generators) 生成器也是一种迭代器，一次只能迭代一次，类似版本迭代更新。在python中并没有直接把所有数据写入内存中，而是在运行时生成值。可以通过遍历来访问他们，大多数时候通过函数来实现。而且并不返回一个值而是yield一个值。 斐波那契数列生成器 # generator version(减少资源消耗) def fibon(n): a = b = 1 for i in range(n): yield a a, b = b, a + b for x in fibon(1000000): print(x) #faction version def fibon(n): a = b = 1 result = [] for i in range(n): result.append(a) a, b = b, a + b return result ","date":"2021-05-15","objectID":"/posts/intermediatepython/:4:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"高阶函数(Map，Filter，Reduce) Map函数 Map会将一个函数映射到一个输入列表的所有元素上 map(function_to_apply, list_of_inputs) # 对比举例 items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.appedn(i**2) # 等同于 items = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, items)) # 在python2中map直接返回列表，但在python3中返回迭代器 # 因此为了兼容python3, 需要list转换一下 Filter函数 filter过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True number_list = range(-5, 5)less_than_zero = filter(lambda x:x \u003c0, number_list)print(list(less_than_zero)) filter类似于一个for循环，但它是一个内置函数，并且更快。 注意：map和filter相对不那么优雅,推导式的可读性更好。 Reduce函数 reduce() 函数会对参数序列中元素进行累积 reduce(function, iterable[, initializer]) #语法from functools import reduceproduct = reduce( (lambda x, y: x * y), [1, 2, 3, 4] )# Output: 24 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:5:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"Set数据集合 set(集合)是一个非常有用的数据结构。它与列表(list)的行为类似，区别在于set不能包含重复的值。 # 查看重复元素some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']duplicates = []for value in some_list: if some_list.count(value) \u003e 1: if value not in duplicates: duplicates.append(value)print(duplicates)### 输出: ['b', 'n'] 更简单更优雅的解决方案，那就是使用集合(sets) some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']duplicates = set([x for x in some_list if some_list.count(x) \u003e 1])print(duplicates)### 输出: set(['b', 'n']) 交集 对比两个集合的交集（两个集合中都有的数据） valid = set(['yellow', 'red', 'blue', ' green', 'black'])input_set = set(['red', 'brown'])print(input_set.interserction(valid))### 输出:set(['red']) 差集 用差集(difference)找出无效的数据，相当于用一个集合减去另一个集合的数据 valid = set(['yellow', 'red', 'blue', 'green', 'black'])input_set = set(['red', 'brown'])print(input_set.difference(valid))### 输出:set(['brown']) 你也可以用{}符号来创建集合 a_set = {'red', 'blue', 'green'}print(type(a_set))### 输出: \u003ctype 'set'\u003e ","date":"2021-05-15","objectID":"/posts/intermediatepython/:6:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"三元运算符 三元运算符通常在Python里被称为条件表达式，这些表达式基于真(true)/假(false)的条件判断 伪代码 #如果条件为真，返回真 否则返回假condition_is_true if condition else condition_is_false 举例 number = 3flag = '单数' if number % 2 != 0 else '双数'print(flag)### 输出:单数 另外一种超级晦涩的语法 #(返回假，返回真)[真或假](if_test_is_false, if_test_is_true)[test]fat = Truefitness = (\"skinny\", \"fat\")[fat]print(\"Ali is\", fitness)#输出: Ali is fat ","date":"2021-05-15","objectID":"/posts/intermediatepython/:7:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"装饰器 修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿），新手跨越必备。 函数也是对象 def hi(name=\"yasoob\"): return \"hi \" + nameprint(hi())# output: 'hi yasoob'# 我们甚至可以将一个函数赋值给一个变量，比如greet = hi# 我们这里没有在使用小括号，因为我们并不是在调用hi函数# 而是在将它放在greet变量里头。我们尝试运行下这个print(greet())# output: 'hi yasoob'# 如果我们删掉旧的hi函数，看看会发生什么！del hiprint(hi())#outputs: NameErrorprint(greet())#outputs: 'hi yasoob' 函数中定义函数 def hi(name=\"yasoob\"): print(\"now you are inside the hi() function\") def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" print(greet()) print(welcome()) print(\"now you are back in the hi() function\")hi()#output:now you are inside the hi() function# now you are in the greet() function# now you are in the welcome() function# now you are back in the hi() function# 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。# 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：greet()#outputs: NameError: name 'greet' is not defined 从函数中返回函数 def hi(name=\"yasoob\"): def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" if name == \"yasoob\": return greet else: return welcomea = hi()print(a)#outputs: \u003cfunction greet at 0x7f2143c01500\u003e#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数#现在试试这个print(a())#outputs: now you are in the greet() function 将函数作为参数传给另一个函数 def hi(): return \"hi yasoob!\"def doSomethingBeforeHi(func): print(\"I am doing some boring work before executing hi()\") print(func())doSomethingBeforeHi(hi)#outputs:I am doing some boring work before executing hi()# hi yasoob! 装饰器应用 def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunctiondef a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\")a_function_requiring_decoration()#outputs: \"I am the function which needs some decoration to remove my foul smell\"a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)#now a_function_requiring_decoration is wrapped by wrapTheFunction()a_function_requiring_decoration()#outputs:I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func() 装饰起语法糖 @a_new_decoratordef a_function_requiring_decoration(): \"\"\"Hey you! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\")a_function_requiring_decoration()#outputs: I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func()#the @a_new_decorator is just a short way of saying:a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 使用场景 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中 from functools import wrapsdef requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated ","date":"2021-05-15","objectID":"/posts/intermediatepython/:8:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"slots魔法 在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这非常有用，因为它允许我们在运行时去设置任意的新属性。 然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象（我指的是成千上万个），它会消耗掉很多内存。 不过还是有一个方法来规避这个问题。这个方法需要使用__slots__来告诉Python不要使用字典，而且只给一个固定集合的属性分配空间。 不使用__slots__: class MyClass(object): def __init__(self, name, identifier): self.name = name self.identifier = identifier self.set_up() 使用__slots__ class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self.name = name self.identifier = identifier self.set_up() 第二段代码会为你的内存减轻负担。通过这个技巧，有些人已经看到内存占用率几乎40%~50%的减少。 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:9:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"虚拟环境Virtualenv 什么是虚拟环境？ Virtualenv 是一个工具，它能够帮我们创建一个独立(隔离)的Python环境。想象你有一个应用程序，依赖于版本为2的第三方模块，但另一个程序依赖的版本是3，请问你如何使用和开发这些应用程序？ 如果你把一切都安装到了/usr/lib/python2.7/site-packages（或者其它平台的标准位置），那很容易出现某个模块被升级而你却不知道的情况。 在另一种情况下，想象你有一个已经开发完成的程序，但是你不想更新它所依赖的第三方模块版本；但你已经开始另一个程序，需要这些第三方模块的版本。 虚拟环境安装 pip install virtualenv 虚拟环境启动 $ virtualenv myproject $ source myproject/bin/activate 执行第一个命令在myproject文件夹创建一个隔离的virtualenv环境，第二个命令激活这个隔离的环境(virtualenv)。 如果你想让你的virtualenv使用系统全局模块，请使用--system-site-packages 虚拟环境关闭 $ deactivate 小工具 smartcd你可以使用smartcd来帮助你管理你的环境，当你切换目录时，它可以帮助你激活（activate）和退出（deactivate）你的virtualenv ","date":"2021-05-15","objectID":"/posts/intermediatepython/:10:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"容器(collections) defaultdict defaultdict与dict类型不同，你不需要检查key是否存在，所以能这样做 from collections import defaultdictcolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'),)favourite_colours = defaultdict(list)for name, colour in colours: favourite_colours[name].append(colour)print(favourite_colours)# defaultdict(\u003ctype 'list'\u003e,# {'Arham': ['Green'],# 'Yasoob': ['Yellow', 'Red'],# 'Ahmed': ['Silver'],# 'Ali': ['Blue', 'Black']# }) 当你在一个字典中对一个键进行嵌套赋值时，如果这个键不存在，会触发keyError异常。 defaultdict允许我们用一个聪明的方式绕过这个问题。 首先我分享一个使用dict触发KeyError的例子，然后提供一个使用defaultdict的解决方案 some_dict = {}some_dict['colours']['favourite'] = \"yellow\"## 异常输出：KeyError: 'colours'import collectionstree = lambda: collections.defaultdict(tree)some_dict = tree()some_dict['colours']['favourite'] = \"yellow\"## 运行正常 counter counter是一个计数器，帮助我们对数据进行计数 from collections import Countercolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'),)favs = Counter(name for name, colour in colours)print(favs)## 输出:## Counter({## 'Yasoob': 2,## 'Ali': 2,## 'Arham': 1,## 'Ahmed': 1## }) 我们也可以在利用它统计一个文件 with open('filename', 'rb') as f: line_count = Counter(f)print(line_count) deque deque提供了一个双端队列，你可以从头和尾两端添加或者删除元素。 from collections import dequed = deque()d.append('1')d.append('2')d.append('3')print(len(d))# output:3print(d[0])# output:'1'print(d[-1])# output:'3' 从两端取出(pop)数据： d = deque(range(5))print(len(d))## 输出: 5d.popleft()## 输出: 0d.pop()## 输出: 4print(d)## 输出: deque([1, 2, 3]) namedtuple enum.Enum ","date":"2021-05-15","objectID":"/posts/intermediatepython/:11:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"枚举Enumerate 枚举(enumerate)是Python内置函数 my_list = ['apple', 'banana', 'grapes', 'pear']for c, value in enumerate(my_list, 1): print(c, value)# 输出:(1, 'apple')(2, 'banana')(3, 'grapes')(4, 'pear') ","date":"2021-05-15","objectID":"/posts/intermediatepython/:12:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"对象自省 自省(introspection)，在计算机编程领域里，是指在运行时来判断一个对象的类型的能力。它是Python的强项之一。Python中所有一切都是一个对象，而且我们可以仔细勘察那些对象。Python还包含了许多内置函数和模块来帮助我们。 dir 返回一个列表，列出了一个对象所拥有的属性和方法。自省给了我们一个列表对象的所有方法的名字。当你没法回忆起一个方法的名字，这会非常有帮助。 my_list = [1, 2, 3]dir(my_list)# Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',# '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',# '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',# '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',# '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',# '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',# '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',# 'remove', 'reverse', 'sort'] type和id type函数返回一个对象的类型 print(type(''))# Output: \u003ctype 'str'\u003eprint(type([]))# Output: \u003ctype 'list'\u003eprint(type({}))# Output: \u003ctype 'dict'\u003eprint(type(dict))# Output: \u003ctype 'type'\u003eprint(type(3))# Output: \u003ctype 'int'\u003e id()函数返回任意不同种类对象的唯一ID name = \"Yasoob\"print(id(name))# Output: 139972439030304 inspect模块 inspect模块也提供了许多有用的函数，来获取活跃对象的信息。 import inspectprint(inspect.getmembers(str))# Output: [('__add__', \u003cslot wrapper '__add__' of ... ... ","date":"2021-05-15","objectID":"/posts/intermediatepython/:13:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"推导式 推导式（又称解析式）是Python的一种独有特性，推导式可以从一个数据序列构建另外一个数据序列的结构体。 列表推导式 字典推导式 集合推导式 List Comprehension 列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。 它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以if和for语句为上下文的表达式运行完成之后产生。 variable = [out_exp for out_exp in input_list if out_exp == 2] Dictionary Comprehension mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}mcase_frequency = { k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()}# mcase_frequency == {'a': 17, 'z': 3, 'b': 34} 快速对换一个字典的键和值 {v: k for k, v in some_dict.items()} Set Comprehension 它们跟列表推导式也是类似的。 唯一的区别在于它们使用大括号{} squared = {x**2 for x in [1, 1, 2]}print(squared) ","date":"2021-05-15","objectID":"/posts/intermediatepython/:14:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"异常 异常处理是一种艺术，一旦你掌握，会授予你无穷的力量 try: file = open('test.txt', 'rb')except IOError as e: print(\"An IOError occurred. {}\".format(e.args[-1])) 处理多个异常 第一种方法需要把所有可能发生的异常放到一个元组里。像这样： try: file = open('test.txt', 'rb')except (IOError, EOFError) as e: print(\"An error occurred. {}\".format(e.args[-1])) 另外一种方式是对每个单独的异常在单独的except语句块中处理。我们想要多少个except语句块都可以。 try: file = open('test.txt', 'rb')except EOFError as e: print(\"An EOF error occurred.\") raise eexcept IOError as e: print(\"An error occurred.\") raise e 捕获所有异常 try: file = open(\"test.txt\", 'rb')except Exception: # 打印一些异常日志，如果你想要的话 raise finally 从句 包裹到finally从句中的代码不管异常是否触发都将会被执行。这可以被用来在脚本执行之后做清理工作。 try: file = open(\"test.txt\", 'rb')except IOError as e: print(\"An IOError occurred.{}\".format(e.args[-1]))finally: print(\"This would be printed wheher or not an exception occurred!\") try / else从句 else可以用在不触发异常的情况下执行一些代码 try: print('I am sure no exception is going to occur!')except Exception: print('exception')else: # 这里的代码只会在try语句里没有触发异常时运行, # 但是这里的异常将 *不会* 被捕获 print('This would only run if no exception occurs. And an error here ' 'would NOT be caught.')finally: print('This would be printed in every case.')# Output: I am sure no exception is going to occur!# This would only run if no exception occurs.# This would be printed in every case. ","date":"2021-05-15","objectID":"/posts/intermediatepython/:15:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"lambda表达式 它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式 原型 lambda 参数:操作(参数) 例子 add = lambda x, y: x + yprint(add(3, 5))# Output: 8 列表排序 a = [(1, 2), (4 ,1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1])print(a)# Output: [(13, -3), (4, 1), (1, 2), (9, 10)] ","date":"2021-05-15","objectID":"/posts/intermediatepython/:16:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"一行式 简易Web Server 你是否想过通过网络快速共享文件？好消息，Python为你提供了这样的功能。 # Python 2python -m SimpleHTTPServer# Python 3python -m http.server 漂亮的打印 你可以在Python REPL漂亮的打印出列表和字典。这里是相关的代码： from pprint import pprintmy_dict = {'name': 'Yasoob', 'age': 'undefined', 'personality': 'awesome'} pprint(my_dict) 想快速漂亮的从文件打印出json数据，那么你可以这么做 cat file.json | python -m json.tool 脚本性能分析 这可能在定位你的脚本中的性能瓶颈时 python -m cProfile my_scripy.py CSV转换为json python -c \"import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))\" 一行式的构造器 class A(object): def __init__(self, a, b, c, d, e, f): self.__dict__.update({k: v for k, v in locals().items() if k != 'self'}) ","date":"2021-05-15","objectID":"/posts/intermediatepython/:17:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"For-else else从句会在循环正常结束时执行。这意味着，循环没有遇到任何break 有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使用break来中断这个循环。有两个场景会让循环停下来。 第一个是当一个元素被找到，break被触发。 第二个场景是循环结束。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n / x) break else: # loop fell through without finding a factor print(n , 'is a prime number') ","date":"2021-05-15","objectID":"/posts/intermediatepython/:18:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"使用C扩展 开发者有三种方法可以在自己的Python代码中来调用C编写的函数-ctypes，SWIG，Python/C API。每种方式也都有各自的利弊。 要在Python中调用C？原因如下： 你要提升代码的运行速度，而且你知道C要比Python快50倍以上 C语言中有很多传统类库，而且有些正是你想要的，但你又不想用Python去重写它们 想对从内存到文件接口这样的底层资源进行访问 不需要理由，就是想这样做 Ctypes Python中的ctypes模块可能是Python调用C方法中最简单的一种。ctypes模块提供了和C语言兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。也正是如此奠定了这种方法的简单性。 SWIG SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种方法。在这个方法中，开发人员必须编写一个额外的接口文件来作为SWIG(终端工具)的入口。 Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。 Python/C API Python/C API可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:19:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"函数缓存 函数缓存允许我们将一个函数对于给定参数的返回值缓存起来。 当一个I/O密集的函数被频繁使用相同的参数调用的时候，函数缓存可以节约时间。 在Python 3.2版本以前我们只有写一个自定义的实现。在Python 3.2以后版本，有个lru_cache的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存。 python3.2+ 实现一个斐波那契计算器，并使用lru_cache ","date":"2021-05-15","objectID":"/posts/intermediatepython/:20:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["前端"],"content":"Createitv","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Lecture 0 Introduction Web Programming HTML (Hypertext Markup Language) Document Object Model (DOM) More HTML Elements Forms CSS (Cascading Style Sheets) Responsive Design Bootstrap Sass (Syntactically Awesome Style Sheets) ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:0:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Introduction In this course, we’re picking up where CS50 left off and diving into the design and creation of web applications. We’ll build our web-design skills by working on a number of projects throughout the course, including an open-ended final project where you’ll have the chance to create a website of your own! In this course, you’ll need a text editor where you can write code locally on your computer. Some popular ones include Visual Studios Code, Sublime Text, Atom, and Vim, but there are many more to choose from! ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:1:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Web Programming Course Topics: We’ll go into more detail later, but here’s a brief overview of what we’ll be working on during this course: HTML and CSS (a markup language used to outline a webpage, and a procedure for making our sites more visually appealing) Git (used for version control and collaboration) Python (a widely-used programming language we’ll use to make our sites more dynamic) Django (a popular web framework we’ll use for the backend of our sites) SQL, Models, and Migrations (a language used for storing and retrieving data, and Django-specific methods that make it easier to interact with SQL databases) JavaScript (a programming language used to make websites faster and more interactive) User Interfaces (methods used to make a website as easy to use as possible) Testing, CI, CD (learning about different methods used to make sure updates to web pages proceed smoothly) Scalability and Security (making sure our websites can be accessed by many users at once, and that they are safe from malicious intent) ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:2:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"HTML (Hypertext Markup Language) HTML is a markup language that defines the structure of a web page. It is interpreted by your web browser (Safari, Google Chrome, Firefox, etc.) in order to display content on your screen. Let’s get started by writing a simple HTML file! \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e When we open up this file in our browser, we get: Now, let’s take some time to talk about the file we just wrote, which seems to be pretty complicated for such a simple page. In the first line, we are declaring (to the web browser) that we are writing the document in the latest version of HTML: HTML5. After that, the page consists of nested HTML elements (such as html and body), each with an opening and closing tag marked with either \u003celement\u003e for an opening and \u003c/element\u003e for a closing. Notice how each of the inner elements is indented just a bit further than the last. While this is not necessarily required by the browser, it will be very helpful to keep this up in your own code. HTML elements can include attributes, which give the browser extra information about the element. For example, when we include lang=\"en\" in our initial tag, we are telling the browser that we are using English as our primary language. Inside the HTML element, we typically want to include both a head and a body tag. The head element will include information about your page that is not necessarily displayed, and the body element will contain what is actually visible to users who visit the site. Within the head, we have included a title for our webpage, which you’ll notice is displayed in the tab at the top of our web browser. Finally, we’ve included the text “Hello, world!” in the body, which is the visible part of our page. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Document Object Model (DOM) The DOM is a convenient way of visualizing the way HTML elements relate to each other using a tree-like structure. Above is an example of the DOM layout for the page we just wrote. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:1","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"More HTML Elements There are many HTML elements you may want to use to customize your page, including headings, lists, and bolded sections. In this next example, we’ll see a few of of these in action. One more thing to note: \u003c!-- --\u003e gives us a comment in HTML, so we’ll use that below to explain some of the elements. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHTML Elements\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- We can create headings using h1 through h6 as tags. --\u003e \u003ch1\u003eA Large Heading\u003c/h1\u003e \u003ch2\u003eA Smaller Heading\u003c/h2\u003e \u003ch6\u003eThe Smallest Heading\u003c/h6\u003e \u003c!-- The strong and i tags give us bold and italics respectively. --\u003e A \u003cstrong\u003ebold\u003c/strong\u003e word and an \u003ci\u003eitalicized\u003c/i\u003e word! \u003c!-- We can link to another page (such as cs50's page) using a. --\u003e View the \u003ca href=\"https://cs50.harvard.edu/\"\u003eCS50 Website\u003c/a\u003e! \u003c!-- We used ul for an unordered list and ol for an ordered one. both ordered and unordered lists contain li, or list items. --\u003e An unordered list: \u003cul\u003e \u003cli\u003efoo\u003c/li\u003e \u003cli\u003ebar\u003c/li\u003e \u003cli\u003ebaz\u003c/li\u003e \u003c/ul\u003e An ordered list: \u003col\u003e \u003cli\u003efoo\u003c/li\u003e \u003cli\u003ebar\u003c/li\u003e \u003cli\u003ebaz\u003c/li\u003e \u003c/ol\u003e \u003c!-- Images require a src attribute, which can be either the path to a file on your computer or the link to an image online. It also includes an alt attribute, which gives a description in case the image can't be loaded. --\u003e An image: \u003cimg src=\"../../images/duck.jpeg\" alt=\"Rubber Duck Picture\"\u003e \u003c!-- We can also see above that for some elements that don't contain other ones, closing tags are not necessary. --\u003e \u003c!-- Here, we use a br tag to add white space to the page. --\u003e \u003cbr/\u003e \u003cbr/\u003e \u003c!-- A few different tags are necessary to create a table. --\u003e \u003ctable\u003e \u003cthead\u003e \u003cth\u003eOcean\u003c/th\u003e \u003cth\u003eAverage Depth\u003c/th\u003e \u003cth\u003eMaximum Depth\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003ePacific\u003c/td\u003e \u003ctd\u003e4280 m\u003c/td\u003e \u003ctd\u003e10911 m\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAtlantic\u003c/td\u003e \u003ctd\u003e3646 m\u003c/td\u003e \u003ctd\u003e8486 m\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003chtml\u003e This page, when rendered, looks something like this: In case you’re worried about it, know that you’ll never have to memorize these elements. It’s very easy to simply search something like “image in HTML” to find the img tag. One resource that’s especially helpful for learning about these elements is W3 Schools. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:2","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Forms Another set of elements that is really important when creating a website is how to collect information from users. You can allow users to enter information using an HTML form, which can contain several different types of input. Later in the course, we’ll learn about how to handle information once a form has been submitted. Just as with other HTML elements, there’s no need to memorize these, and W3 Schools is a great resource for learning about them! \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eForms\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform\u003e \u003cinput type=\"text\" placeholder=\"First Name\" name=\"first\"\u003e \u003cinput type=\"password\" placeholder=\"Password\" name=\"password\"\u003e \u003cdiv\u003e Favorite Color: \u003cinput name=\"color\" type=\"radio\" value=\"blue\"\u003e Blue \u003cinput name=\"color\" type=\"radio\" value=\"green\"\u003e Green \u003cinput name=\"color\" type=\"radio\" value=\"yellow\"\u003e Yellow \u003cinput name=\"color\" type=\"radio\" value=\"red\"\u003e Red \u003c/div\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:3","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"CSS (Cascading Style Sheets) CSS is used to customize the appearance of a website. While we’re just getting, started, we can add a style attribute to any HTML element in order to apply some CSS to it. We change style by altering the CSS properties of an element, writing something like color: blue or text-align: center In this example below, we make a slight change to our very first file to give it a colorful heading: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"color: blue; text-align: center;\"\u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e If we style an outer element, all of the inner elements automatically take on that style. We can see this if we move the styling we just applied from the header tag to the body tag: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody style=\"color: blue; text-align: center;\"\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e While we can style our web page as we’ve done above, to achieve better design, we should be able to move our styling away from the individual lines. One way of doing this is to add your styling between \u003cstyle\u003e tags in the head. Inside these tags, we write which types of elements we want to be style, and the styling we wish to apply to them. For example: \u003chtml lang=\"en\"\u003e \u003c!DOCTYPE html\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003cstyle\u003e h1 { color: blue; text-align: center; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003c/html\u003e Another way is to include in a \u003clink\u003e element in your head with a link to a styles.css file that contains some styling. This means the HTML file would look like: \u003chtml lang=\"en\"\u003e \u003c!DOCTYPE html\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003c/html\u003e And our file called styles.css would look like: h1 { color: blue; text-align: center; } There are far too many CSS properties to go over here, but just like HTML elements, it’s typically easy to Google something along the lines of “change font to blue CSS” to get the result. Some of the most common ones though are: color: the color of text text-align: where elements are placed on the page background-color: can be set to any color width: in pixels or percent of a page height: in pixels or percent of a page padding: how much space should be left inside an element margin: how much space should be left outside an element font-family: type of font for text on page font-size: in pixels border: size type (solid, dashed, etc) color Let’s use some of what we just learned to improve upon our oceans table from above. Here’s some HTML to start us off: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eNicer Table\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003cthead\u003e \u003cth\u003eOcean\u003c/th\u003e \u003cth\u003eAverage Depth\u003c/th\u003e \u003cth\u003eMaximum Depth\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003ePacific\u003c/td\u003e \u003ctd\u003e4280 m\u003c/td\u003e \u003ctd\u003e10911 m\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAtlantic\u003c/td\u003e \u003ctd\u003e3646 m\u003c/td\u003e \u003ctd\u003e8486 m\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003chtml\u003e The above looks a lot like what we had before, but now, either by including a style tag or a link to a stylesheet in the head element, we add the following css: table { border: 1px solid black; border-collapse: collapse; } td { border: 1px solid black; padding: 2px; } th { border: 1px solid black; padding: 2px; } Which leaves us with this nicer-looking table: You may already be thinking that there’s some needless repetition in our CSS at the moment, as td and th have the same styling. We can (and should) condense this down to the following code, using a comma to show the styling should apply to more than one element type. table { border: 1px solid black; border-collapse: collapse; } td, th { border: 1px solid black; padding: 2px; } This is a good introduction into what are known as CSS selectors . There are many ways to determine which HTML elements you are styling, some of which we’ll mention here: element type: this is what we’ve been doing so far: styli","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:4:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Responsive Design Today, many people view websites on devices other than computers, such as smartphones and tablets. It’s important to make sure your website is readable to people on all devices. One way we can achieve this is through knowledge of the viewport. The viewport is the part of the screen that is actually visible to the user at any given time. By default, many webpages assume that the viewport is the same on any device, which is what leads to many sites (especially older ones) being difficult to interact with on mobile devices. One simple way to improve the appearance of a site on a mobile device is to add the following line in the head of our HTML files. This line tells the mobile device to use a viewport that is the same width as that of the device you’re using rather than a much larger one. \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e Another way we can deal with different devices is through media queries. Media queries are ways of changing the style of a page based on how the page is being viewed. For an example of a media query, let’s try to simply change the color of the screen when it shrinks down to a certain size. We signal a media query by typing @media followed by the type of query in parentheses: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eScreen Size\u003c/title\u003e \u003cstyle\u003e @media (min-width: 600px) { body { background-color: red; } } @media (max-width: 599px) { body { background-color: blue; } } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to the page!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e Another way to deal with differing screen size is using a new CSS attribute known as a flexbox. This allows us to easily have elements wrap around to the next line if they don’t fit horizontally. We do this by putting all of our elements in a div that we’ll call our container. We then add some styling to that div specifying that we want to use a flexbox display for the elements inside of it. We’ve also added some additional styling to the inner divs to better illustrate the wrapping that’s occuring here. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eScreen Size\u003c/title\u003e \u003cstyle\u003e #container { display: flex; flex-wrap: wrap; } #container \u003e div { background-color: green; font-size: 20px; margin: 20px; padding: 20px; width: 200px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"container\"\u003e \u003cdiv\u003eSome text 1!\u003c/div\u003e \u003cdiv\u003eSome text 2!\u003c/div\u003e \u003cdiv\u003eSome text 3!\u003c/div\u003e \u003cdiv\u003eSome text 4!\u003c/div\u003e \u003cdiv\u003eSome text 5!\u003c/div\u003e \u003cdiv\u003eSome text 6!\u003c/div\u003e \u003cdiv\u003eSome text 7!\u003c/div\u003e \u003cdiv\u003eSome text 8!\u003c/div\u003e \u003cdiv\u003eSome text 9!\u003c/div\u003e \u003cdiv\u003eSome text 10!\u003c/div\u003e \u003cdiv\u003eSome text 11!\u003c/div\u003e \u003cdiv\u003eSome text 12!\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Another popular way of styling a page is using an HTML grid. In this grid, we can specify style attributes such as column widths and gaps between columns and rows, as demonstrated below. Note that when we specify column widths, we say the third one is auto, meaning it should fill the rest of the page. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cstyle\u003e .grid { background-color: green; display: grid; padding: 20px; grid-column-gap: 20px; grid-row-gap: 10px; grid-template-columns: 200px 200px auto; } .grid-item { background-color: white; font-size: 20px; padding: 20px; text-align: center; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"grid\"\u003e \u003cdiv class=\"grid-item\"\u003e1\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e2\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e3\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e4\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e5\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e6\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e7\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e8\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e9\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e10\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e11\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e12\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:5:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Bootstrap It turns out that there are many libraries that other people have already written that can make the styling of a webpage even simpler. One popular library that we’ll use throughout the course is known as bootstrap. We can include bootstrap in our code by adding a single line to the head of our HTML file: \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"\u003e Next, we can look at some of bootstrap’s features by navigating to the documentation portion of their website. On this page, you’ll find many examples of classes you can add to elements that allow them to be styled with bootstrap. One popular bootstrap feature is their grid system. Bootstrap automatically splits a page into 12 columns, and we can decide how many columns an element takes up by adding the class col-x where x is a number between 1 and 12. For example, in the following page, we have a row of columns of equal width, and then a row where the center column is larger: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"\u003e \u003cstyle\u003e .row \u003e div { padding: 20px; background-color: teal; border: 2px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-4\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-4\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-4\"\u003e This is a third section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cbr/\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-3\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-6\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-3\"\u003e This is a third section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e To improve mobile-responsiveness, bootstrap also allows us to specify column sizes that differ depending on the screen size. In the following example, we use col-lg-3 to show that an element should take up 3 columns on a large screen, and col-sm-6 to show an element should take up 6 columns when the screen is small: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"\u003e \u003cstyle\u003e .row \u003e div { padding: 20px; background-color: teal; border: 2px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a third section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a fourth section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:6:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Sass (Syntactically Awesome Style Sheets) So far, we’ve found a few ways to eliminate redundancy in CSS such as moving it to separate files or using bootstrap, but there are still quite a few places where we can still make improvements. For example, what if we want several elements to have different styles, but for all of them to be the same color? If we decide later we want to change the color, then we would have to change it within several different elements. Sass is a language that allows us to write CSS more efficiently in several ways, one of which is by allowing us to have variables, as in the following example. When writing in Sass, we create a new file with the extension filename.scss. In this file, we can create a new variable by adding a $ before a name, then a colon, then a value. For example, we would write $color: red to set the variable color to the value red. We then access that variable using $color. Here’s an example of our variables.scss file: $color: red; ul { font-size: 14px; color: $color; } ol { font-size: 18px; color: $color; } Now, in order to link this styling to our HTML file, we can’t just link to the .scss file because most web browsers only recognize .css files. To deal with this problem, we have to download a program called Sass onto our computers. Then, in our terminal, we write sass variables.scss:variables.css This command will compile a .scss file named variables.scss into a .css file named variables.css, to which you can add a link in your HTML page. To speed up this process, we can use the command sass --watch variables.scss:variables.css which automatically changes the .css file every time a change is detected in the .scss file. While using Sass, we can also physically nest our styling rather than use the CSS selectors we talked about earlier. For example, if we want to apply some styling only to paragraphs and unordered lists within a div, we can write the following: div { font-size: 18px; p { color: blue; } ul { color: green; } } Once compiled into CSS, we would get a file that looks like: div { font-size: 18px; } div p { color: blue; } div ul { color: green; } One more feature that Sass gives us is known as inheritance. This allows us to create a basic set of styling that can be shared by several different elements. We do this by adding a % before a name of a class, adding some styling, and then later adding the line @extend %classname to the beginning of some styling. For example, the following code applies the styling within the message class to each of the different classes below, resulting in a webpage that looks like the one below. %message { font-family: sans-serif; font-size: 18px; font-weight: bold; border: 1px solid black; padding: 20px; margin: 20px; } .success { @extend %message; background-color: green; } .warning { @extend %message; background-color: orange; } .error { @extend %message; background-color: red; } That wraps up our content for today! ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:7:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["总结"],"content":" 求证的合群，不如自证的孤独 本月主题 ： python爬虫， ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"读书记录 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:1:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"python编程之美 爬虫Request库作者所书，难度适中，封面美丽。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:1:1","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"学习 这个月学习主题多有涉及：vim编辑器、算法复杂度、队列、爬虫解析xpath，re，Bs4、代理爬虫。主要是涉及了爬虫爬虫比我想象中要难，尤其是各种验证码识别，反爬虫破解。已经做到可以爬取豆瓣电影Top250，拉勾网招聘爬虫，小有收获。python csv，json，sql数据库还不太熟悉。4月份打算放一放scrapy先耍耍Django，再回头。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:2:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"投资 耐心等待周期 ☞第一，不要去追求“银弹”，即所谓的低风险甚至无风险的高收益。因为，这种“银弹”会引诱人们动用杠杆或是一把梭，结果可能会有不错的收益，但也有可能出现一系列极其糟糕的结果，而后者在市场里出现的概率更为普遍。当重大损失发生后，而后市场又刚好出现好机会，那么此时的机会必然与自身擦肩而过。 ☞第二，面对市场低迷期，在确定标的长期可持续增长的情况下，持续买入。因为，你耐心地持有，周期的力量会让它的内在价值和价格趋于一致。 ☞第三，持续的学习，只有持续的学习，并习得独立思考判断的能力，才能在耐心等待过程中，识别出机会并抓住它。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:3:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":" 正月已过，重新启程。先做正确的事情，再把事情做对 本月主题 ： 区块链技术入门，密西根Python3 Programming， 如何销售 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"读书记录 区块链革命 没想道会有Apple II之父沃兹尼亚克推荐，可见比特币和区块链技术已经成为了硅谷共识，不得不关注。这本书居区块链入门书籍中高阶部分，所以不像其他区块链通识书籍，阅读起来较为困难，导致豆瓣评分不高。上阵父子兵，没想到写书还有父子兵。Coursera还有两位作者一起创作的Mooc，也以本书为参考教材。本书涉及区块链设计原则较多，而非区块链底层原理。 数字黄金 区块链小白书，豆瓣评分也明显偏高。涉及比特币原理：区块链技术、密码箱原理、分布式账本、挖矿、共识机制。 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:1","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"学习 不得不说国外的Mooc是真TM贴心，云环境，网页编辑器，课本、视频、练习、作业、考核、评论。完全跨过操作系统限制、环境配置、网络，能够体会到背后的用心，这也是我喜欢靠自己自学的原因。课程质量高一圈，体贴程度也是高一圈。下一步玩玩爬虫，做个蜘蛛侠，也巩固下学习内容。 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:2","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"销售 不得不吹一下Box定投践行群，第一期销售训练营也都是实打实的分享，基本上都在我主动边界以外的内容，不加群根本不知道还可以这样做销售，销售也只有一个理念，价值服务。 销售的不是产品，是你自己 过滤你的顾客 顾客买的不是产品，买的为什么 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:3","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"投资 开年以来交易日均值回归，📉跌幅尽在射程范围以内。从预计年化101%直接到20%，我的目标是年化15%足矣。此外张坤的易方达中小盘今年分红竟然有9%，赚钱只有一个姿势：躺 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:4","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"}]