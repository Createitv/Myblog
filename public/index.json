[{"categories":[],"content":"Createitv","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"常见的加密算法可以分成三类 MD5、hash256、hash1、hash128 对称加密算法：AES、DES 非对称加密算法：RSA、… ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"Hash MD5算法： Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。一般为32位 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"特点 优点：不可逆、易计算、特征化 缺点：可能存在散列冲突 使用场景：文件或字符串一致性校验、数字签名、鉴权协议 对于 MD5 而言，有两个特性是很重要的，第一：明文数据经过散列以后的值是定长的；第二：是任意一段明文数据，经过散列以后，其结果必须永远是不变的。 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:1","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"python版本 import hashlib password = \"w3213xcas0\" print(hashlib.md5(password.encode(\"utf-8\")).hexdigest()) print(len(\"3e356fc9115d18c86e445ce2475a0961\")) # output \u003e\u003e 3e356fc9115d18c86e445ce2475a0961 \u003e\u003e 32 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:2","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"JS版本 const crypto = require(\"crypto\"); //引入crypto加密模块 // update()方法默认字符串编码为UTF-8，也可以传入Buffer。 // 如果要计算SHA1，只需要把'md5'改成'sha1'，就可以得到SHA1的结果 const hash = crypto.createHash(\"md5\"); //规定使用哈希算法中的MD5算法 password = \"w3213xcas0\"; // 可任意多次调用update(),效果相当于多个字符串相加 hash.update(password); //最终加密的字符串为'w3213xcas0',hash.digest('hex')表示输出的格式为16进制 console.log(hash.digest(\"hex\")); console.log(hash.digest(\"hex\").length); # output \u003e\u003e 3e356fc9115d18c86e445ce2475a0961 \u003e\u003e 32 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:3","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"MD5结合密钥加密 const crypto = require(\"crypto\"); function md5(text) { return crypto.createHash(\"md5\").update(text).digest(\"hex\"); } var str = \"123\"; var md5_suffix = \"9d0f0dakdllwlelldda,x,,axx2\"; //md5_suffix作为秘钥,越复杂越好 var FinalPass = md5(str + md5_suffix); console.log(FinalPass); ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:4","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"sha256 import hashlib password = \"w3213xcas0\" + \"dasdasd\" print(hashlib.sha256(password.encode(\"utf-8\")).hexdigest()) print(len(\"998b2d30d19311f48758bc5601913edf66db6932eb14d39ab8a6b114f96973f4\")) # output \u003e\u003e 998b2d30d19311f48758bc5601913edf66db6932eb14d39ab8a6b114f96973f4 \u003e\u003e 64 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:5","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"BASE64 Base64 编码只是一种编码格式并不是加密算法，它可用于在 HTTP 环境下传递较长的标识信息。 特点 可以将任意的二进制数据进行 Base64 编码 数据加密之后，数据量会变大，变大 1/3 左右 编码后有个非常显著的特点，末尾有个=号 可进行反向解码 Base64 编码具有不可读性 import base64 print(base64.b64encode(b\"binary\\x00string\")) print(base64.b64decode(b\"YmluYXJ5AHN0cmluZw==\")) # output \u003e\u003e b'YmluYXJ5AHN0cmluZw==' \u003e\u003e b'binary\\x00string' ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:6","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"对称加密 1、什么是对称加密？ 对称加密就是指，加密和解密使用同一个密钥的加密方式。 2、对称加密的工作过程 发送方使用密钥将明文数据加密成密文，然后发送出去，接收方收到密文后，使用同一个密钥将密文解密成明文读取。 3、对称加密的优点 加密计算量小、速度块，适合对大量数据进行加密的场景。（记住这个特点，实际使用是会用到的） 4、对称加密的两大不足 密钥传输问题：如上所说，由于对称加密的加密和解密使用的是同一个密钥，所以对称加密的安全性就不仅仅取决于加密算法本身的强度，更取决于密钥是否被安全的保管，因此加密者如何把密钥安全的传递到解密者手里，就成了对称加密面临的关键问题。（比如，我们客户端肯定不能直接存储对称加密的密钥，因为被反编译之后，密钥就泄露了，数据安全性就得不到保障，所以实际中我们一般都是客户端向服务端请求对称加密的密钥，而且密钥还得用非对称加密加密后再传输。） ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"什么是AES加密算法 针对对称加密的话，是有很多的对称加密算法的，如DES加密算法、3DES加密算法等，但是因为AES加密算法的安全性要高于DES和3DES，所以AES已经成为了主要的对称加密算法，因此本篇主要学习一下AES加密算法。 AES加密算法就是众多对称加密算法中的一种，它的英文全称是Advanced Encryption Standard，翻译过来是高级加密标准，它是用来替代之前的DES加密算法的。 AES加密算法采用分组密码体制，每个分组数据的长度为128位16个字节，密钥长度可以是128位16个字节、192位或256位，一共有四种加密模式，我们通常采用需要初始向量IV的CBC模式，初始向量的长度也是128位16个字节。 from Crypto.Cipher import AES import base64 BLOCK_SIZE = 16 # Bytes def pad(s): return s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \\ chr(BLOCK_SIZE - len(s) % BLOCK_SIZE) def unpad(s): return s[:-ord(s[len(s) - 1:])] def aesEncrypt(key, data): ''' AES的ECB模式加密方法 :param key: 密钥 :param data:被加密字符串（明文） :return:密文 ''' key = key.encode('utf8') # 字符串补位 data = pad(data) cipher = AES.new(key, AES.MODE_ECB) # 加密后得到的是bytes类型的数据，使用Base64进行编码,返回byte字符串 result = cipher.encrypt(data.encode()) encodestrs = base64.b64encode(result) enctext = encodestrs.decode('utf8') print(enctext) return enctext def aesDecrypt(key, data): ''' :param key: 密钥 :param data: 加密后的数据（密文） :return:明文 ''' key = key.encode('utf8') data = base64.b64decode(data) cipher = AES.new(key, AES.MODE_ECB) # 去补位 text_decrypted = unpad(cipher.decrypt(data)) text_decrypted = text_decrypted.decode('utf8') print(text_decrypted) return text_decrypted if __name__ == '__main__': key = '5c44c819appsapi0' data = 'herish acorn' ecdata = aesEncrypt(key, data) aesDecrypt(key, ecdata) ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:1","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"非对称加密 一、非对称加密算法 1、乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 2、甲方获取乙方的公钥，然后用它对信息加密。 3、乙方得到加密后的信息，用私钥解密。 二、RSA算法 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的\"非对称加密算法\"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。 这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:0","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"使用openssl 工具生成RSA 私钥和秘钥 生成私钥 openssl genrsa -out rsa_private_key.pem 1024 生成公钥 openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:1","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"python版本 import base64 from Crypto.PublicKey import RSA from Crypto.Hash import SHA from Crypto.Signature import PKCS1_v1_5 as PKCS1_signature from Crypto.Cipher import PKCS1_v1_5 as PKCS1_cipher def get_key(key_file): with open(key_file) as f: data = f.read() key = RSA.importKey(data) return key def encrypt_data(msg): public_key = get_key('rsa_public_key.pem') cipher = PKCS1_cipher.new(public_key) encrypt_text = base64.b64encode(cipher.encrypt(bytes(msg.encode(\"utf8\")))) return encrypt_text.decode('utf-8') def decrypt_data(encrypt_msg): private_key = get_key('rsa_private_key.pem') cipher = PKCS1_cipher.new(private_key) back_text = cipher.decrypt(base64.b64decode(encrypt_msg), 0) return back_text.decode('utf-8') def test_encrypt_decrypt(): msg = \"coolpython.net\" encrypt_text = encrypt_data(msg) decrypt_text = decrypt_data(encrypt_text) print(msg == decrypt_text) if __name__ == '__main__': msg = \"coolpython.net\" encrypt_text = encrypt_data(msg) print(encrypt_text) print(decrypt_data(encrypt_text)) test_encrypt_decrypt() # output \u003e\u003e\u003e eR5fRxkvKZA5sPCw1MEwjiqjkdI6/aQtGqbdwauaCIaM1WISSBmKMXZ7EflZXmR3a21wEWZ3rVCZzTYSypPjofPIAmZFH2sN20pTJ2iY9bnp+m5klWaHSa/2FcNurAzy7NcL1r+3tfGnMh5bHN81BYwtTOaVuYlD7Z3IBAf7RpY= \u003e\u003e\u003e coolpython.net \u003e\u003e\u003e True ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:2","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":[],"content":"javascript版本 const fs = require(\"fs\"); const NodeRSA = require(\"node-rsa\"); const a_public_key_data = fs.readFileSync(\"./rsa_public_key.pem\", \"utf8\"); const a_private_key_data = fs.readFileSync(\"./rsa_private_key.pem\", \"utf8\"); // console.log(a_public_key_data); // console.log(a_private_key_data); const a_public_key = new NodeRSA(a_public_key_data); const a_private_key = new NodeRSA(a_private_key_data); const text = \"coolpython.net\"; const sign = a_private_key.sign(text, \"base64\", \"utf8\"); console.log(\"A 私钥加签:\", sign); const encrypted = a_public_key.encrypt(sign, \"base64\"); console.log(\"A 公钥加密:\", encrypted); // 解密并验签 const decrypted = a_private_key.decrypt(encrypted, \"utf8\"); console.log(\"A 私钥解密:\", decrypted); const verify = a_public_key.verify(text, decrypted, \"utf8\", \"base64\"); console.log(\"A 公钥验签:\", verify); // output \u003e\u003e\u003e A 私钥加密: PoYV1td/yKT8YgcP5R6RlHRQmmBv4cWO8p7nuEH8YpZ1Q0KvrwQ/r3vY+/b3Gjf7Ubr4xbApADzXtjASekey+dc1io85OCZ4Rodf2+k2/hrUbbExUDoc9arBgY5QBAgqd88xfjR5U+hovnSwhUVvALlXONJpqjeLLcH9grWwAhs= \u003e\u003e\u003e A 公钥加密: UBAONDQY1ZGHVTT3BzKEYIFGgJcYCLZEanLbdWDYsiZ3xXqWX7zTpiX35F30lob/fgXCRoOnNLTxLwzN82BOW6OIEm9C4AOM4V72KTEP/6PUzEESCelpqc2tOJXpiBM/mlAhEodCjQV8qU7+k5wHm7uMc5uH2Eov2SkjEiqlUC2gkr04KBd1a6U5T3cWyme9qv65aFVAAOhuq+Cf30C8hM4g3NZml/QcMn4PJZettkOMo8KRSG+vxJpyR/q0pxIC5AuZl9IoMotWGGgfEC6GRbvDL95FDA3CacZopJWktGuNLAHzanMGn2wfQBHmn22yGeTUcDgfvV459UlON9UAeg== \u003e\u003e\u003e A 私钥解密: PoYV1td/yKT8YgcP5R6RlHRQmmBv4cWO8p7nuEH8YpZ1Q0KvrwQ/r3vY+/b3Gjf7Ubr4xbApADzXtjASekey+dc1io85OCZ4Rodf2+k2/hrUbbExUDoc9arBgY5QBAgqd88xfjR5U+hovnSwhUVvALlXONJpqjeLLcH9grWwAhs= \u003e\u003e\u003e A 公钥验密: true RSA加密，私钥都是一样的，公钥每次加密的结果不一样跟对数据的padding（填充）有关。 1、Padding (填充)属性定义元素边框与元素内容之间的空间。 2、padding 简写属性在一个声明中设置所有内边距属性。设置所有当前或者指定元素内边距属性。该属性可以有1到4个值。 3、当元素的 Padding(填充)(内边距)被清除时，所\"释放\"的区域将会受到元素背景颜色的填充。 4、单独使用填充属性是在一个声明中设置元素的所内边距属性。缩写填充属性也可以使用，一旦改变一个数值，则padding对应的距离都会改变。 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:3","tags":["加密算法"],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Vim"],"content":"Createitv","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim文件编辑 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:1:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"插入 e 编辑文件 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件 i 光标前插入 I 行首插入 o 下一行插入 O 上一行插入 a 光标后插入 A 行尾插入 s 删除当前字符并进入插入模式 S 删除当前行并进入插入模式 r 替换当前字符 R 替换当前光标的字符直到退出插入模式 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:1:1","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"复制粘贴 yw 拷贝当前的一个单词 y0 拷贝的范围是当前光标处到行首 y^ 同上 y$ 拷贝的范围是当前光标处到行尾 yy 拷贝当前行 Y 同上 Nyy 从当前行开始拷贝 N 行 yf + 字符 复制从当前字符到指定字符 yG 拷贝当前行到文件尾 ygg 拷贝当前行到文件头 ggyG 复制整个文件 \"+y 复制到系统剪切板 \"+p 粘贴剪切板中的内容 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:1:2","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim移动 单位级 h 向左一字符 j 下一行 k 上一行 l 向右一字符 单词级 w or W 向右移动到下一单词开头 e or E 向右移动到单词结尾 b or B 向左移动到单词开头 * 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 注：所有小写单词都是以分词符作为单词界限，大写字母以空格作为界限。 块级 ( 移动到当前句子开头 ) 移动到下一句子开头 { 移动到当前段落开头 } 移动到下一段落开头 + 移动到下一行开头 - 移动到上一行开头 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 gg 到文档第一行 G 到文档最后一行 0, | 到行首（第 1 列） ^ 到第一个非空白字符 $ 到行尾 0nl, n| 到当前行的第n 列 g_ 到当前行的最后一个非空格字符处 H 到屏幕的首行 L 到屏幕尾行 M 到屏幕中间 % 到匹配的括号（包括小括号、中括号、大括号） zt 将当前行移到屏幕顶部 zz 将当前行移到屏幕中部 zb 将当前行移到屏幕底部 Ctrl-d 向下移动半页 Ctrl-u 向上移动半页 Ctrl-f 向下移动一页 Ctrl-b 向上移动一页 :\u003cN\u003e or \u003cN\u003egg 跳转到第 N 行 :+\u003cN\u003e or \u003cN\u003ej 向下跳 N 行 :-\u003cN\u003e or \u003cN\u003ek 向上跳 N 行 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:2:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim修改 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:3:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"c字符 c 修改命令 change,复合命令,修改后进入插入模式 cw修改一个单词 cb向后修改一个单词 ct)修改知道碰到符号） ci) 修改)内的内容 ca)修改)内的内容包括） cc删除整行保持缩进并进入编辑模式 diw删除光标所在的单词=\u003e d inside word ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:3:1","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"d字符 只删除还是在普通模式 dw删除一个单词 db向后伤处一个单词 d4l向右删除4个字符 dd删除一正行 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:3:2","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim回退 u撤销 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:4:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["git"],"content":"Createitv","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 的故事 十年前的这一周，Linux 内核开发社区正面临严峻的挑战：他们不能继续使用 BitKeeper 了（注：原因是当时BitKeeper 著作权所有者决定收回授权，内核开发团队与其协商无果），而又没有其他的 SCM （Software Configuration Management）可满足他们的分布式系统的需求。Linux 之父 Linus Torvalds 接受了这个挑战，决定开发一个新的版本控制系统。周末他消失了，新的一周，Git 问世了。今天，Git 已经成为上万个项目的版本控制系统，并且在程序员中引发了开源热潮。 git /gɪt/ 是一个开源的分布式版本控制系统 最初是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:1:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"有关版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。可以对任何类型的文件进行版本控制，便于不同的开发者协同工作 集中式版本控制 集中化的版本控制系统是为了让不同系统上的开发者协同工作。例如 SVN，它会有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人通过客户端连接到这台服务器，拉取最新的文件或者是提交更新 在这个系统中，每个人可以看到项目中其他人的工作，管理员也能很好的掌握和分配每个开发者的权限。但由于版本库是集中在服务器上的，如果出现了中央服务器的单点故障，在这个时间内，谁都无法提交更新，而且整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险 分布式版本控制 分布式的版本控制解决了集中化版本控制的一些问题，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:2:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 介绍 直接记录快照，而非差异比较 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照 Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它会对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成， Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用 Git 一般只添加数据 执行的 Git 操作，几乎只往 Git 数据库中增加数据 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:3:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 使用参考 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:4:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"1. 安装 brew install git ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:4:1","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"2. 配置 --global电脑全局配置，该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。你也可以在项目内配置项目的 git，配置完后可以使用 git config --list 查看配置信息 $ git config --global user.name \"zou\" $ git config --global user.email zouxq412@foxmail.com ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:4:2","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 基本使用 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"1. Git 工作区、暂存区和版本库 在了解 Git 的基本操作之前，我们先来了解 Git 工作区、暂存区和版本库的概念 在 Git 中的文件有三种状态：已提交(committed)： 表示数据已经安全的保存在本地数据库中；已修改(modified)： 表示修改了文件，但还没保存到数据库中；已暂存(staged)： 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此也引入了 Git 项目的三个工作区域的概念： 工作区： 就是项目文件所在的目录 暂存区： stage 或 index。一般存放在 .git/index 文件中，所以我们把暂存区有时也叫作索引 版本库： 工作区下隐藏目录 .git，这里记录着仓库的版本信息和历史记录 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:1","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"2.命令介绍 git init # 初始化git仓库，创建git配置文件 git add . # 添加所有文件到暂存区 git commit -m \"\u003cmsg\u003e\" # 提交文件更新 git commit -a \"\u003cmsg\u003e\" # 等于第上两步，直接跳过git add 步骤 git reset HEAD \u003cfile\u003e... # 用来取消已暂存的内容 git status # 参看git工作区状态 git rm \u003cfile\u003e # 记录此次移除文件的操作 git rm -f \u003cfile\u003e # 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可 git mv # 命令用于移动或重命名一个文件、目录、软连接 git checkout \u003cfile\u003e # 文件回退 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:2","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"3. 上传 github git remote add origin \u003curl\u003e # 添加一个新的远程 Git 仓库 git push -u origin master # 本地仓库或把已存在的仓库推到 github仓库上 git fetch # 命令会将数据拉取到你的本地仓库 git merge # 合并分支 git pull \u003cremote\u003e \u003cbranch\u003e # 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支 git remote rename # 去修改一个远程仓库的简写名 git remote rm [name] # 可以去移除一个远程仓库 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:3","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"4.标签管理 git tag #查看所有的标签 git tag \u003cname\u003e #创建标签 git tag -v \u003cname\u003e -m \u003cmessage\u003e # 创建附注标签 git push origin [tagname] #推送标签到远程仓库 git tag -d \u003ctagname\u003e #删除本地仓库标签 git push \u003cremote\u003e :refs/tags/\u003ctagname\u003e #更新远程仓库标签 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:4","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"5.分支管理 git branch #列出分支，当前分支前面会标一个*号 git branch \u003cbranchname\u003e #创建分支 git checkout \u003cbranchname\u003e #切换分支 git checkout -b \u003cbranchname\u003e #创建并切换分支 git merge #合并分支 git branch -d \u003cbranchname\u003e #删除分支 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:5","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"参考 Git 10 周年访谈：Linus Torvalds 讲述背后故事 常用 Git 命令清单 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:6:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["JAVA"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/javase/","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"1.Java 概述 Java 编程语言是一种通用的、并行的、基于类的、面向对象的语言。它被设计得非常简单，这样程序员可以在该语言上流畅的交流。Java 编程语言与 C 和 C++ 有关联，但组织却截然不同，其中也省略了其他语言的一些用法，比如指针。它的目的是作为一个生产性语言，而不是一个研究性语言，因此，在设计上避免了包括新的和未经考验的功能。 Java 编程语言是强类型和静态类型，可以在编译时检测到编译时错误。编译时间通常由翻译程序到与机器无关的字节码表示的。运行时的活动包括加载和执行程序，可选机器代码生成和程序的动态优化所需的类的交联，和实际执行程序。 Java 编程语言是一个比较高层次的语言，在机器表示的细节是无法通过该语言的。它包括自动存储管理，通常使用垃圾收集器，以避免明确释放的安全问题（就像 C 语言的 free 或 C++ 的 delete）。高性能垃圾回收的实现可具有有界的停顿，以支持系统的编程和实时应用。语言不包括任何不安全的结构，如没有索引检查的数组访问，因为这种不安全的结构会导致不可预知的程序行为。 ","date":"2021-07-27","objectID":"/posts/javase/:1:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"语言起源 　Java平台和语言最开始只是SUN公司在1990年12月开始研究的一个内部项目。SUN公司的一个叫做帕特里克·诺顿的工程师被自己开发的C和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth计划”的项目的机会。 “Stealth计划”后来改名为“Green计划”，JGosling（詹姆斯·高斯林）和麦克·舍林丹也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，SUN公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C语言，但是很多成员包括SUN的首席科学家比尔·乔伊，发现C和可用的API在某些方面存在很大问题。 工作小组使用的是内嵌类型平台，可以用的资源极其有限。很多成员发现C太复杂以至很多开发者经常错误使用。他们发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。 根据可用的资金，比尔·乔伊决定开发一种集C语言和Mesa语言搭成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议SUN公司的工程师应该在C的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C的功能，他自己称这种新语言为C–，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的树而命名。 就像很多开发新技术的秘密的工程一样，工作小组没日没夜地工作到了1992年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库，和其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。 同年11月，Green计划被转化成了“FirstPerson有限公司”，一个SUN公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度互动的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Requestforproposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多地控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司再并回SUN公司。 1994年6、7月间，在经历了一场历时三天的头脑风暴的讨论之后，约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·斯库米，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。同年，Oak改名为Java。商标搜索显示，Oak已被一家显卡制造商注册，因此团队找到了一个新名字。这个名字是在很多成员常去的本地咖啡馆中杜撰出来的。名字是不是首字母缩写还不清楚，很大程度上来说不是。虽然有人声称是开发人员名字的组合：JamesGosling（詹姆斯·高斯林）ArthurVanHoff（阿瑟·凡·霍夫）AndyBechtolsheim（安迪·贝克托克姆），或“JustAnotherVagueAcronym”（只是另外一个含糊的缩写）。还有一种比较可信的说法是这个名字是出于对咖啡的喜爱，所以以Java咖啡来命名。类文件的前四个字节如果用十六进制阅读的话，分别为“CAFEBABE”，就会拼出两个单词“CAFEBABE”（咖啡宝贝）。 　1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年5月23日SunWorld大会上进行的。SUN公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，Sun公司成立了Java业务集团，专门开发Java技术。 ","date":"2021-07-27","objectID":"/posts/javase/:1:1","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"发展简史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为JavaSE5.0 2005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME 2006年12月，SUN公司发布JRE6.0 2009年4月7日GoogleAppEngine开始支持Java 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。 2011年7月28日，甲骨文发布java7.0的正式版。 2014年3月19日，甲骨文公司发布java8.0的正式版。 ","date":"2021-07-27","objectID":"/posts/javase/:1:2","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"Java 语言与 Java 虚拟机的关系 什么是 Java 虚拟机 Java 虚拟机(Java Virtual Machine,简称 JVM) 是整个 Java 平台的基石，实现硬件与操作系统无关，编译代码后生成出极小体积，保障用户机器免于恶意代码损害。 JVM 可以看作是一台抽象的计算机。跟真实的计算机一样，它有自己的指令集以及各种运行时内存区域。使用虚拟机来实现一门程序设计语言有许多合理的理由，业界中流传最为久远的虚拟机可能是 UCSD Pascal 的 P-Code 虚拟机。 第一个 JVM 的原型机是由 Sun 公司实现的，它被用在一种类似 PDA（Personal Digital Assistant，俗称掌上电脑）的手持设备上仿真实现 JVM 指令集。时至今日，Oracle 已有许多 JVM 实现应用于移动设备、桌面电脑、服务器等领域。JVM 并不局限于特定的实现技术、主机硬件和操作系统。它不强求使用解释器来执行程序，也可以通过把自己的指令集编译为实际 CPU 的指令来实现，它可以通过微代码来实现，或者甚至直接实现在 CPU 中。 Java 语言与 JVM 的关系 JVM 与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 class 文件格式所关联。class 文件中包含了 JVM 指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。 基于安全方面的考虑，JVM 要求在 class 文件中使用了许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 JVM 接收的有效的 class 文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将 JVM 作为他们语言的产品交付媒介。 如上图所示，在 Java 编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把 Java 的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。当你写好一个 Java 程序后，源语言的语句将由Java 编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel 的 Pentium 微处理器或 IBM 的 System/390 处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。 ","date":"2021-07-27","objectID":"/posts/javase/:1:3","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"2.变量、数据类型和运算符 定义格式 // 数据类型 变量名 = 初始化值; （声明、赋值）int num1 = 123; 使用注意 同一作用域内同一变量不可重复声明 变量必须初始化后才能使用（即必须有值才能使用），否则编译报错 变量的值可在同一类型不断变化 变量命名符合标识符规范，使用驼峰命名法，首字母小写 就近原则 ","date":"2021-07-27","objectID":"/posts/javase/:2:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"变量的分类及作用域 图 1 变量分类 图 2 不同数据类型的成员变量的初始值 成员变量/全局变量/字段：直接定义在类中，方法外的变量 类变量 使用 static 修饰的字段 方法区 实例变量 没有使用 static 修饰的字段 堆 默认是有初始值的，可以先在方法中使用后定义 作用域是整个类 局部变量 方法的形参；2. 方法内中的变量；3.代码块中的变量 没有初始值，必须显式初始化后才能使用 定义局部变量后，系统并未分配内存空间，直到程序为这个变量赋值时，系统才会在所在方法的的栈内存中为局部变量分配内存，并将初始值（基本类型的值或者对象的引用）保存在该内存中 从 定义的位置 开始到所在结束的花括号 ","date":"2021-07-27","objectID":"/posts/javase/:2:1","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"数据类型的分类 图 3 数据类型分类 图 4 基本数据类型范围 图 5 基本类型 ","date":"2021-07-27","objectID":"/posts/javase/:2:2","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"boolean 类型 常量值只能是 true 或 false boolean isMan = true; ","date":"2021-07-27","objectID":"/posts/javase/:2:3","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"字符类型 char 16 位 Unicode 字符集，编码方式为 UTF-16BE UTF-16 使用 2 或者 4 字节表示一个字符，在 65536 以内的占两个字节，而基本上所有汉字的 Unicode 编码在 19968 到 40869 之间，所以一个 char 类型可以存储一个汉字 使用' ' 括起来 49'1'; 65 ‘A’; 97 ‘a’ // 表示形式 char c1 = 'A'; // 使用单个字符 char c2 = 65; // 使用十进制的整数（Unicode 值），[0, 65535] char c3 = '\\u0061'; // 使用十六进制的整数，格式'\\uXXXX'，('\\u0000'~'\\u00FF') ","date":"2021-07-27","objectID":"/posts/javase/:2:4","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"运算符 // 算数运算符 + - * / % ++ -- // 比较运算符 == != \u003c \u003e \u003c= \u003e= instanceof // 三目运算符 String ret = number % 2 == 0 ? \"偶数\" : \"奇数\"; // 逻辑运算符 \u0026\u0026 || ^ ! // 位运算符 \u0026 | ~ \u003c\u003c \u003e\u003e \u003e\u003e\u003e 自增 ++ 自减 — 自增、自减操作都是直接修改变量的值（读、改、写），不经过操作数栈 前置 ( ++i )：局部变量表中的 i 先自增，再把 i 的值压入操作数栈 后置 ( i++ )：先把局部变量表中的 i 压入操作数栈，再自增 int i = 1;i = ++i;System.out.println(i); // 2int j = 1;j = j++;System.out.println(j); // 1 ","date":"2021-07-27","objectID":"/posts/javase/:2:5","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"3.流程控制 if-else 语句 if (boolean 表达式 或 boolean 变量) { 条件执行体 1 // 为 true 时执行 } else { 条件执行体 2 // 为 false 时执行 } while 语句 while (boolean 表达式) { 循环体; 迭代语句; // 自增或自减，用于对循环次数的控制 } for循环 for (初始化语句; boolean 表达式; 迭代语句) { 循环体; } 循环控制 break：结束当前 break 所在的整个循环 continue：跳过 continue 所在的本次循环剩下语句，开始下一次循环 ","date":"2021-07-27","objectID":"/posts/javase/:3:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"4.方法 格式 [修饰符] 返回值类型 方法名([参数类型 形参 1, 参数类型 形参 2, ...]) { // 方法体; [return 返回值]; // 当方法需要给调用者返回值时 } 当方法无返回值时，必须给出返回类型 void 参数列表 / 参数清单，包含参数的个数、参数类型、 参数顺序 方法签名：方法名 + 方法参数列表，判断是否是同一个方法的标准 在同一个类中，方法签名是唯一的，否则编译报错 考虑当调用者传入数据的范围不合理时，该如何处理（进行参数校验） ","date":"2021-07-27","objectID":"/posts/javase/:4:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"5.数组 声明 int[] arr; // 数组元素类型[] 数组名; int arr[]; // 数组元素类型 数组名[]; // 不推荐 初始化 // 静态初始化 // 数组名 = new 数组元素类型[] {元素 1, 元素 2, ...}; // 在堆空间开辟一块内存区域来存储数组的元素（new） // 将 该内存区域的地址值 赋值给 该数组的引用变量 arr（引用） int[] arr = new int[] {1, 2, 3}; // 简单写法，必须声明的同时作初始化 // 数组元素类型[] 数组名 = {元素 1, 元素 2, ...}; int[] arr = {1, 2, 3}; // 动态初始化，系统自动为数组元素分配初始值 // 数组名 = new 数组元素类型[length]; int[] arr = new int[3]; // [0, 0, 0] 变量必须初始化后才能使用 数组是定长的：数组一旦初始化完成，数组的长度就固定了，不能更改，除非重新做初始化 数组是引用数据类型，可以赋值为 null，表示没有引用任何内存空间 new 关键字：在堆空间开辟一块内存区域，用来存储数据 操作数组常见异常：NullPointerException：空指针异常（没有引用地址值）ArrayIndexOutOfBoundsException：数组的索引越界异常 基本操作 int[] arr = new int[] {1, 2, 3}; // 访问数组元素 数组变量[索引值] int len = arr.length; // 数组长度，length 是属性，索引范围 [0, arr.length - 1] int num = arr[0]; arr[0] = 11; // 遍历 // 普通 for 循环 for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } // 增强 for 循环（for-each） // 只能访问数组元素，不能赋值，不关心数组的索引时使用 // 当数组元素是引用类型时，不建议使用（需要先知道值不为 null 的元素个数） for (int ele : arr) { System.out.println(ele); } // 反编译后 int ai[] = arr; int k = ai.length; for (int j = 0; j \u003c k; j++) { int i = ai[j]; // 使用循环迭代出数组中的每一个元素并赋值给 i System.out.println(i); // 操作 i } // 打印数组元素 // 直接打印数组名时，打印出来是数组对应的 hashCode 值，如 [I@15db9742, [D@15db9742, [Ljava.lang.String;@15db9742 static String toString(int[] arr) { // 判断数组是否为空 if (arr == null) { return \"null\"; // 结束方法 } if (arr.length == 0) { return \"[]\"; } String ret = \"[\"; // 先拼接\"[\" for (int index = 0; index \u003c arr.length; index++) { // 如果不是最后一个元素，拼接 元素 + \", \"，否则拼接 元素 + \"]\" ret = (index != arr.length - 1) ? ret + arr[index] + \", \" : ret + arr[index] + \"]\"; } return ret; } 二分查找 // 从有序数组中查找 key 第一次出现的位置 // 二分搜索法/二分查找法/折半查找 // 前提：数组的元素是有序排列的 // 区间位置：如果 arr[mid] != key，下一次是以 mid + 1 作为下一个起始位置，或者 mid - 1 作为下一个结束位置 // 退出循环的条件：low \u003e high static int binarySearch(int[] arr, int key) { int low = 0; int high = arr.length - 1; while (low \u003c= high) { int mid = (low + high) \u003e\u003e 1; if (arr[mid] \u003c key) { low = mid + 1; } else if (arr[mid] \u003e key) { high = mid - 1; } else { while (mid - 1 \u003e= 0 \u0026\u0026 arr[mid -1] == key) { mid--; } return mid; } } return -1; } Arrays java.util.Arrays 中的类方法： String toString(Object[] arr)：将 a 数组转换成一个字符串，括在方括号（\"[]\"）中，相邻元素用字符 “, “（逗号加空格）分隔 void sort(Object[] a)：根据元素的自然顺序对指定对象数组按升序进行排序，数组中的所有元素都必须实现 Comparable 接口（对于原始数据类型，使用所谓双轴快速排序（Dual-Pivot QuickSort），对于对象数据类型，使用 TimSort） void sort(T[] a, Comparator\u003c? super T\u003e c)：根据指定比较器产生的顺序对指定对象数组进行排序 void parallelSort(Object[] a)：以并发的方式对 a 数组的数组元素进行排序 void setAll(T[] array, IntFunction\u003cT\u003e generator)：使用提供的函数计算每一个元素的值，对指定数组中的所有元素进行设置 void parallelSetAll(T[] array, IntFunction\u003cT\u003e generator)：以并发的方式，使用提供的函数计算每一个元素的值，对指定数组中的所有元素进行设置 type binarySearch(Object[] a, type key)：使用二分法査询 key 元素值在 a 数组中出现的索引，如果 a 数组不包含 key 元素值，则返回 -(low + 1)（调用该方法时要求数组中元素已经按升序排列） boolean equals(Object[] a, Object[] a2)：如果 a 数组和 a2 数组的长度相等，且 a 数组和 a2 数组的数组元素也一一相同，该方法将返回 true Object[] copyOf(Object[] original, int newLength)：复制 original 数组，截取或用 0（数值类型）、false（布尔类型）或者 null（引用类型）填充，以使新数组的长度为 newLength List\u003cT\u003e asList(T… a)：把一个引用类型的数组或指定个数的对象转换成固定长度的 List（Arrays.ArrayList），只能遍历访问该集合里的元素，不可增加、删除该集合里的元素，否则会引发 UnsupportedOperationException ","date":"2021-07-27","objectID":"/posts/javase/:5:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"6.java修饰符 图 1 修饰符适用范围 访问权限修饰符 用于控制一个类的成员是否可以在其它类中访问，不能修饰局部变量 图 2 访问权限修饰符 private（当前类访问权限）：在同一类内可见，只能被所属类访问 （包访问权限）：不使用任何修饰符时，在同一包内可见 protected（子类访问权限）：对同一包内的任何其它类和不同包中的子类可见，不能修饰接口中的成员变量和成员方法（注意：在不同包中的子类只能通过该子类访问父类中 protected 成员，通过其它子类或父类都无法访问） public（公共访问权限）：对所有类可见 非访问修饰符 static 用来创建类方法和类变量，类方法不能访问的实例变量 final 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不可修改 abstract 用来创建抽象类、抽象方法 synchronized 修饰的方法、代码块在同一时间只能被一个线程访问，不能修饰构造器、成员变量等 volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值；并且，当成员变量发生变化时，强迫线程将变化值回写到共享内存（保证了线程操作时变量的可见性，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的）（只能保证内存可见性，无法保证操作的原子性） transient 序列化的对象包含被 transient 修饰的实例变量时，JVM 跳过该特定的变量 native 修饰的方法通常采用 C/C++ 语言来实现 volatile 的实现原理 如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到内存，这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效 缓存一致性协议（如 Intel 的 MESI 协议）：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里 final 修饰符 表示最终的类，不可被继承的类 java 里 final 修饰的类有很多，比如八大基本数据类型包装类和 String 类，也是不可变类（当创建它们的实例后，其实例的实例变量不可改变） final 修饰的方法 最终的方法，该方法子类可以调用，但不允许被子类覆盖 构造方法不能使用 final 修饰 final 修饰的变量 最终的变量，常量，该变量只能被赋值一次 final 修饰的成员变量必须显式指定初始值（定义时、初始化块或构造器中指定），系统不会为 final 字段初始化；静态常量的单词全部大写，单词间使用下划线隔开 final int MAX_VALUE = …; final 是唯一可以修饰局部变量的修饰符 final 修饰基本类型的变量，表示该变量不能被重新赋值 final 修饰引用类型的变量，表示该变量所引用的地址不能变，而所引用对象的内容可以改变 可执行“宏替换”的 final 变量：当定义 final 变量时就为该变量指定了初始值，编译器会把程序中所有用到该变量的地方直接替换成该变量的值（在编译阶段能确定的内容只能来自于常量池中） ","date":"2021-07-27","objectID":"/posts/javase/:6:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"7.类与对象 定义 对象是类的实例，类是对象的抽象 类可被认为是一种自定义的数据类型，可以使用类来定义变量 类中的成员：字段（成员变量）、构造器、方法、初始化块、内部类（包括接口、枚举） 外部类只能有两种访问控制级别：public 和 缺省 定义类的语法格式 [修饰符] class 类名 { 0-N 成员变量（字段） // 描述类具有的特性，对象的状态 0-N 构造器定义 0-N 方法 // 描述类具有的功能，对象的行为 } ","date":"2021-07-27","objectID":"/posts/javase/:7:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"1. 异步编程介绍 除了顺序执行和并行执行的模型之外，还有第三种模型，叫做异步模型，这是事件驱动模型的基础。异步活动的执行模型可以只有一个单一的主控制流，能在单核心系统和多核心系统中运行。 在并发执行的异步模型中，许多任务被穿插在同一时间线上，所有的任务都由一个控制流执行（单一线程）。任务的执行可能被暂停或恢复，中间的这段时间线程将会去执行其他任务。下面的这幅图可以清楚地表达这个概念。 如上图所示，任务（不同的颜色表示不同的任务）可能被其他任务插入，但是都处在同一个线程下。这表明，当某一个任务执行的时候，其他的任务都暂停了。与多线程编程模型很大的一点不同是， 多线程由操作系统决定在时间线上什么时候挂起某个活动或恢复某个活动，而在异步并发模型中，程序员必须假设线程可能在任何时间被挂起和替换。 程序员可以将任务编写成许多可以间隔执行的小步骤， 这样的话如果一个任务需要另一个任务的输出，那么被依赖的任务必须接收它的输入。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:1:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2. 使用Python的 concurrent.futures 模块 Python3.2带来了 concurrent.futures 模块，这个模块具有线程池和进程池、管理并行编程任务、处理非确定性的执行流程、进程/线程同步等功能。 此模块由以下部分组成： concurrent.futures.Executor: 这是一个虚拟基类，提供了异步执行的方法。 submit(function, argument): 调度函数（可调用的对象）的执行，将 argument 作为参数传入。 map(function, argument): 将 argument 作为参数执行函数，以 异步 的方式。 shutdown(Wait=True): 发出让执行者释放所有资源的信号。 concurrent.futures.Future: 其中包括函数的异步执行。Future对象是submit任务（即带有参数的functions）到executor的实例。 Executor是抽象类，可以通过子类访问，即线程或进程的 ExecutorPools 。因为，线程或进程的实例是依赖于资源的任务，所以最好以“池”的形式将他们组织在一起，作为可以重用的launcher或executor。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.1. 使用线程池和进程池 线程池或进程池是用于在程序中优化和简化线程/进程的使用。通过池，你可以提交任务给executor。池由两部分组成，一部分是内部的队列，存放着待执行的任务；另一部分是一系列的进程或线程，用于执行这些任务。池的概念主要目的是为了重用：让线程或进程在生命周期内可以多次使用。它减少了创建创建线程和进程的开销，提高了程序性能。重用不是必须的规则，但它是程序员在应用中使用池的主要原因。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:1","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.2. 准备工作 current.Futures 模块提供了两种 Executor 的子类，各自独立操作一个线程池和一个进程池。这两个子类分别是： concurrent.futures.ThreadPoolExecutor(max_workers) concurrent.futures.ProcessPoolExecutor(max_workers) max_workers 参数表示最多有多少个worker并行执行任务。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:2","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.3. 代码 下面的示例代码展示了线程池和进程池的功能。这里的任务是，给一个list number_list ，包含1到10。对list中的每一个数字，乘以1+2+3…+10000000的和（这个任务只是为了消耗时间）。 下面的代码分别测试了： 顺序执行 通过有5个worker的线程池执行 通过有5个worker的进程池执行 import concurrent.futures import time number_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def evaluate_item(x): # 计算总和，这里只是为了消耗时间 result_item = count(x) # 打印输入和输出结果 return result_item def count(number) : for i in range(0, 10000000): i=i+1 return i * number if __name__ == \"__main__\": # 顺序执行 start_time = time.time() for item in number_list: print(evaluate_item(item)) print(\"Sequential execution in \" + str(time.time() - start_time), \"seconds\") # 线程池执行 start_time_1 = time.time() with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor: futures = [executor.submit(evaluate_item, item) for item in number_list] for future in concurrent.futures.as_completed(futures): print(future.result()) print (\"Thread pool execution in \" + str(time.time() - start_time_1), \"seconds\") # 进程池 start_time_2 = time.time() with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor: futures = [executor.submit(evaluate_item, item) for item in number_list] for future in concurrent.futures.as_completed(futures): print(future.result()) print (\"Process pool execution in \" + str(time.time() - start_time_2), \"seconds\") 运行结果 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:3","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.4 代码解释 我们创建了一个list存放10个数字，然后使用一个循环计算从1加到10000000，打印出和与 number_list 的乘积。: def evaluate_item(x): # 计算总和，这里只是为了消耗时间 result_item = count(x) # 打印输入和输出结果 print (\"item \" + str(x) + \" result \" + str(result_item)) def count(number) : for i in range(0, 10000000): i=i+1 return i * number 在主要程序中，我们先使用顺序执行跑了一次程序：: if __name__ == \"__main__\": # 顺序执行 start_time = time.clock() for item in number_list: evaluate_item(item) print(\"Sequential execution in \" + str(time.clock() - start_time), \"seconds\") 然后，我们使用了 futures.ThreadPoolExecutor 模块的线程池跑了一次：: with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor: for item in number_list: executor.submit(evaluate_item, item) print (\"Thread pool execution in \" + str(time.clock() - start_time_1), \"seconds\") ThreadPoolExecutor 使用线程池中的一个线程执行给定的任务。池中一共有5个线程，每一个线程从池中取得一个任务然后执行它。当任务执行完成，再从池中拿到另一个任务。 当所有的任务执行完成后，打印出执行用的时间：: print (\"Thread pool execution in \" + str(time.clock() - start_time_1), \"seconds\") 最后，我们又用 ProcessPoolExecutor 跑了一次程序：: with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor: for item in number_list: executor.submit(evaluate_item, item) 如同 ThreadPoolExecutor 一样， ProcessPoolExecutor 是一个executor，使用一个线程池来并行执行任务。然而，和 ThreadPoolExecutor 不同的是， ProcessPoolExecutor 使用了多核处理的模块，让我们可以不受GIL的限制，大大缩短执行时间。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:4","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3. 使用Asyncio管理事件循环 Python的Asyncio模块提供了管理事件、协程、任务和线程的方法，以及编写并发代码的原语。此模块的主要组件和概念包括： 事件循环: 在Asyncio模块中，每一个进程都有一个事件循环。 协程: 这是子程序的泛化概念。协程可以在执行期间暂停，这样就可以等待外部的处理（例如IO）完成之后，从之前暂停的地方恢复执行。 Futures: 定义了 Future 对象，和 concurrent.futures 模块一样，表示尚未完成的计算。 Tasks: 这是Asyncio的子类，用于封装和管理并行模式下的协程。 本节中重点讨论事件，事实上，异步编程的上下文中，事件无比重要。因为事件的本质就是异步。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.1. 什么是事件循环 在计算系统中，可以产生事件的实体叫做事件源，能处理事件的实体叫做事件处理者。此外，还有一些第三方实体叫做事件循环。它的作用是管理所有的事件，在整个程序运行过程中不断循环执行，追踪事件发生的顺序将它们放到队列中，当主线程空闲的时候，调用相应的事件处理者处理事件。最后，我们可以通过下面的伪代码来理解事件循环：: while (1) { events = getEvents(); for (e in events) processEvent(e); } 所有的事件都在 while 循环中捕捉，然后经过事件处理者处理。事件处理的部分是系统唯一活跃的部分，当一个事件处理完成，流程继续处理下一个事件。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:1","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.2. 准备工作 Asyncio提供了一下方法来管理事件循环： loop = get_event_loop(): 得到当前上下文的事件循环。 loop.call_later(time_delay, callback, argument): 延后 time_delay 秒再执行 callback 方法。 loop.call_soon(callback, argument): 尽可能快调用 callback, call_soon() 函数结束，主线程回到事件循环之后就会马上调用 callback 。 loop.time(): 以float类型返回当前时间循环的内部时间。 asyncio.set_event_loop(): 为当前上下文设置事件循环。 asyncio.new_event_loop(): 根据此策略创建一个新的时间循环并返回。 loop.run_forever(): 在调用 stop() 之前将一直运行。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:2","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.3. 代码 下面的代码中，我们将展示如何使用Asyncio库提供的时间循环创建异步模式的应用。 import asyncio import datetime import time def function_1(end_time, loop): print (\"function_1 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_2, end_time, loop) else: loop.stop() def function_2(end_time, loop): print (\"function_2 called \") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_3, end_time, loop) else: loop.stop() def function_3(end_time, loop): print (\"function_3 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_1, end_time, loop) else: loop.stop() def function_4(end_time, loop): print (\"function_5 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_4, end_time, loop) else: loop.stop() loop = asyncio.get_event_loop() end_loop = loop.time() + 9.0 loop.call_soon(function_1, end_loop, loop) # loop.call_soon(function_4, end_loop, loop) loop.run_forever() loop.close() 运行结果如下：: python3 event.pyfunction_1 calledfunction_2 calledfunction_3 calledfunction_1 calledfunction_2 calledfunction_3 calledfunction_1 calledfunction_2 calledfunction_3 called ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:3","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.4. 代码解释 在这个例子中，我们定义了三个异步的任务，相继执行，入下图所示的顺序。 首先，我们要得到这个事件循环：: loop = asyncio.get_event_loop() 然后我们通过 call_soon 方法调用了 function_1() 函数。 end_loop = loop.time() + 9.0loop.call_soon(function_1, end_loop, loop) 让我们来看一下 function_1() 的定义：: def function_1(end_time, loop): print (\"function_1 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_2, end_time, loop) else: loop.stop() 这个函数通过以下参数定义了应用的异步行为： end_time: 定义了 function_1() 可以运行的最长时间，并通过 call_later 方法传入到 function_2() 中作为参数 loop: 之前通过 get_event_loop() 方法得到的事件循环 function_1() 的任务非常简单，只是打印出函数名字。当然，里面也可以写非常复杂的操作。 print (\"function_1 called\") 任务执行结束之后，它将会比较 loop.time() +1s和设定的运行时间，如果没有超过，使用 call_later 在1秒之后执行 function_2() 。 if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_2, end_time, loop)else: loop.stop() function_2() 和 function_3() 的作用类似。 如果运行的时间超过了设定，时间循环终止。 loop.run_forever()loop.close() ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:4:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4. 使用Asyncio控制任务 Asyncio是用来处理事件循环中的异步进程和并发任务执行的。它还提供了 asyncio.Task() 类，可以在任务中使用协程。它的作用是，在同一事件循环中,运行某一个任务的同时可以并发地运行多个任务。当协程被包在任务中，它会自动将任务和事件循环连接起来，当事件循环启动的时候，任务自动运行。这样就提供了一个可以自动驱动协程的机制。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4.1. 准备工作 Asyncio模块为我们提供了 asyncio.Task(coroutine) 方法来处理计算任务，它可以调度协程的执行。任务对协程对象在事件循环的执行负责。如果被包裹的协程要从future yield，那么任务会被挂起，等待future的计算结果。 当future计算完成，被包裹的协程将会拿到future返回的结果或异常（exception）继续执行。另外，需要注意的是，事件循环一次只能运行一个任务，除非还有其它事件循环在不同的线程并行运行，此任务才有可能和其他任务并行。当一个任务在等待future执行的期间，事件循环会运行一个新的任务。 \"\"\"Asyncio using Asyncio.Task to execute three math function in parallel\"\"\"import asyncio@asyncio.coroutinedef factorial(number): f = 1 for i in range(2, number + 1): print(\"Asyncio.Task: Compute factorial(%s)\" % (i)) yield from asyncio.sleep(1) f *= i print(\"Asyncio.Task - factorial(%s) = %s\" % (number, f))@asyncio.coroutinedef fibonacci(number): a, b = 0, 1 for i in range(number): print(\"Asyncio.Task: Compute fibonacci (%s)\" % (i)) yield from asyncio.sleep(1) a, b = b, a + b print(\"Asyncio.Task - fibonacci(%s) = %s\" % (number, a))@asyncio.coroutinedef binomialCoeff(n, k): result = 1 for i in range(1, k+1): result = result * (n-i+1) / i print(\"Asyncio.Task: Compute binomialCoeff (%s)\" % (i)) yield from asyncio.sleep(1) print(\"Asyncio.Task - binomialCoeff(%s , %s) = %s\" % (n, k, result))if __name__ == \"__main__\": tasks = [asyncio.Task(factorial(10)), asyncio.Task(fibonacci(10)), asyncio.Task(binomialCoeff(20, 10))] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) loop.close() ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:1","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4.2. 如何做… 在下面的代码中，我们展示了三个可以被 Asyncio.Task() 并发执行的数学函数。 运行的结果如下： python3 task.pyAsyncio.Task: Compute factorial(2)Asyncio.Task: Compute fibonacci (0)Asyncio.Task: Compute binomialCoeff (1)Asyncio.Task: Compute factorial(3)Asyncio.Task: Compute fibonacci (1)Asyncio.Task: Compute binomialCoeff (2)Asyncio.Task: Compute factorial(4)Asyncio.Task: Compute fibonacci (2)Asyncio.Task: Compute binomialCoeff (3)Asyncio.Task: Compute factorial(5)Asyncio.Task: Compute fibonacci (3)Asyncio.Task: Compute binomialCoeff (4)Asyncio.Task: Compute factorial(6)Asyncio.Task: Compute fibonacci (4)Asyncio.Task: Compute binomialCoeff (5)Asyncio.Task: Compute factorial(7)Asyncio.Task: Compute fibonacci (5)Asyncio.Task: Compute binomialCoeff (6)Asyncio.Task: Compute factorial(8)Asyncio.Task: Compute fibonacci (6)Asyncio.Task: Compute binomialCoeff (7)Asyncio.Task: Compute factorial(9)Asyncio.Task: Compute fibonacci (7)Asyncio.Task: Compute binomialCoeff (8)Asyncio.Task: Compute factorial(10)Asyncio.Task: Compute fibonacci (8)Asyncio.Task: Compute binomialCoeff (9)Asyncio.Task - factorial(10) = 3628800Asyncio.Task: Compute fibonacci (9)Asyncio.Task: Compute binomialCoeff (10)Asyncio.Task - fibonacci(10) = 55Asyncio.Task - binomialCoeff(20 , 10) = 184756.0 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:2","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4.3. 代码解释 在这个例子中，我们定义了三个协程， factorial, fibonacci 和 binomialCoeff ，每一个都带有 asyncio.coroutine 装饰器： @asyncio.coroutinedef factorial(number): do Something@asyncio.coroutinedef fibonacci(number): do Something@asyncio.coroutinedef binomialCoeff(n, k): do Something 为了能并行执行这三个任务，我们将其放到一个task的list中： if __name__ == \"__main__\": tasks = [asyncio.Task(factorial(10)), asyncio.Task(fibonacci(10)), asyncio.Task(binomialCoeff(20, 10))] 得到事件循环： loop = asyncio.get_event_loop() 然后运行任务： loop.run_until_complete(asyncio.wait(tasks)) 这里， asyncio.wait(tasks) 表示运行直到所有给定的协程都完成。 最后，关闭事件循环： loop.close() ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:3","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"1. 介绍 multiprocessing 是Python标准库中的模块，实现了共享内存机制，也就是说，可以让运行在不同处理器核心的进程能读取共享内存。 mpi4py 库实现了消息传递的编程范例（设计模式）。简单来说，就是进程之间不靠任何共享信息来进行通讯（也叫做shared nothing），所有的交流都通过传递信息代替。 这方面与使用共享内存通讯，通过加锁或类似机制实现互斥的技术行成对比。在信息传递的代码中，进程通过 send() 和 receive 进行交流。 在Python多进程的官方文档中，明确指出 multiprocessing 模块要求，使用此模块的函数的main模块对子类来说必须是可导入的（ https://docs.python.org/3.3/library/multiprocessing.html ）。 __main__ 在IDLE中并不是可以导入的，即使你在IDLE中将文件当做一个脚本来运行。为了能正确使用此模块，本章我们将在命令行使用下面的命令运行脚本： python multiprocessing example.py ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:1:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2. 多进程基本使用 “产生”（spawn）的意思是，由父进程创建子进程。父进程既可以在产生子进程之后继续异步执行，也可以暂停等待子进程创建完成之后再继续执行。Python的multiprocessing库通过以下几步创建进程： 创建进程对象 调用 start() 方法，开启进程的活动 调用 join() 方法，在进程结束之前一直等待 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2.1. 代码 下面的例子创建了5个进程，每一个进程都分配了 foo(i) 函数， i 表示进程的id： # -*- coding: utf-8 -*- import multiprocessing def foo(i): print ('called function in process: %s' %i) return if __name__ == '__main__': Process_jobs = [] for i in range(5): p = multiprocessing.Process(target=foo, args=(i,)) Process_jobs.append(p) p.start() p.join() 执行本例需要打开命令行，到文件 spawn_a_process.py （脚本名字）所在的目录下，然后输入下面的命令执行： python spawn_a_process.py 我们会得到以下结果： $ python process_2.py called function in process: 0 called function in process: 1 called function in process: 2 called function in process: 3 called function in process: 4 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2.2. 解释 按照本节前面提到的步骤，创建进程对象首先需要引入multiprocessing模块： import multiprocessing 然后，我们在主程序中创建进程对象： p = multiprocessing.Process(target=foo, args=(i,)) 最后，我们调用 start() 方法启动： p.start() 进程对象的时候需要分配一个函数，作为进程的执行任务，本例中，这个函数是 foo() 。我们可以用元组的形式给函数传递一些参数。最后，使用进程对象调用 join() 方法。 如果没有 join() ，主进程退出之后子进程会留在idle中，你必须手动杀死它们。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2.3. 了解更多 这是因为，子进程创建的时候需要导入包含目标函数的脚本。通过在 __main__ 代码块中实例化进程对象，我们可以预防无限递归调用。最佳实践是在不同的脚本文件中定义目标函数，然后导入进来使用。所以上面的代码可以修改为： import multiprocessing import target_function if __name__ == '__main__': Process_jobs = [] for i in range(5): p = multiprocessing.Process(target=target_function.function,args=(i,)) Process_jobs.append(p) p.start() p.join() target_function.py 的内容如下： def function(i): print('called function in process: %s' %i) return 输出和上面一样。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:3","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3. 线程命名 命名进程的方法和前一章中介绍的命名线程差不多 下面的代码在主程序中创建了一个有名字的进程和一个没有名字的进程，目标函数都是 foo() 函数。 # 命名一个进程 import multiprocessing import time def foo(): name = multiprocessing.current_process().name print(\"Starting %s\\n\" % name) time.sleep(3) print(\"Exiting %s\\n\" % name) if __name__ == '__main__': process_with_name = multiprocessing.Process(name='foo_process', target=foo) process_with_name.daemon = True # 注意原代码有这一行，但是译者发现删掉这一行才能得到正确输出 process_with_default_name = multiprocessing.Process(target=foo) process_with_name.start() process_with_default_name.start() 运行上面的代码，打开终端输入: python naming_process.py 输出的结果如下： $ python naming_process.pyStarting foo_processStarting Process-2Exiting foo_processExiting Process-2 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3.2. 讨论 这个过程和命名线程很像。命名进程需要为进程对象提供 name 参数： process_with_name = multiprocessing.Process(name='foo_process', target=foo) 在本例子中，进程的名字就是 foo_function 。如果子进程需要知道父进程的名字，可以使用以下声明： name = multiprocessing.current_process().name 然后就能看见父进程的名字。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"4. 后台守护进程 如果需要处理比较巨大的任务，又不需要人为干预，将其作为后台进程执行是个非常常用的编程模型。此进程又可以和其他进程并发执行。通过Python的multiprocessing模块的后台进程选项，我们可以让进程在后台运行。 import multiprocessingimport timedef foo(): name = multiprocessing.current_process().name print(\"Starting %s\" % name) time.sleep(3) print(\"Exiting %s\" % name)if __name__ == '__main__': background_process = multiprocessing.Process(name='background_process', target=foo) background_process.daemon = True NO_background_process = multiprocessing.Process(name='NO_background_process', target=foo) NO_background_process.daemon = False background_process.start() NO_background_process.start() #注释掉这一句讲没有任何输出 运行结果： $ python background_process.pyStarting NO_background_processExiting NO_background_process 为了在后台运行进程，我们设置 daemon 参数为 True background_process.daemon = True 在非后台运行的进程会看到一个输出，后台运行的没有输出，后台运行进程在主进程结束之后会自动结束。 注意，后台进程不允许创建子进程。否则，当后台进程跟随父进程退出的时候，子进程会变成孤儿进程。另外，它们并不是Unix的守护进程或服务（daemons or services），所以当非后台进程退出，它们会被终结。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5.杀掉一个进程 我们可以使用 terminate() 方法立即杀死一个进程。另外，我们可以使用 is_alive() 方法来判断一个进程是否还存活。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5.1 代码 import multiprocessingimport timedef foo(): print('Starting function') time.sleep(0.1) print('Finished function')if __name__ == '__main__': p = multiprocessing.Process(target=foo) print('Process before execution:', p, p.is_alive()) p.start() print('Process running:', p, p.is_alive()) p.terminate() print('Process terminated:', p, p.is_alive()) p.join() print('Process joined:', p, p.is_alive()) print('Process exit code:', p.exitcode) 运行结果： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5.2 解释 我们创建了一个线程，然后用 is_alive() 方法监控它的声明周期。然后通过调用 terminate() 方法结束进程。 最后，我们通过读进程的 ExitCode 状态码（status code）验证进程已经结束， ExitCode 可能的值如下： == 0: 没有错误正常退出 \u003e 0: 进程有错误，并以此状态码退出 \u003c 0: 进程被 -1 * 的信号杀死并以此作为 ExitCode 退出 在我们的例子中，输出的 ExitCode 是 -15 。负数表示子进程被数字为15的信号杀死。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6. 自定义进程 实现一个自定义的进程子类，需要以下三步： 定义 Process 的子类 覆盖 __init__(self [,args]) 方法来添加额外的参数 覆盖 run(self, [.args]) 方法来实现 Process 启动的时候执行的任务 创建 Porcess 子类之后，你可以创建它的实例并通过 start() 方法启动它，启动之后会运行 run() 方法。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.1 代码 我们将使用子类的形式重写之前的例子： # -*- coding: utf-8 -*-# 自定义子类进程import multiprocessingclass MyProcess(multiprocessing.Process): def run(self): print(\"Called run method in process: %s\" % self.name) returnif __name__ == \"__main__\": jobs = [] for i in range(5): p = MyProcess() jobs.append(p) p.start() p.join() 输入以下命令运行脚本： python subclass_process.py ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.2 解释 每一个继承了 Process 并重写了 run() 方法的子类都代表一个进程。此方法是进程的入口： class MyProcess(multiprocessing.Process): def run(self): print ('called run method in process: %s' % self.name) return 在主程序中，我们创建了一些 MyProcess() 的子类。当 start() 方法被调用的时候进程开始执行： p = MyProcess()p.start() join() 命令可以让主进程等待其他进程结束最后退出 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7. 进程间对象交换 并行应用常常需要在进程之间交换数据。Multiprocessing库有两个Communication Channel可以交换对象：队列(queue)和管道（pipe）。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7.1 使用队列交换对象 我们可以通过队列数据结构来共享对象。 Queue 返回一个进程共享的队列，是线程安全的，也是进程安全的。任何可序列化的对象（Python通过 pickable 模块序列化对象）都可以通过它进行交换。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7.2 队列交换对象代码 我们将展示如何使用队列来实现生产者-消费者问题。 Producer 类生产item放到队列中，然后 Consumer 类从队列中移除它们。 import multiprocessingimport randomimport timeclass Producer(multiprocessing.Process): def __init__(self, queue): multiprocessing.Process.__init__(self) self.queue = queue def run(self): for i in range(10): item = random.randint(0, 256) self.queue.put(item) print(\"Process Producer : item %dappended to queue %s\" % (item, self.name)) time.sleep(1) print(\"The size of queue is %s\" % self.queue.qsize())class Consumer(multiprocessing.Process): def __init__(self, queue): multiprocessing.Process.__init__(self) self.queue = queue def run(self): while True: if self.queue.empty(): print(\"the queue is empty\") break else: time.sleep(2) item = self.queue.get() print('Process Consumer : item %dpopped from by %s\\n' % (item, self.name)) time.sleep(1)if __name__ == '__main__': queue = multiprocessing.Queue() process_producer = Producer(queue) process_consumer = Consumer(queue) process_producer.start() process_consumer.start() process_producer.join() process_consumer.join() 运行结果： Chapter 3\u003epython using_queue.pyProcess Producer : item 69 appended to queue producer-1The size of queue is 1Process Producer : item 168 appended to queue producer-1The size of queue is 2Process Consumer : item 69 popped from by consumer-2Process Producer : item 235 appended to queue producer-1The size of queue is 2Process Producer : item 152 appended to queue producer-1The size of queue is 3Process Producer : item 213 appended to queue producer-1Process Consumer : item 168 popped from by consumer-2The size of queue is 3Process Producer : item 35 appended to queue producer-1The size of queue is 4Process Producer : item 218 appended to queue producer-1The size of queue is 5Process Producer : item 175 appended to queue producer-1Process Consumer : item 235 popped from by consumer-2The size of queue is 5Process Producer : item 140 appended to queue producer-1The size of queue is 6Process Producer : item 241 appended to queue producer-1The size of queue is 7Process Consumer : item 152 popped from by consumer-2Process Consumer : item 213 popped from by consumer-2Process Consumer : item 35 popped from by consumer-2Process Consumer : item 218 popped from by consumer-2Process Consumer : item 175 popped from by consumer-2Process Consumer : item 140 popped from by consumer-2Process Consumer : item 241 popped from by consumer-2the queue is empty ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7.3 解释 我们使用 multiprocessing 类在主程序中创建了 Queue 的实例： if __name__ == '__main__': queue = multiprocessing.Queue() 然后我们创建了两个进程，生产者和消费者， Queue 对象作为一个属性。 process_producer = Producer(queue)process_consumer = Consumer(queue) 生产者类负责使用 put() 方法放入10个item： for i in range(10): item = random.randint(0, 256) self.queue.put(item) 消费者进程负责使用 get() 方法从队列中移除item，并且确认队列是否为空，如果为空，就执行 break 跳出 while 循环： def run(self): while True: if self.queue.empty(): print(\"the queue is empty\") break else: time.sleep(2) item = self.queue.get() print('Process Consumer : item %dpopped from by %s\\n' % (item, self.name)) time.sleep(1) ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:3","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8. 进程池 多进程库提供了 Pool 类来实现简单的多进程任务。 Pool 类有以下方法： apply(): 直到得到结果之前一直阻塞。 apply_async(): 这是 apply() 方法的一个变体，返回的是一个result对象。这是一个异步的操作，在所有的子类执行之前不会锁住主进程。 map(): 这是内置的 map() 函数的并行版本。在得到结果之前一直阻塞，此方法将可迭代的数据的每一个元素作为进程池的一个任务来执行。 map_async(): 这是 map() 方法的一个变体，返回一个result对象。如果指定了回调函数，回调函数应该是callable的，并且只接受一个参数。当result准备好时会自动调用回调函数（除非调用失败）。回调函数应该立即完成，否则，持有result的进程将被阻塞。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.1 代码 下面的例子展示了如果通过进程池来执行一个并行应用。我们创建了有4个进程的进程池，然后使用 map() 方法进行一个简单的计算。 import multiprocessingdef function_square(data): result = data*data return resultif __name__ == '__main__': inputs = list(range(100)) pool = multiprocessing.Pool(processes=4) pool_outputs = pool.map(function_square, inputs) pool.close() pool.join() print ('Pool :', pool_outputs) 计算的结果如下： $ python poll.py('Pool :', [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6889, 7056, 7225, 7396, 7569, 7744, 7921, 8100, 8281, 8464, 8649, 8836, 9025, 9216, 9409, 9604, 9801]) ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.2 解释 multiprocessing.Pool 方法在输入元素上应用 function_square 方法来执行简单的计算。并行的进程数量是4： pool = multiprocessing.Pool(processes=4) pool.map 方法将一些独立的任务提交给进程池： pool_outputs = pool.map(function_square, inputs) input 是一个从 0 到 100 的list： inputs = list(range(100)) 计算的结果存储在 pool_outputs 中。最后的结果打印出来： print ('Pool :', pool_outputs) 需要注意的是， pool.map() 方法的结果和Python内置的 map() 结果是相同的，不同的是 pool.map() 是通过多个并行进程计算的。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"1. 线程介绍 目前，在软件应用中使用最广泛的并发编程范例是多线程。通常，一个应用有一个进程，分成多个独立的线程，并行运行、互相配合，执行不同类型的任务。 主要特点： 线程是独立的处理流程，可以和系统的其他线程并行或并发地执行。 多线程可以共享数据和资源，利用所谓的共享内存空间。 同一进程的多个不同的线程可以共享相同的资源。相比而言，进程之间不会共享资源。 每一个线程基本上包含3个元素：程序计数器，寄存器和栈。与同一进程的其他线程共享的资源基本上包括数据和系统资源。每一个线程也有自己的运行状态，可以和其他线程同步，这点和进程一样。线程的状态大体上可以分为ready,running,blocked。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:1:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2. python线程模块介绍 Python通过标准库的 threading 模块来管理线程。这个模块提供了很多不错的特性，让线程变得无比简单。实际上，线程模块提供了几种同时运行的机制，实现起来非常简单。 线程模块的主要组件如下： 线程对象 Lock对象 RLock对象 信号对象 条件对象 事件对象 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3. 定义一个python线程 使用线程最简单的一个方法是，用一个目标函数实例化一个Thread然后调用 start() 方法启动它。Python的threading模块提供了 Thread() 方法在不同的线程中运行函数或处理过程等。 class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}) 上面的代码中： group: 一般设置为 None ，这是为以后的一些特性预留的 target: 当线程启动的时候要执行的函数 name: 线程的名字，默认会分配一个唯一名字 Thread-N args: 传递给 target 的参数，要使用tuple类型 kwargs: 同上，使用字典类型dict 创建线程的方法非常实用，通过target参数arg和kwarg告诉线程应该做什么。下面这个例子传递一个数字给线程（这个数字正好等于线程号码），目标函数会打印出这个数字。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3.1 代码举例 import threading def function(i): print (\"function called by thread %i\\n\" % i) return threads = [] for i in range(5): # 线程对象 t = threading.Thread(target=function , args=(i, )) threads.append(t) t.start() # 加入主线程队列 t.join() 输出 ✔ python -u thread_simple.py function called by thread 0 function called by thread 1 function called by thread 2 function called by thread 3 function called by thread 4 导入内置threading模块，简单地使用python命令就可以了： import threading 在主程序中，我们使用目标函数 function 初始化了一个线程对象 Thread 。同时还传入了用于打印的一个参数： t = threading.Thread(target=function , args=(i, )) 线程被创建之后并不会马上运行，需要手动调用 start() ， join() 让调用它的线程一直等待直到执行结束（即阻塞调用它的主线程， t 线程执行结束，主线程才会继续执行）： t.start() t.join() ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"4. 确定线程运行状态 threading模块提供了一些比较实用的方法或者属性 import urllib.request import threading import logging import os logging.basicConfig(level=logging.DEBUG, format='%(asctime)s-%(levelname)s-%(message)s') logger = logging.getLogger(__name__) sites = [ '\u003chttps://www.yahoo.com/\u003e', '\u003chttp://www.cnn.com\u003e', '\u003chttp://www.python.org\u003e', '\u003chttp://www.jython.org\u003e', '\u003chttp://www.pypy.org\u003e', '\u003chttp://www.perl.org\u003e', '\u003chttp://www.cisco.com\u003e', '\u003chttp://www.facebook.com\u003e', '\u003chttp://www.twitter.com\u003e', \"\u003chttps://www.youtube.com/\u003e\", '\u003chttp://arstechnica.com/\u003e', '\u003chttp://www.reuters.com/\u003e', '\u003chttp://abcnews.go.com/\u003e', '\u003chttp://www.cnbc.com/\u003e', ] def getHtml(url): page = urllib.request.urlopen(url).read() print(url, len(page)) for url in sites: threading.Thread(target=getHtml, args=(url,)).start() logger.info(f'Process ID: {os.getpid()}') logger.info(f\"Main thread {threading.main_thread()}\") logger.info(f'Thread Count: {threading.active_count()}') for thread in threading.enumerate(): logger.info(thread) 运行结果： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"给线程命名 使用参数来确认或命名线程是笨拙且没有必要的。每一个 Thread 实例创建的时候都有一个带默认值的名字，并且可以修改。在服务端通常一个服务进程都有多个线程服务，负责不同的操作，这时候命名线程是很实用的 import threading import time def first_function(): print(threading.currentThread().getName() + str(' is Starting ')) time.sleep(2) print (threading.currentThread().getName() + str(' is Exiting ')) return def second_function(): print(threading.currentThread().getName() + str(' is Starting ')) time.sleep(2) print (threading.currentThread().getName() + str(' is Exiting ')) return def third_function(): print(threading.currentThread().getName() + str(' is Starting ')) time.sleep(2) print(threading.currentThread().getName() + str(' is Exiting ')) return if __name__ == \"__main__\": t1 = threading.Thread(name='first_function', target=first_function) t2 = threading.Thread(name='second_function', target=second_function) t3 = threading.Thread(name='third_function', target=third_function) t1.start() t2.start() t3.start() 运行结果: ✔ python -u thread_simple.pyfirst_function is Starting second_function is Starting third_function is Starting first_function is Exiting second_function is Exiting third_function is Exiting ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"解析 我们使用目标函数实例化线程。同时，我们传入 name 参数作为线程的名字，如果不传这个参数，将使用默认的参数： t1 = threading.Thread(name='first_function', target=first_function)t2 = threading.Thread(name='second_function', target=second_function)t3 = threading.Thread(target=third_function) （译者注：这里的代码和上面的不一样，可能作者本意是第三个线程不加参数来测试默认的行为，如果改为这里的代码，那么线程3将会输出的是 Thread-1 is Starting 以及 Thread-1 is Exiting ，读者可以自行尝试） 最后调用 start() 和 join() 启动它们。 t1.start()t2.start()t3.start()t1.join()t2.join()t3.join() ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5. 自己动手实现一个线程 使用threading模块实现一个新的线程，需要下面3步： 定义一个 Thread 类的子类 重写 __init__(self [,args]) 方法，可以添加额外的参数 最后，需要重写 run(self, [,args]) 方法来实现线程要做的事情 当你创建了新的 Thread 子类的时候，你可以实例化这个类，调用 start() 方法来启动它。线程启动之后将会执行 run() 方法。 import threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print(\"Starting \" + self.name) print_time(self.name, self.counter, 5) print(\"Exiting \" + self.name)def print_time(threadName, delay, counter): while counter: if exitFlag: # 译者注：原书中使用的thread，但是Python3中已经不能使用thread，以_thread取代，因此应该 # import _thread # _thread.exit() thread.exit() time.sleep(delay) print(\"%s: %s\" % (threadName, time.ctime(time.time()))) counter -= 1# Create new threadsthread1 = myThread(1, \"Thread-1\", 1)thread2 = myThread(2, \"Thread-2\", 2)# Start new Threadsthread1.start()thread2.start()# 以下两行为译者添加，如果要获得和图片相同的结果，# 下面两行是必须的。疑似原作者的疏漏thread1.join()thread2.join()print(\"Exiting Main Thread\") 结果： ✔ python -u thread_run.pyStarting Thread-1Starting Thread-2Thread-1: Thu Jun 24 09:31:43 2021Thread-2: Thu Jun 24 09:31:44 2021Thread-1: Thu Jun 24 09:31:44 2021Thread-1: Thu Jun 24 09:31:45 2021Thread-1: Thu Jun 24 09:31:46 2021Thread-2: Thu Jun 24 09:31:46 2021Thread-1: Thu Jun 24 09:31:47 2021Exiting Thread-1Thread-2: Thu Jun 24 09:31:48 2021Thread-2: Thu Jun 24 09:31:50 2021Thread-2: Thu Jun 24 09:31:52 2021Exiting Thread-2Exiting Main Thread 解释： threading 模块是创建和管理线程的首选形式。每一个线程都通过一个继承 Thread 类，重写 run() 方法来实现逻辑，这个方法是线程的入口。在主程序中，我们创建了多个 myThread 的类型实例，然后执行 start() 方法启动它们。调用 Thread.__init__ 构造器方法是必须的，通过它我们可以给线程定义一些名字或分组之类的属性。调用 start() 之后线程变为活跃状态，并且持续直到 run() 结束，或者中间出现异常。所有的线程都执行完成之后，程序结束。 join() 命令控制主线程的终止。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6. 线程锁🔒 当两个或以上对共享内存的操作发生在并发线程中，并且至少有一个可以改变数据，又没有同步机制的条件下，就会产生竞争条件，可能会导致执行无效代码、bug、或异常行为。 竞争条件最简单的解决方法是使用锁。锁的操作非常简单，当一个线程需要访问部分共享内存时，它必须先获得锁才能访问。此线程对这部分共享资源使用完成之后，该线程必须释放锁，然后其他线程就可以拿到这个锁并访问这部分资源了。 然而，在实际使用的过程中，我们发现这个方法经常会导致一种糟糕的死锁现象。当不同的线程要求得到一个锁时，死锁就会发生，这时程序不可能继续执行，因为它们互相拿着对方需要的锁。使用锁来解决同步问题是一个可行却存在潜在问题的方案。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.1 代码解释 # -*- coding: utf-8 -*-import threadingshared_resource_with_lock = 0shared_resource_with_no_lock = 0COUNT = 100000shared_resource_lock = threading.Lock()# 有锁的情况def increment_with_lock(): global shared_resource_with_lock for i in range(COUNT): shared_resource_lock.acquire() shared_resource_with_lock += 1 shared_resource_lock.release()def decrement_with_lock(): global shared_resource_with_lock for i in range(COUNT): shared_resource_lock.acquire() shared_resource_with_lock -= 1 shared_resource_lock.release()# 没有锁的情况def increment_without_lock(): global shared_resource_with_no_lock for i in range(COUNT): shared_resource_with_no_lock += 1def decrement_without_lock(): global shared_resource_with_no_lock for i in range(COUNT): shared_resource_with_no_lock -= 1if __name__ == \"__main__\": t1 = threading.Thread(target=increment_with_lock) t2 = threading.Thread(target=decrement_with_lock) t3 = threading.Thread(target=increment_without_lock) t4 = threading.Thread(target=decrement_without_lock) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() print (\"the value of shared variable with lock management is %s\" % shared_resource_with_lock) print (\"the value of shared variable with race condition is %s\" % shared_resource_with_no_lock) 运行结果： ✔ python -u thread_lock.pythe value of shared variable with lock management is 0the value of shared variable with race condition is 67058 可以看出，如果有锁来管理线程的话，我们会得到正确的结果。这里要注意，没有锁的情况下并不一定会得到错误的结果，但是重复执行多次，总会出现错误的结果。而有锁的情况结果总会是正确的。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.2 代码解释 在主程序中，我们有以下步骤： t1 = threading.Thread(target=increment_with_lock)t2 = threading.Thread(target=decrement_with_lock) 启动线程： t1.start()t2.start() 然后阻塞主线程直到所有线程完成： t1.join()t2.join() 在 increment_with_lock() 函数和 decrement_with_lock() 函数中，可以看到我们使用了lock语句。当你需要使用资源的时候，调用 acquire() 拿到锁（如果锁暂时不可用，会一直等待直到拿到），最后调用 release(): shared_resource_lock.acquire()shared_resource_with_lock -= 1shared_resource_lock.release() 让我们总结一下： 锁有两种状态： locked（被某一线程拿到）和unlocked（可用状态） 我们有两个方法来操作锁： acquire() 和 release() 需要遵循以下规则： 如果状态是unlocked， 可以调用 acquire() 将状态改为locked 如果状态是locked， acquire() 会被block直到另一线程调用 release() 释放锁 如果状态是unlocked， 调用 release() 将导致 RuntimError 异常 如果状态是locked， 可以调用 release() 将状态改为unlocked ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.3. 线程弊端 尽管理论上行得通，但是锁的策略不仅会导致有害的僵持局面。还会对应用程序的其他方面产生负面影响。这是一种保守的方法，经常会引起不必要的开销，也会限制程序的可扩展性和可读性。更重要的是，有时候需要对多进程共享的内存分配优先级，使用锁可能和这种优先级冲突。最后，从实践的经验来看，使用锁的应用将对debug带来不小的麻烦。所以，最好使用其他可选的方法确保同步读取共享内存，避免竞争条件。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:3","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7. 递归锁RLOCK RLock其实叫做“Reentrant Lock”，就是可以重复进入的锁，也叫做“递归锁”。这种锁对比Lock有是三个特点：1. 谁拿到谁释放。如果线程A拿到锁，线程B无法释放这个锁，只有A可以释放；2. 同一线程可以多次拿到该锁，即可以acquire多次；3. acquire多少次就必须release多少次，只有最后一次release才能改变RLock的状态为unlocked 如果是一把互斥锁（threading.Lock()），那么下面的代码会发生堵塞： import threadinglock = threading.Lock()lock.acquire() for i in range(10): print('获取第二把锁') lock.acquire() print(f'test.......{i}') lock.release() lock.release() 同样的代码，如果换成（threading.RLock()），则不会发生堵塞： import threadinglock = threading.RLock()lock.acquire() for i in range(10): print('获取第二把锁') lock.acquire() print(f'test.......{i}') lock.release() lock.release() RLock其实底层维护了一个互斥锁和一个计数器 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8. 信号量 信号量也是一把锁，用来控制线程并发数的。BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。 计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念) 类名：BoundedSemaphore。这种锁允许一定数量的线程同时更改数据，它不是互斥锁。比如地铁安检，排队人很多，工作人员只允许一定数量的人进入安检区，其它的人继续排队。 同样的，在threading模块中，信号量的操作有两个函数，即 acquire() 和 release() ，解释如下： 每当线程想要读取关联了信号量的共享资源时，必须调用 acquire() ，此操作减少信号量的内部变量, 如果此变量的值非负，那么分配该资源的权限。如果是负值，那么线程被挂起，直到有其他的线程释放资源。 当线程不再需要该共享资源，必须通过 release() 释放。这样，信号量的内部变量增加，在信号量等待队列中排在最前面的线程会拿到共享资源的权限。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.1 代码 import timeimport threadingdef run(n, se): se.acquire() print(\"run the thread: %s\" % n) time.sleep(1) se.release()# 设置允许5个线程同时运行semaphore = threading.BoundedSemaphore(5)for i in range(20): t = threading.Thread(target=run, args=(i, semaphore)) t.start() 运行结果： ​ ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.2 消费者模型的信号量使用 # -*- coding: utf-8 -*-\"\"\"Using a Semaphore to synchronize threads\"\"\"import threadingimport timeimport random# The optional argument gives the initial value for the internal# counter;# it defaults to 1.# If the value given is less than 0, ValueError is raised.semaphore = threading.Semaphore(0)def consumer(): print(\"consumer is waiting.\") # Acquire a semaphore semaphore.acquire() # The consumer have access to the shared resource print(\"Consumer notify : consumed item number %s \" % item)def producer(): global item time.sleep(10) # create a random item item = random.randint(0, 1000) print(\"producer notify : produced item number %s\" % item) # Release a semaphore, incrementing the internal counter by one. # When it is zero on entry and another thread is waiting for it # to become larger than zero again, wake up that thread. semaphore.release()if __name__ == '__main__': for i in range (0,5) : t1 = threading.Thread(target=producer) t2 = threading.Thread(target=consumer) t1.start() t2.start() t1.join() t2.join() print(\"program terminated\") 我们使用生产者-消费者模型展示通过信号量的同步。当生产者生产出item，便释放信号量。然后消费者拿到资源进行消费。 运行结果： ↵ python -u thread_semaphore.pyconsumer is waiting.producer notify : produced item number 328Consumer notify : consumed item number 328 consumer is waiting.producer notify : produced item number 230Consumer notify : consumed item number 230 consumer is waiting.producer notify : produced item number 174Consumer notify : consumed item number 174 consumer is waiting.producer notify : produced item number 573Consumer notify : consumed item number 573 consumer is waiting.producer notify : produced item number 286Consumer notify : consumed item number 286 program terminated ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"9. 条件线程设置 条件指的是应用程序状态的改变。这是另一种同步机制，其中某些线程在等待某一条件发生，其他的线程会在该条件发生的时候进行通知。一旦条件发生，线程会拿到共享资源的唯一权限。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:9:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"9.1 代码 from threading import Thread, Conditionimport timeitems = []condition = Condition()class consumer(Thread): def __init__(self): Thread.__init__(self) def consume(self): global condition global items condition.acquire() if len(items) == 0: condition.wait() print(\"Consumer notify : no item to consume\") items.pop() print(\"Consumer notify : consumed 1 item\") print(\"Consumer notify : items to consume are \" + str(len(items))) condition.notify() condition.release() def run(self): for i in range(0, 20): time.sleep(2) self.consume()class producer(Thread): def __init__(self): Thread.__init__(self) def produce(self): global condition global items condition.acquire() if len(items) == 10: condition.wait() print(\"Producer notify : items producted are \" + str(len(items))) print(\"Producer notify : stop the production!!\") items.append(1) print(\"Producer notify : total items producted \" + str(len(items))) condition.notify() condition.release() def run(self): for i in range(0, 20): time.sleep(1) self.produce()if __name__ == \"__main__\": producer = producer() consumer = consumer() producer.start() consumer.start() producer.join() consumer.join() 运行结果： (译者在这里添加一段。乍一看这段代码好像会死锁，因为 condition.acquire() 之后就在 .wait() 了，好像会一直持有锁。其实 .wait() 会将锁释放，然后等待其他线程 .notify() 之后会重新尝试获得锁。但是要注意 .notify() 并不会自动释放锁，所以代码中有两行，先 .notify() 然后再 .release() 。 译者画了一张图，方便大家理解。这里的过程应该是这样子的（注意 wait() 里面实际有一个释放锁重新获得锁的过程）： 译者的私货完毕，建议看一下官方文档： https://docs.python.org/3/library/threading.html ) 消费者通过拿到锁来修改共享的资源 items[] ： condition.acquire() 如果list的长度为0，那么消费者就进入等待状态： if len(items) == 0: condition.wait() 否则就通过 pop 操作消费一个item： items.pop() 然后，消费者的状态被通知给生产者，同时共享资源释放： condition.notify()condition.release() 生产者拿到共享资源，然后确认缓冲队列是否已满（在我们的这个例子中，最大可以存放10个item），如果已经满了，那么生产者进入等待状态，直到被唤醒： condition.acquire()if len(items) == 10: condition.wait() 如果队列没有满，就生产1个item，通知状态并释放资源： condition.notify()condition.release() ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:9:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"10. 事件进行线程同步 事件是线程之间用于通讯的对象。有的线程等待信号，有的线程发出信号。基本上事件对象都会维护一个内部变量，可以通过 set() 方法设置为 true ，也可以通过 clear() 方法设置为 false 。 wait() 方法将会阻塞线程，直到内部变量为 true 。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:10:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"10.1 代码 import timefrom threading import Thread, Eventimport randomitems = []event = Event()class consumer(Thread): def __init__(self, items, event): Thread.__init__(self) self.items = items self.event = event def run(self): while True: time.sleep(2) self.event.wait() item = self.items.pop() print('Consumer notify : %dpopped from list by %s' % (item, self.name))class producer(Thread): def __init__(self, items, event): Thread.__init__(self) self.items = items self.event = event def run(self): global item for i in range(100): time.sleep(2) item = random.randint(0, 256) self.items.append(item) print('Producer notify : item N° %dappended to list by %s' % (item, self.name)) print('Producer notify : event set by %s' % self.name) self.event.set() print('Produce notify : event cleared by %s'% self.name) self.event.clear()if __name__ == '__main__': t1 = producer(items, event) t2 = consumer(items, event) t1.start() t2.start() t1.join() t2.join() 线程t1在list最后添加值，然后设置event来通知消费者。消费者通过 wait() 阻塞，直到收到信号的时候从list中取出元素消费。 运行结果： 解释： producer 类初始化时定义了item的list和 Event ，与条件对象时候的例子不同，这里的list并不是全局的，而是通过参数传入的： class consumer(Thread): def __init__(self, items, event): Thread.__init__(self) self.items = items self.event = event 在run方法中，每当item创建， producer 类将新item添加到list末尾然后发出事件通知。使用事件有两步，第一步： self.event.set() 第二步： self.event.clear() consumer 类初始化时也定义了item的list和 Event() 。当item进来的时候，它将其取出： def run(self): while True: time.sleep(2) self.event.wait() item = self.items.pop() print('Consumer notify : %d popped from list by %s' % (item, self.name)) 下图可以帮我们认识 producer 和 consumer ： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:10:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"11. 线程中的with语句 Python从2.5版本开始引入了 with 语法。此语法非常实用，在有两个相关的操作需要在一部分代码块前后分别执行的时候，可以使用 with 语法自动完成。同事，使用 with 语法可以在特定的地方分配和释放资源，因此， with 语法也叫做“上下文管理器”。在threading模块中，所有带有 acquire() 方法和 release() 方法的对象都可以使用上下文管理器。 也就是说，下面的对象可以使用 with 语法： Lock RLock Condition Semaphore ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:11:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"11.1 代码 import threadingimport logginglogging.basicConfig(level=logging.DEBUG, format='(%(threadName)-10s) %(message)s',)def threading_with(statement): with statement: logging.debug('%sacquired via with' % statement)def threading_not_with(statement): statement.acquire() try: logging.debug('%sacquired directly' % statement ) finally: statement.release()if __name__ == '__main__': # let's create a test battery lock = threading.Lock() rlock = threading.RLock() condition = threading.Condition() mutex = threading.Semaphore(1) threading_synchronization_list = [lock, rlock, condition, mutex] # in the for cycle we call the threading_with e threading_no_with function for statement in threading_synchronization_list : t1 = threading.Thread(target=threading_with, args=(statement,)) t2 = threading.Thread(target=threading_not_with, args=(statement,)) t1.start() t2.start() t1.join() t2.join() 运行结果: ↵ python -u thread_with.py(Thread-1 ) \u003clocked _thread.lock object at 0x1019a1450\u003e acquired via with(Thread-2 ) \u003clocked _thread.lock object at 0x1019a1450\u003e acquired directly(Thread-3 ) \u003clocked _thread.RLock object owner=123145583611904 count=1 at 0x1019a1420\u003e acquired via with(Thread-4 ) \u003clocked _thread.RLock object owner=123145583611904 count=1 at 0x1019a1420\u003e acquired directly(Thread-5 ) \u003cCondition(\u003clocked _thread.RLock object owner=123145583611904 count=1 at 0x1019a19c0\u003e, 0)\u003e acquired via with(Thread-6 ) \u003cCondition(\u003clocked _thread.RLock object owner=123145600401408 count=1 at 0x1019a19c0\u003e, 0)\u003e acquired directly(Thread-7 ) \u003cthreading.Semaphore object at 0x101818910\u003e acquired via with(Thread-8 ) \u003cthreading.Semaphore object at 0x101818910\u003e acquired directly ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:11:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"10.2 解释 在主程序中，我们定义了一个list， threading_synchronization_list ，包含要测试的线程同步使用的对象： lock = threading.Lock()rlock = threading.RLock()condition = threading.Condition()mutex = threading.Semaphore(1)threading_synchronization_list = [lock, rlock, condition, mutex] 定义之后，我们可以在 for 循环中测试每一个对象： for statement in threading_synchronization_list : t1 = threading.Thread(target=threading_with, args=(statement,)) t2 = threading.Thread(target=threading_not_with, args=(statement,)) 最后，我们有两个目标函数，其中 threading_with 测试了 with 语法： def threading_with(statement): with statement: logging.debug('%s acquired via with' % statement) ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:11:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"12. 使用队列进行线程通信 当线程之间如果要共享资源或数据的时候，可能变的非常复杂。如你所见，Python的threading模块提供了很多同步原语，包括信号量，条件变量，事件和锁。如果可以使用这些原语的话，应该优先考虑使用这些，而不是使用queue（队列）模块。队列操作起来更容易，也使多线程编程更安全，因为队列可以将资源的使用通过单线程进行完全控制，并且允许使用更加整洁和可读性更高的设计模式。 Queue常用的方法有以下四个： put(): 往queue中放一个item get(): 从queue删除一个item，并返回删除的这个item task_done(): 每次item被处理的时候需要调用这个方法 join(): 所有item都被处理之前一直阻塞 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:12:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"12.2 代码 from threading import Thread, Eventfrom queue import Queueimport timeimport randomclass producer(Thread): def __init__(self, queue): Thread.__init__(self) self.queue = queue def run(self) : for i in range(10): item = random.randint(0, 256) self.queue.put(item) print('Producer notify: item N° %dappended to queue by %s' % (item, self.name)) time.sleep(1)class consumer(Thread): def __init__(self, queue): Thread.__init__(self) self.queue = queue def run(self): while True: item = self.queue.get() print('Consumer notify : %dpopped from queue by %s' % (item, self.name)) self.queue.task_done()if __name__ == '__main__': queue = Queue() t1 = producer(queue) t2 = consumer(queue) t3 = consumer(queue) t4 = consumer(queue) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() 运行结果： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:12:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"12.2 解释 首先，我们创建一个生产者类。由于我们使用队列存放数字，所以不需要用来存放数字的list了。 class producer(Thread): def __init__(self, queue): Thread.__init__(self) self.queue = queue producer 类生产整数，然后通过一个 for 循环将整数放到队列中： def run(self) : for i in range(10): item = random.randint(0, 256) self.queue.put(item) print('Producer notify: item N° %d appended to queue by %s' % (item, self.name)) time.sleep(1) 生产者使用 Queue.put(item [,block[, timeout]]) 来往queue中插入数据。Queue是同步的，在插入数据之前内部有一个内置的锁机制。 可能发生两种情况： 如果 block 为 True ， timeout 为 None （这也是默认的选项，本例中使用默认选项），那么可能会阻塞掉，直到出现可用的位置。如果 timeout 是正整数，那么阻塞直到这个时间，就会抛出一个异常。 如果 block 为 False ，如果队列有闲置那么会立即插入，否则就立即抛出异常（ timeout 将会被忽略）。本例中， put() 检查队列是否已满，然后调用 wait() 开始等待。 消费者从队列中取出整数然后用 task_done() 方法将其标为任务已处理。 消费者使用 Queue.get([block[, timeout]]) 从队列中取回数据，queue内部也会经过锁的处理。如果队列为空，消费者阻塞。 最后，在主程序中，我们创建线程t作为生产者，t1, t2, t3作为消费者： if __name__ == '__main__': queue = Queue() t1 = producer(queue) t2 = consumer(queue) t3 = consumer(queue) t4 = consumer(queue) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() 生产者和消费者之间的操作可以用下图来描述： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:12:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13. 评估多线程应用的性能 在本节中，我们将验证GIL的影响，评估多线程应用的性能。前文已经介绍过，GIL是CPython解释器引入的锁，GIL在解释器层面阻止了真正的并行运行。解释器在执行任何线程之前，必须等待当前正在运行的线程释放GIL。事实上，解释器会强迫想要运行的线程必须拿到GIL才能访问解释器的任何资源，例如栈或Python对象等。这也正是GIL的目的——阻止不同的线程并发访问Python对象。这样GIL可以保护解释器的内存，让垃圾回收工作正常。但事实上，这却造成了程序员无法通过并行执行多线程来提高程序的性能。如果我们去掉CPython的GIL，就可以让多线程真正并行执行。GIL并没有影响多处理器并行的线程，只是限制了一个解释器只能有一个线程在运行。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:13:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13.1 代码 下面的代码是用来评估多线程应用性能的简单工具。下面的每一个测试都循环调用函数100次，重复执行多次，取速度最快的一次。在 for 循环中，我们调用 non_threaded 和 threaded 函数。同时，我们会不断增加调用次数和线程数来重复执行这个测试。我们会尝试使用1，2，3，4和8线程数来调用线程。在非线程的测试中，我们顺序调用函数与对应线程数一样多的次数。为了保持简单，度量的指标使用Python的内建模块timer。 代码如下： from threading import Threadclass threads_object(Thread): def run(self): function_to_run()class nothreads_object(object): def run(self): function_to_run()def non_threaded(num_iter): funcs = [] for i in range(int(num_iter)): funcs.append(nothreads_object()) for i in funcs: i.run()def threaded(num_threads): funcs = [] for i in range(int(num_threads)): funcs.append(threads_object()) for i in funcs: i.start() for i in funcs: i.join()def function_to_run(): passdef show_results(func_name, results): print(\"%-23s%4.6fseconds\" % (func_name, results))if __name__ == \"__main__\": import sys from timeit import Timer repeat = 100 number = 1 num_threads = [1, 2, 4, 8] print('Starting tests') for i in num_threads: t = Timer(\"non_threaded(%s)\" % i, \"from __main__ import non_threaded\") best_result = min(t.repeat(repeat=repeat, number=number)) show_results(\"non_threaded (%siters)\" % i, best_result) t = Timer(\"threaded(%s)\" % i, \"from __main__ import threaded\") best_result = min(t.repeat(repeat=repeat, number=number)) show_results(\"threaded (%sthreads)\" % i, best_result) print('Iterations complete') ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:13:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13.2. 解释 我们一共进行了四次测试(译者注：原文是three，我怀疑原作者不识数，原文的3个线程数也没有写在代码里），每一次都会使用不同的function进行测试，只要改变 function_to_run() 就可以了。 测试用的机器是 Core 2 Duo CPU – 2.33Ghz。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第一次测试 在第一次测试中，我们使用了一个简单的空函数： def function_to_run(): pass 下图展示了我们测试的每个机制的运行速度： 通过结果可以发现，使用线程的开销要比不使用线程的开销大的多。特别的，我们发现随着线程的数量增加，带来的开销是成比例的。4个线程的运行时间是0.000162秒，8个线程的运行时间是0.000316秒。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第二次测试 多线程比较常用的一个用途是处理数字，下面的测试计算斐波那契数列，注意这个例子中没有共享的资源，只是测试生成数字数列： def function_to_run(): a, b = 0, 1 for i in range(10000): a, b = b, a + b 输出如下： 在输出中可以看到，提高线程的数量并没有带来收益。因为GIL和线程管理代码的开销，多线程运行永远不可能比函数顺序执行更快。再次提醒一下：GIL只允许解释器一次执行一个线程。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第三次测试 下面的测试是读1kb的数据1000次，测试用的函数如下： def function_to_run(): fh=open(\"C:\\\\CookBookFileExamples\\\\test.dat\",\"rb\") size = 1024 for i in range(1000): fh.read(size) 测试的结果如下： 我们终于看到多线程比非多线程跑的好的情况了，而且多线程只用了一半的时间。这给我们的启示是，多线程并不是一个标准。一般，我们将会将多线程放入一个队列中，将它们放到一边，执行其他任务。使用多线程执行同一个相同的任务有时候很有用，但用到的时候很少，除非需要大量处理数据输入。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:3","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第四次测试 在最后的测试中，我们使用 urllib.request 测试，这是一个Python模块，可以发送URL请求。此模块基于 socket ，使用C语言编写并且是线程安全的。 下面的代码尝试读取 https://www.packpub.com 的主页并且读取前1k的数据： def function_to_run(): import urllib.request for i in range(10): with urllib.request.urlopen(\"https://www.packtpub.com/\")as f: f.read(1024) 运行结果如下： 可以看到，在 I/O 期间，GIL释放了。多线程执行比单线程快的多。鉴于大多数应用需要很多I/O操作，GIL并没有限制程序员在这方面使用多线程对程序进行性能优化。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:4","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13.3. 了解更多 你应该记住，增加线程并不会提高应用启动的时间，但是可以支持并发。例如，一次性创建一个线程池，并重用worker会很有用。这可以让我们切分一个大的数据集，用同样的函数处理不同的部分（生产者消费者模型）。上面这些测试并不是并发应用的模型，只是尽量简单的测试。那么GIL会成为试图发挥多线程应用潜能的纯Python开发的瓶颈吗？是的。线程是编程语言的架构，CPython解释器是线程和操作系统的桥梁。这就是为什么Jython，IronPython没有GIL的原因（译者注：Pypy也没有），因为它不是必要的。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:15:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"1. 简介 解决一个大问题的一般方法是，将其拆分成若干小的、独立的问题，然后分别解它们。并行的程序也是使用这种方法，用多个处理器同时工作，来完成同一个任务。每一个处理器都做自己的那部分工作（独立的部分）。而且计算过程中处理器之间可能需要交换数据。如果，软件应用要求越来越高的计算能力。提高计算能力有两种思路：提高处理器的时钟速度或增加芯片上的核心数。提高时钟速度就必然会增加散热，然后每瓦特的性能就会降低，甚至可能要求特殊的冷却设备。提高芯片的核心数是更可行的一种方案，因为能源的消耗和散热，第一种方法必然有上限，而且计算能力提高没有特别明显。 为了解决这个问题，计算机硬件供应商的选择是多核心的架构，就是在同一个芯片上放两个或者多个处理器（核心）。GPU制造商也逐渐引进了这种基于多处理器核心的硬件架构。事实上，今天的计算机几乎都是各种多核、异构的计算单元组成的，每一个单元都有多个处理核心。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:1:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2. 并行计算的内存架构 根据指令的同时执行和数据的同时执行，计算机系统可以分成以下四类： 单处理器，单数据 (SISD) 单处理器，多数据 (SIMD) 多处理器，单数据 (MISD) 多处理器，多数据 (MIMD) 这种分类方法叫做“费林分类”: ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.1. SISD 单处理器单数据就是“单CPU的机器”，它在单一的数据流上执行指令。在SISD中，指令被顺序地执行。 对于每一个“CPU时钟”，CPU按照下面的顺序执行： Fetch: CPU 从一片内存区域中（寄存器）获得数据和指令 Decode: CPU对指令进行解码 Execute: 该执行在数据上执行，将结果保存在另一个寄存器中 当Execute阶段完成之后，CPU回到步骤1准备执行下一个时钟循环。 运行在这些计算机上的算法是顺序执行的（连续的），不存在任何并行。只有一个CPU的硬件系统就是SISD的例子。 这种架构（冯·诺依曼体系）的主要元素有以下： 中心内存单元：存储指令和数据 CPU：用于从内存单元获得指令/数据，对指令解码并顺序执行它们 I/O系统：程序的输入和输出流 传统的单处理器计算机都是经典的SISD系统。下图表述了CPU在Fetch、Decode、Execute的步骤中分别用到了哪些单元： ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.2. MISD 这种模型中，有n个处理器，每一个都有自己的控制单元，共享同一个内存单元。在每一个CPU时钟中，从内存获得的数据会被所有的处理器同时处理，每一个处理器按照自己的控制单元发送的指令处理。在这种情况下，并行实际上是指令层面的并行，多个指令在相同的数据上操作。能够合理利用这种架构的问题模型比较特殊，例如数据加密等。因此，MISD在现实中并没有很多用武之地，更多的是作为一个抽象模型的存在。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:2","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.3. SIMD SIMD计算机包括多个独立的处理器，每一个都有自己的局部内存，可以用来存储数据。所有的处理器都在单一指令流下工作；具体说，就是有n个数据流，每个处理器处理一个。所有的处理器同时处理每一步，在不同的数据上执行相同的指令。这是一个数据并行的例子。SIMD架构比MISD架构要实用的多。很多问题都可以用SIMD计算机的架构来解决。这种架构另一个有趣的特性是，这种架构的算法非常好设计，分析和实现。限制是，只有可以被分解成很多个小问题（小问题之间要独立，可以不分先后顺序被相同的指令执行）的问题才可以用这种架构解决。很多超级计算机就是使用这架构设计出来的。例如Connection Machine（1985年的 Thinking Machine)和MPP（NASA-1983）.我们在第六章 GPU Python编程中会接触到高级的现代图形处理器（GPU），这种处理器就是内置了很多个SIMD处理单元，使这种架构在今天应用非常广泛。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:3","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.4. MIMD 在费林分类中，这种计算机是最广泛使用、也是最强大的一个种类。这种架构有n个处理器，n个指令流，n个数据流。每一个处理器都有自己的控制单元和局部内存，让MIMD架构比SIMD架构的计算能力更强。每一个处理器都在独立的控制单元分配的指令流下工作；因此，处理器可以在不同的数据上运行不同的程序，这样可以解决完全不同的子问题甚至是单一的大问题。在MIMD中，架构是通过线程或进程层面的并行来实现的，这也意味着处理器一般是异步工作的。这种类型的计算机通常用来解决那些没有统一结构、无法用SIMD来解决的问题。如今，很多计算机都应用了这中间架构，例如超级计算机，计算机网络等。然而，有一个问题不得不考虑：异步的算法非常难设计、分析和实现。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:4","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"3. 内存管理 内存管理是并行架构需要考虑的另一方面，确切来说是获得数据的方式。无论处理单元多快，如果内存提供指令和数据的速度跟不上，系统性能也不会得到提升。制约内存达到处理器速度级别的响应时间的主要因素是内存存取周期。所谓存取周期就是连续启动两次读或写操作所需间隔的最小时间。处理器的周期通常比内存周期短得多。当处理器传送数据到内存或从内存中获取数据时，内存依旧在一个周期中，其他任何设备（I/O控制器，处理器）都不能使用内存，因为内存必须先对上一个请求作出响应。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:3:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"3.1. 共享内存 下图展示了共享内存多处理器系统的架构，这里只展示了各部件之间简单的物理连接。总线结构允许任意数量的设备共享一个通道。总线协议最初设计是让单处理器，一个或多个磁盘和磁带控制器通过共享内存进行通讯。可以注意到处理器拥有各自的Cache，Cache中保存着局部内存中有可能被处理器使用的指令或数据。可以想象一下，当一个处理器修改了内存中的数据，同时另外一个处理器正在使用这个数据时，就会出现问题。已修改的值会从处理器的Cache传递到共享内存中，接着，新值会传递到其他处理器的Cache中，其它处理器就不可以使用旧值进行计算。这就是人们所熟知的Cache一致性问题，是内存一致性问题的一种特殊情况，要解决这个问题需要硬件能像多进程编程一样实现处理并发问题 和同步控制 。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:3:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"3.2. 分布式内存 在使用分布式内存的系统中，各个处理器都有其各自的内存，而且每个处理器只能处理属于自己的内存。某些学者把这类系统称为“多计算机系统”，这个名字很真实地反映了组成这类系统的元素能够独立作为一个具有内存和处理器的微型系统，如下图所示： 这种内存管理方式有几个好处。第一，总线和开关级别的的通讯不会发生冲突。每个处理器都可以无视其他处理器的干扰而充分利用局部内存的带宽；第二，没有通用总线意味着没有处理器数量的限制，系统的规模只局限于连接处理器的网络带宽；第三，没有Cache一致性问题的困扰。每个处理器只需要处理属于自己的数据而无须关心上传数据副本的问题。但最大的缺点是，很难实现处理器之间的通讯。如果一个处理器需要其他处理器的数据，这两个处理器必须要通过消息传递协议来交换消息。这样进行通讯会导致速度降低，原因有两个，首先，从一个处理器创建和发送消息到另外一个处理器需要时间；其次，任何处理器都需要停止工作，处理来自其他处理器的消息。面向分布式内存机器的程序必须按照尽量相互独立的任务来组织，任务之间通过消息进行通讯。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:3:2","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4. 并行编程模型 并行编程模型是作为对硬件和内存架构的抽象而存在的。事实上，这些模式不是特定的，而且和机器的类型或内存的架构无关。他们在理论上能在任何类型的机器上实现。相对于前面的架构细分，这些编程模型会在更高的层面上建立，用于表示软件执行并行计算时必须实现的方式。为了访问内存和分解任务，每一个模型都以它独自的方式和其他处理器共享信息。 需要明白的是没有最好的编程模型，模型的效果如何很大程度上取决于实际的问题。使用范围最广的并行编程模型有： 共享内存模型 多线程模型 分布式内存/消息传递模型 数据并行模型 在这节中，会描述这些编程模型的概览。在下一章会更加准确的描述这些编程模型，并会介绍Python中实现这些模型的相应模块。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.1. 共享内存模型 在这个编程模型中所有任务都共享一个内存空间，对共享资源的读写是 异步的。系统提供一些机制，如锁和信号量，来让程序员控制共享内存的访问权限。使用这个编程模型的优点是，程序员不需要清楚任务之间通讯的细节。但性能方面的一个重要缺点是,了解和管理数据区域变得更加困难;将数据保存在处理器本地才可以节省内存访问，缓存刷新以及多处理器使用相同数据时发生的总线流量。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.2. 多线程模型 在这个模型中，单个处理器可以有多个执行流程，例如，创建了一个顺序执行任务之后，会创建一系列可以并行执行的任务。通常情况下，这类模型会应用在共享内存架构中。由于多个线程会对共享内存进行操作，所以进行线程间的同步控制是很重要的，作为程序员必须防止多个线程同时修改相同的内存单元。现代的CPU可以在软件和硬件上实现多线程。POSIX 线程就是典型的在软件层面上实现多线程的例子。Intel 的超线程 (Hyper-threading) 技术则在硬件层面上实现多线程，超线程技术是通过当一个线程在停止或等待I/O状态时切换到另外一个线程实现的。使用这个模型即使是非线性的数据对齐也能实现并行性。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:2","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.3. 消息传递模型 消息传递模型通常在分布式内存系统（每一个处理器都有独立的内存空间）中应用。更多的任务可以驻留在一台或多台物理机器上。程序员需要确定并行和通过消息产生的数据交换。实现这个数据模型需要在代码中调用特定的库。于是便出现了大量消息传递模型的实现，最早的实现可以追溯到20世纪80年代，但直到90年代中期才有标准化的模型——实现了名为MPI (the Message Passing Interface, 消息传递接口)的事实标准。MPI 模型是专门为分布式内存设计的，但作为一个并行编程模型，也可以在共享内存机器上跨平台使用。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:3","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.4. 数据并行模型 在这个模型中，有多个任务需要操作同一个数据结构，但每一个任务操作的是数据的不同部分。在共享内存架构中，所有任务都通过共享内存来访问数据；在分布式内存架构中则会将数据分割并且保存到每个任务的局部内存中。为了实现这个模型，程序员必须指定数据的分配方式和对齐方式。现代的GPU在数据已对齐的情况下运行的效率非常高。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:4","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"5. python的并行计算 作为一种解释型的语言，Python的速度并不算慢。如果对速度有很高的要求的话，可以选择用更快的语言实现，比如C或C++，然后用Python调用。Python的一种常见应用场景是实现高级的逻辑。Python的解释器就是用C语言写的，即CPython。解释器将Python转换成一种中间语言，叫做Python字节码，类似于汇编语言，但是包含一些更高级的指令。当一个运行一个Python程序的时候，评估循环不断将Python字节码转换成机器码。解释型语言的好处是方便编程和调试，但是程序的运行速度慢。其中的一种解决办法是，用C语言实现一些第三方的库，然后在Python中使用。另一种方法是使用即时编译器来替换Cpython，例如PyPy，PyPy对代码生成和Python的运行速度做了优化。但是在本书中，我们将研究第三种方法。Python提供了很多可以利用并行的模块，在后面的章节中，我们将着重讨论这些并行编程的模块。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:5:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"6. 线程与进程 来源： 进程与线程的一个简单解释，看过最通俗易懂的解释 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫“互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做“信号量”（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:6:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"7. python中的线程和进程 基于线程的并行是编写并行程序的标准方法。然而，Python解释器并不完全是线程安全的。为了支持多线程的Python程序，CPython使用了一个叫做全局解释器锁（Global Interpreter Lock， GIL）的技术。这意味着同一时间只有一个线程可以执行Python代码；执行某一个线程一小段时间之后，Python会自动切换到下一个线程。GIL并没有完全解决线程安全的问题，如果多个线程试图使用共享数据，还是可能导致未确定的行为。 # To use threads you need import Thread using the following code: from threading import Thread # Also we use the sleep function to make the thread \"sleep\" from time import sleep # To create a thread in Python you'll want to make your class work as a thread. # For this, you should subclass your class from the Thread class class CookBook(Thread): def __init__(self): Thread.__init__(self) self.message = \"Hello Parallel Python CookBook!!\\n\" # this method prints only the message def print_message(self): print(self.message) # The run method prints ten times the message def run(self): print(\"Thread Starting\\n\") x = 0 while (x \u003c 10): self.print_message() sleep(2) x += 1 print(\"Thread Ended\\n\") # start the main process print(\"Process Started\") # create an instance of the HelloWorld class hello_Python = CookBook() # print the message...starting the thread hello_Python.start() # end the main process print(\"Process Ended\") 输出 可以看到主进程先结束，子线程还在继续运行知道完毕才结束。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:6:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["设计模式"],"content":"Createitv","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"简介 工厂模式三姐妹：简单工厂模式（小妹妹）、工厂方法模式（妹妹）、抽象工厂模式（姐姐）。这三种模式可以理解为同一种编程思想的三个版本，从简单到高级不断升级。 简单工厂：只有一个工厂类 SimpleFactory，类中有一个静态的创建方法createProduct，该方法根据参数传递过来的类型值（type）或名称（name）来创建具体的产品（子类）对象。 **工厂方法模式：**工厂方法模式是简单工厂模式的一个升级版本，为解决简单工厂模式不符合“开放-封闭”原则的问题，对 SimpleFactory 进行了一个拆分，抽象出一个父类 Factory，并增加多个子类分别负责创建不同的具体产品 **抽象工厂模式：**抽象工厂模式是工厂方法模式的升级版本，工厂方法模式不能解决具有二级分类的产品的创建问题，抽象工厂模式就是用来解决这一问题的。提供一个创建一系列相关或相互依赖的对象的接口，而无须指定它们的具体类。 ","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用步骤 创建抽象产品类 \u0026 定义具体产品的公共接口； 创建具体产品类（继承抽象产品类） \u0026 定义生产的具体产品； 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例； 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例 #!/Users/tnt/Documents/虚拟环境/Django/bin/python3 # -*- encoding: utf-8 -*- # Time : 2021/06/05 17:34:24 # Theme : 简单工厂设计模式,工厂是创建其他产品类型的类 # ---------例子一:简单工厂模式--------------- class Mercedes(): def __repr__(self): return \"Mercedes-Benz\" class Bmw(): def __repr__(self): return \"BMW\" class Audi(): def __repr__(self): return \"Audi A8\" class SimpleCarFactory(): \"\"\"简单工厂 \"\"\" @staticmethod def product_car(name): if name == \"mb\": return Mercedes() elif name == \"bmw\": return Bmw() elif name == \"audi\": return Audi() def test(): c1 = SimpleCarFactory.product_car(\"mb\") c2 = SimpleCarFactory.product_car(\"bmw\") c3 = SimpleCarFactory.product_car(\"audi\") print(c1, c2, c3) # -----------例子2 工厂方法模式-------------------- from abc import ABCMeta, abstractmethod class Operation(metaclass=ABCMeta): \"\"\"抽象产品角色\"\"\" def __init__(self, first_num, second_num): self.first_num = first_num self.second_num = second_num @abstractmethod def getResult(self): pass class Add(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): return self.first_num + self.second_num class Sub(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): return self.first_num - self.second_num class Mul(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): return self.first_num * self.second_num class Div(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): try: return 1.0 * self.first_num / self.second_num except ZeroDivisionError: raise class OperationFactory(object): \"\"\"产品工厂角色\"\"\" def __init__(self, operation): self.op = operation def chooseOpertator(self): if self.op == \"+\": return Add elif self.op == \"-\": return Sub elif self.op == \"*\": return Mul elif self.op == \"/\": return Div def test(): operator = OperationFactory(\"*\").chooseOpertator() # operator.first_num = 4 # operator.second_num = 5 # print(operator == Add()) print(operator(3, 4).getResult()) test() # ---------------例子3 工厂方法模式------------------ class Coffee(metaclass=ABCMeta): \"\"\"咖啡类,抽象产品\"\"\" def __init__(self, name): self.__name = name def getName(self): return self.__name @abstractmethod def getTaste(self): pass class LatteCaffe(Coffee): \"\"\"拉铁咖啡, 具体产品\"\"\" def __init__(self, name): super().__init__(name) def getTaste(self): return \"轻柔而香纯\" class MochaCoffee(Coffee): \"\"\"摩卡咖啡, 具体产品\"\"\" def __init__(self, name): super().__init__(name) def getTaste(self): return \"丝滑与醇厚\" class Coffeemaker: \"\"\"咖啡机\"\"\" @staticmethod def makeCoffee(coffeeBean): \"通过staticmethod装饰器修饰来定义一个静态方法\" if(coffeeBean == \"拿铁咖啡豆\"): coffee = LatteCaffe(\"拿铁咖啡\") elif(coffeeBean == \"摩卡咖啡豆\"): coffee = MochaCoffee(\"摩卡咖啡\") else: raise ValueError(\"不支持的参数：%s\" % coffeeBean) return coffee def testCoffeeMaker(): latte = Coffeemaker.makeCoffee(\"拿铁咖啡豆\") print(\"%s已为您准备好了，口感：%s。请慢慢享用！\" % (latte.getName(), latte.getTaste())) mocha = Coffeemaker.makeCoffee(\"摩卡咖啡豆\") print(\"%s已为您准备好了，口感：%s。请慢慢享用！\" % (mocha.getName(), mocha.getTaste())) testCoffeeMaker() 抽象工厂方法举例一 from __future__ import annotations from abc import ABC, abstractmethod class AbstractFactory(ABC): \"\"\" The Abstract Factory interface declares a set of methods that return different abstract products. These products are called a family and are related by a high-level theme or concept. Products of one family are usually able to collaborate among themselves. A family of products may have several variants, but the products of one variant are incompatible with products of another. \"\"\" @abstractmethod def create_product_a(self) -\u003e AbstractProductA: pass @abstractmethod def create_product_b(self) -\u003e AbstractProductB: pass class ConcreteFactory1(AbstractFactory): \"\"\" Concrete Factories produce a family of products that belong to a single variant. The factory guarantees that resulting products are compatible. Note that signatures of the Concrete Factory's methods return an abstract product, while inside the method a concrete product is instantiated. \"\"\" def create_product_a(self) -\u003e AbstractProductA: return ConcreteProductA1() def create_product","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象方法举例二 #!/usr/bin/env python # -*- coding: utf-8 -*- # http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/ \"\"\"Implementation of the abstract factory pattern\"\"\" import abc import random class Solider(object): def __init__(self, gun, buttle): self.gun = gun self.buttle = buttle def fire(self): self.gun.pong() self.buttle.pa() class Gunfactory(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def get_gun(self): pass @abc.abstractmethod def get_bullet(self): pass class Gun(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def pong(self): pass class Bullet(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def pa(self): pass class Rifle(Gun): def pong(self): print \"Rifle fire,pong!\" class Handgun(Gun): def pong(self): print \"Handgun fire,pong,pong,pong\" class RifleBullet(Bullet): def pa(self): print \"Rifle buttle,pa!\" class HandgunBullet(Bullet): def pa(self): print \"Handgun buttle,pa,pa,pa\" class RifleFactory(Gunfactory): def get_gun(self): return Rifle() def get_bullet(self): return RifleBullet() class HandgunFactory(object): def get_gun(self): return Handgun() def get_bullet(self): return HandgunBullet() if __name__ == \"__main__\": rifle_factory = RifleFactory() handgun_factory = HandgunFactory() factories = [rifle_factory, handgun_factory] for i in range(4): factory = random.choice(factories) gun = factory.get_gun() bullet = factory.get_bullet() solider = Solider(gun, bullet) solider.fire() print(\"=\" * 20) ### OUTPUT ### # Rifle fire,pong! # Rifle buttle,pa! # ==================== # Handgun fire,pong,pong,pong # Handgun buttle,pa,pa,pa # ==================== # Handgun fire,pong,pong,pong # Handgun buttle,pa,pa,pa # ==================== # Rifle fire,pong! # Rifle buttle,pa! # ==================== ","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:1","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["python"],"content":"Createitv","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3种编程范式 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"命令式编程 Procedural programming is the most basic form of coding. Code is structured hierarchically into blocks (such as if statements, loops, and functions). It is arguably the simplest form of coding. However, it can be difficult to write and maintain large and complex software due to its lack of enforced structure. def add_values(any_list): sum = 0 for x in any_list: sum += x return sum my_list = [1,2,3,4] print(add_values(my_list)) ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:1","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"面向对象编程 Object-oriented programming (OOP) structures code into objects. An object typically represents a real item in the program, such as a file or a window on the screen, and it groups all the data and code associated with that item within a single software structure. Software is structured according to the relationships and interactions between different objects. Since objects are encapsulated, with well-defined behavior, and capable of being tested independently, it is much easier to write complex systems using OOP. class ListOperations(object): def __init__(self, any_list): self.any_list = any_list def add_values(self): self.sum = sum(self.any_list) my_list = [1,2,3,4] sum_values = ListOperations(my_list) sum_values.add_values() print(sum_values.sum) ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:2","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"函数式编程 Functional programming (FP) uses functions as the main building blocks. Unlike procedural programming, the functional paradigm treats functions as objects that can be passed as parameters, allowing new functions to be built dynamically as the program executes. Functional programming tends to be more declarative than imperative – your code defines what you want to happen, rather than stating exactly how the code should do it. Some FP languages don’t even contain constructs, such as loops or if statements. However, Python is more general-purpose and allows you to mix programming styles very easily. import functools my_list = [1, 2, 3, 4] # We will look at the functools library later on sum = functools.reduce(lambda x, y: x + y, my_list) print(sum) ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:3","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"函数式编程特点 纯函数 没有副作用 函数是第一等公民 偏爱不可变对象 迭代器胜过不可迭代序列 惰性计算 避免循环和判断语句 递归代替循环 高阶函数 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"函数式编程的优缺点 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:3:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"优点 代码更少 易读 Bug更少，更好debug Code is potentially mathematically provable 易于并行计算多线程 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:3:2","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"缺点 不可能完全纯函数 学习曲线高 效率较低，递归消耗大 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:4:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["算法"],"content":"Createitv","date":"2021-05-26","objectID":"/posts/adt_date_type/","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"Abstract Data Types Abstract Data type (ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations. The definition of ADT only mentions what operations are to be performed but not how these operations will be implemented. It does not specify how data will be organized in memory and what algorithms will be used for implementing the operations. It is called “abstract” because it gives an implementation-independent view. The process of providing only the essentials and hiding the details is known as abstraction. The user of data type does not need to know how that data type is implemented, for example, we have been using Primitive values like int, float, char data types only with the knowledge that these data type can operate and be performed on without any idea of how they are implemented. So a user only needs to know what a data type can do, but not how it will be implemented. Think of ADT as a black box which hides the inner structure and design of the data type. Now we’ll define three ADTs namely List ADT, Stack ADT, Queue ADT. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:0","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"List ADT The data is generally stored in key sequence in a list which has a head structure consisting of count,pointers and address of compare function needed to compare the data in the list. The data node contains the pointer to a data structure and a self-referential pointer which points to the next node in the list. //List ADT Type Definitions typedef struct node { void *DataPtr; struct node *link; } Node; typedef struct { int count; Node *pos; Node *head; Node *rear; int (*compare) (void *argument1, void *argument2) } LIST; The List ADT Functions is given below: A list contains elements of the same type arranged in sequential order and following operations can be performed on the list. get() – Return an element from the list at any given position. insert() – Insert an element at any position of the list. remove() – Remove the first occurrence of any element from a non-empty list. removeAt() – Remove the element at a specified location from a non-empty list. replace() – Replace an element at any position by another element. size() – Return the number of elements in the list. isEmpty() – Return true if the list is empty, otherwise return false. isFull() – Return true if the list is full, otherwise return false. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:1","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"Stack ADT In Stack ADT Implementation instead of data being stored in each node, the pointer to data is stored. The program allocates memory for the date and address is passed to the stack ADT. The head node and the data nodes are encapsulated in the ADT. The calling function can only see the pointer to the stack. The stack head structure also contains a pointer to top and count of number of entries currently in stack. //Stack ADT Type Definitions typedef struct node { void *DataPtr; struct node *link; } StackNode; typedef struct { int count; StackNode *top; } STACK; A Stack contains elements of the same type arranged in sequential order. All operations take place at a single end that is top of the stack and following operations can be performed: push() – Insert an element at one end of the stack called top. pop() – Remove and return the element at the top of the stack, if it is not empty. peek() – Return the element at the top of the stack without removing it, if the stack is not empty. size() – Return the number of elements in the stack. isEmpty() – Return true if the stack is empty, otherwise return false. isFull() – Return true if the stack is full, otherwise return false. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:2","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"Queue ADT The queue abstract data type (ADT) follows the basic design of the stack abstract data type. Each node contains a void pointer to the data and the link pointer to the next element in the queue. The program’s responsibility is to allocate memory for storing the data. //Queue ADT Type Definitions typedef struct node { void *DataPtr; struct node *next; } QueueNode; typedef struct { QueueNode *front; QueueNode *rear; int count; } QUEUE; A Queue contains elements of the same type arranged in sequential order. Operations take place at both ends, insertion is done at the end and deletion is done at the front. Following operations can be performed: enqueue() – Insert an element at the end of the queue. dequeue() – Remove and return the first element of the queue, if the queue is not empty. peek() – Return the element of the queue without removing it, if the queue is not empty. size() – Return the number of elements in the queue. isEmpty() – Return true if the queue is empty, otherwise return false. isFull() – Return true if the queue is full, otherwise return false. From these definitions, we can clearly see that the definitions do not specify how these ADTs will be represented and how the operations will be carried out. There can be different ways to implement an ADT, for example, the List ADT can be implemented using arrays, or singly linked list or doubly linked list. Similarly, stack ADT and Queue ADT can be implemented using arrays or linked lists. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:3","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["前端","Javascript"],"content":"Createitv","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"数组常用方法总结 01_数组常用方法1.html =\u003e 数组基础方法 =\u003e push() =\u003e pop() =\u003e unshift() =\u003e shift() 02_数组常用方法2.html =\u003e ES3.0, IE 6 7 8 可以是使用 =\u003e reverse() =\u003e sort() =\u003e splice() =\u003e join() =\u003e slice() =\u003e concat() 03_数组常用方法3.html =\u003e ES5.0, IE 6 7 8 不好使了 =\u003e indexOf() =\u003e lastIndexOf() =\u003e forEach() =\u003e map() =\u003e fliter() =\u003e every() =\u003e some() 04_数组常用方法4.html =\u003e ES2015(ES6) 以后, 标准浏览器, IE 10 以上 =\u003e fill() =\u003e copyWithin() =\u003e includes() =\u003e flat() =\u003e flatMap() =\u003e find() =\u003e findIndex() ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:0:1","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"push, pop, unshift ,shift // -----------pop----------- const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato']; console.log(plants.pop()); // expected output: \"tomato\" console.log(plants); // expected output: Array [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"] plants.pop(); console.log(plants); // expected output: Array [\"broccoli\", \"cauliflower\", \"cabbage\"] // -----------push----------- const animals = ['pigs', 'goats', 'sheep']; const count = animals.push('cows'); console.log(count); // expected output: 4 console.log(animals); // expected output: Array [\"pigs\", \"goats\", \"sheep\", \"cows\"] animals.push('chickens', 'cats', 'dogs'); console.log(animals); // expected output: Array [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"] // -----------unshift----------- // unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 const array1 = [1, 2, 3]; console.log(array1.unshift(4, 5)); // expected output: 5 console.log(array1); // expected output: Array [4, 5, 1, 2, 3] // -----------shift----------- //shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 const array1 = [1, 2, 3]; const firstElement = array1.shift(); console.log(array1); // expected output: Array [2, 3] console.log(firstElement); // expected output: 1 ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:1:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"reverse, sort, splice, join, slice, concat // -----------reverse----------- // reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。 const array1 = ['one', 'two', 'three']; console.log('array1:', array1); // expected output: \"array1:\" Array [\"one\", \"two\", \"three\"] const reversed = array1.reverse(); console.log('reversed:', reversed); // expected output: \"reversed:\" Array [\"three\", \"two\", \"one\"] // Careful: reverse is destructive -- it changes the original array. console.log('array1:', array1); // expected output: \"array1:\" Array [\"three\", \"two\", \"one\"] // -----------sort----------- // sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 const months = ['March', 'Jan', 'Feb', 'Dec']; months.sort(); console.log(months); // expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // expected output: Array [1, 100000, 21, 30, 4] // ----------sort()比大小------- var numbers = [4, 2, 5, 1, 3]; numbers.sort(function(a, b) { return a - b; }); console.log(numbers); 也可以写成： var numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =\u003e a - b); console.log(numbers); // [1, 2, 3, 4, 5] // -----------splice----------- // splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组 const months = ['Jan', 'March', 'April', 'June']; months.splice(1, 0, 'Feb'); // inserts at index 1 console.log(months); // expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"] months.splice(4, 1, 'May'); // replaces 1 element at index 4 console.log(months); // expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"] // 从第 2 位开始删除 0 个元素，插入“drum” var myFish = [\"angel\", \"clown\", \"mandarin\", \"sturgeon\"]; var removed = myFish.splice(2, 0, \"drum\"); // 运算后的 myFish: [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"] // 被删除的元素: [], 没有元素被删除 // -----------join------------- // join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 const elements = ['Fire', 'Air', 'Water']; console.log(elements.join()); // expected output: \"Fire,Air,Water\" console.log(elements.join('')); // expected output: \"FireAirWater\" console.log(elements.join('-')); // expected output: \"Fire-Air-Water\" // -----------slice------------ // slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 const animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice(2)); // expected output: Array [\"camel\", \"duck\", \"elephant\"] console.log(animals.slice(2, 4)); // expected output: Array [\"camel\", \"duck\"] console.log(animals.slice(1, 5)); // expected output: Array [\"bison\", \"camel\", \"duck\", \"elephant\"] // -----------concat----------- // concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 const array1 = ['a', 'b', 'c']; const array2 = ['d', 'e', 'f']; const array3 = array1.concat(array2); console.log(array3); // expected output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:2:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"indexOf, lastIndexOf, forEach, map, filter, every, some // -------------------indexOf-------------------- // indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 const beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 // start from index 2 console.log(beasts.indexOf('bison', 2)); // expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 // -------------------lastIndexOf-------------------- // lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo']; console.log(animals.lastIndexOf('Dodo')); // expected output: 3 console.log(animals.lastIndexOf('Tiger')); // expected output: 1 // -------------------forEach-------------------- // forEach() 方法对数组的每个元素执行一次给定的函数。返回undefined const array1 = ['a', 'b', 'c']; array1.forEach(element =\u003e console.log(element)); // expected output: \"a\" // expected output: \"b\" // expected output: \"c\" // -------------------map-------------------- // map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x =\u003e x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] // -------------------filter-------------------- // filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter(word =\u003e word.length \u003e 6); console.log(result); // expected output: Array [\"exuberant\", \"destruction\", \"present\"] // -------------------every-------------------- // every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 const isBelowThreshold = (currentValue) =\u003e currentValue \u003c 40; const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true // 检测数组中的所有元素是否都大于 10。 function isBigEnough(element, index, array) { return element \u003e= 10; } [12, 5, 8, 130, 44].every(isBigEnough); // false [12, 54, 18, 130, 44].every(isBigEnough); // true // -------------------some-------------------- // some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 const array = [1, 2, 3, 4, 5]; // checks whether an element is even const even = (element) =\u003e element % 2 === 0; console.log(array.some(even)); // expected output: true //下面的例子检测在数组中是否有元素大于 10。 function isBiggerThan10(element, index, array) { return element \u003e 10; } [2, 5, 8, 1, 4].some(isBiggerThan10); // false [12, 5, 8, 1, 4].some(isBiggerThan10); // true ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:3:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"fill, copyWithin, includes, flat, flatMap, find, findIndex // -------------------fill-------------------- // fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 const array1 = [1, 2, 3, 4]; // fill with 0 from position 2 until position 4 console.log(array1.fill(0, 2, 4)); // expected output: [1, 2, 0, 0] // fill with 5 from position 1 console.log(array1.fill(5, 1)); // expected output: [1, 5, 5, 5] console.log(array1.fill(6)); // expected output: [6, 6, 6, 6] // -------------------copyWithin-------------------- // copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 const array1 = ['a', 'b', 'c', 'd', 'e']; // copy to index 0 the element at index 3 console.log(array1.copyWithin(0, 3, 4)); // expected output: Array [\"d\", \"b\", \"c\", \"d\", \"e\"] // copy to index 1 all elements from index 3 to the end console.log(array1.copyWithin(1, 3)); // expected output: Array [\"d\", \"d\", \"e\", \"d\", \"e\"] // -------------------includes-------------------- // includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 const array1 = [1, 2, 3]; console.log(array1.includes(2)); // expected output: true const pets = ['cat', 'dog', 'bat']; console.log(pets.includes('cat')); // expected output: true console.log(pets.includes('at')); // expected output: false // -------------------flat-------------------- // flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 const arr1 = [0, 1, 2, [3, 4]]; console.log(arr1.flat()); // expected output: [0, 1, 2, 3, 4] const arr2 = [0, 1, 2, [[[3, 4]]]]; console.log(arr2.flat(2)); // expected output: [0, 1, 2, [3, 4]] // -------------------flatMap-------------------- // flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 let arr1 = [\"it's Sunny in\", \"\", \"California\"]; arr1.map(x =\u003e x.split(\" \")); // [[\"it's\",\"Sunny\",\"in\"],[\"\"],[\"California\"]] arr1.flatMap(x =\u003e x.split(\" \")); // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"] // -------------------find-------------------- // find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 const array1 = [5, 12, 8, 130, 44]; const found = array1.find(element =\u003e element \u003e 10); console.log(found); // expected output: 12 // -------------------findIndex-------------------- // findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 const array1 = [5, 12, 8, 130, 44]; const isLargeNumber = (element) =\u003e element \u003e 13; console.log(array1.findIndex(isLargeNumber)); // expected output: 3 ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:4:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["浏览器"],"content":"Createitv","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"浏览器特性 现代浏览器的特性主要包含如下几部分： 网络 浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。 资源管理 浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。 网页浏览 浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。 多页面管理 浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。 插件和扩展 现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。 账户和同步 现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。 安全机制 现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。 开发者工具 开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。 浏览器结构 目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构： 浏览器的抽象分层结构图中将浏览器分成了以下8个子系统： 用户界面（User Interface） 用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。 用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。 浏览器引擎（Browser Engine） 浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。 浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。 浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。 浏览器引擎还允许查询/修改渲染引擎设置。 渲染引擎（Rendering Engine） 渲染引擎为指定的URI生成可视化的表示。 渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。 渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。 渲染引擎内部包含HTML解析器。 网络（Networking） 网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。 JavaScript解释器（JavaScript Interpreter） JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。 XML解析器（XML Parser） XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。 显示后端（Display Backend） 显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。 数据持久层（Data Persistence） 数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。 这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？ 原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。 渲染引擎 浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用： 渲染引擎 浏览器 Trident IE、Edge Gecko Firefox WebKit Safari、Chromium/Chrome ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:0:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"渲染引擎工作流程 如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。 Parsing HTML to Construct DOM Tree 渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。 同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。 Render Tree construction 渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。 渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 Layout of Render Tree 渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 Painting Render Tree 渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。 ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:1:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"渲染引擎组成模块 下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 从图中可以看出，渲染引擎主要包含（或调用）的模块有： HTML（XML）解析器 解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。 CSS解析器 将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。 JavaScript解释器 使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。 布局 DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。 绘图 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。 ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:2:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["python"],"content":"Createitv","date":"2021-05-15","objectID":"/posts/intermediatepython/","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"IntermediatePython ","date":"2021-05-15","objectID":"/posts/intermediatepython/:1:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"*args和**kwargs 并不是必须写成*args 和**kwargs。 只有变量前面的 *(星号)才是必须的. 你也可以写成*var 和**vars. 而写成*args 和**kwargs只是一个通俗的命名约定。 *args的用法 args和**kwargs用于函数不定数量的参数传递，在函数使用者不知道会传递多少个参数下可使用 def test_var_args(f_arg, *argv): print(\"first normal arg:\", f_arg) for arg in argv: print(\"another arg through *argv:\", arg) \u003e\u003e\u003etest_var_args('yasoob', 'python', 'eggs', 'test') first normal arg: yasoob another arg through *argv: python another arg through *argv: eggs another arg through *argv: test **kwargs的用法 **kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 def greet_me(**kwargs): for key, value in kwargs.items(): print(\"{0}=={1}\".format(key, value)) \u003e\u003e\u003egreet_me(name='yasoob') name == yasoob 使用args和**kwargs来调用函数 def test_args_kwargs(arg1, arg2, arg3): print(\"arg1:\", arg1) print('arg2:', arg2) print(\"arg3:\", arg3) # 首先使用*args \u003e\u003e\u003eargs = (\"two\", 3, 5) \u003e\u003e\u003etest_args_kwargs(**kwargs) arg1: two arg2: 3 arg3: 5 #再使用**kwargs \u003e\u003e\u003e kwargs = {\"arg3\": 3, \"arg2\": \"two\", \"arg1\": 5} \u003e\u003e\u003e test_args_kwargs(**kwargs) arg1: 5 arg2: two arg3: 3 标准参数、缺省参数、*args、**kwargs在使用时候的顺序 some_function(argument, argument=' ', *args, **kwargs ) 什么时候使用 根据需求而定：最常见在装饰起之中捕获修饰函数的不定参数 def use_logging(func): def wrapper(*args, **kwargs): # Look this logging.warn(\"%sis running\" % func.__name__) return func(*args) return wrapper @use_logging def foo(): print(\"i am foo\") @use_logging def bar(): print(\"i am bar\") bar() ","date":"2021-05-15","objectID":"/posts/intermediatepython/:2:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"调试Debugging 利用好调试，能大大提高你捕捉代码Bug的。大部分新人忽略了Python debugger(pdb)的重要性。 从命令行启动 $ python -m pdb my_script.py 从脚本内部启动 import pdb def make_bread(): pdb.set_trace() #设置断点 return \"I don't have time\" print(make_bread()) 命令列表： c: 继续执行 w: 显示当前正在执行的代码行的上下文信息 a: 打印当前函数的参数列表 s: 执行当前代码行，并停在第一个能停的地方（相当于单步进入） n: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过） ","date":"2021-05-15","objectID":"/posts/intermediatepython/:3:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"生成器Generators 迭代器(iterators)是一个让程序员可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。 可迭代对象(Iterable)——形容词 迭代器(Iterator)——名词 迭代(Iteration)——动词 可迭代对象(Iterable) Python中任意的对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。 迭代器(Iterator) 任意对象，只要定义了next(Python2) 或者__next__方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration) 迭代(Iteration) 从某个地方（比如一个列表）不断取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。 生成器(Generators) 生成器也是一种迭代器，一次只能迭代一次，类似版本迭代更新。在python中并没有直接把所有数据写入内存中，而是在运行时生成值。可以通过遍历来访问他们，大多数时候通过函数来实现。而且并不返回一个值而是yield一个值。 斐波那契数列生成器 # generator version(减少资源消耗) def fibon(n): a = b = 1 for i in range(n): yield a a, b = b, a + b for x in fibon(1000000): print(x) #faction version def fibon(n): a = b = 1 result = [] for i in range(n): result.append(a) a, b = b, a + b return result ","date":"2021-05-15","objectID":"/posts/intermediatepython/:4:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"高阶函数(Map，Filter，Reduce) Map函数 Map会将一个函数映射到一个输入列表的所有元素上 map(function_to_apply, list_of_inputs) # 对比举例 items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.appedn(i**2) # 等同于 items = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, items)) # 在python2中map直接返回列表，但在python3中返回迭代器 # 因此为了兼容python3, 需要list转换一下 Filter函数 filter过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True number_list = range(-5, 5)less_than_zero = filter(lambda x:x \u003c0, number_list)print(list(less_than_zero)) filter类似于一个for循环，但它是一个内置函数，并且更快。 注意：map和filter相对不那么优雅,推导式的可读性更好。 Reduce函数 reduce() 函数会对参数序列中元素进行累积 reduce(function, iterable[, initializer]) #语法from functools import reduceproduct = reduce( (lambda x, y: x * y), [1, 2, 3, 4] )# Output: 24 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:5:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"Set数据集合 set(集合)是一个非常有用的数据结构。它与列表(list)的行为类似，区别在于set不能包含重复的值。 # 查看重复元素some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']duplicates = []for value in some_list: if some_list.count(value) \u003e 1: if value not in duplicates: duplicates.append(value)print(duplicates)### 输出: ['b', 'n'] 更简单更优雅的解决方案，那就是使用集合(sets) some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']duplicates = set([x for x in some_list if some_list.count(x) \u003e 1])print(duplicates)### 输出: set(['b', 'n']) 交集 对比两个集合的交集（两个集合中都有的数据） valid = set(['yellow', 'red', 'blue', ' green', 'black'])input_set = set(['red', 'brown'])print(input_set.interserction(valid))### 输出:set(['red']) 差集 用差集(difference)找出无效的数据，相当于用一个集合减去另一个集合的数据 valid = set(['yellow', 'red', 'blue', 'green', 'black'])input_set = set(['red', 'brown'])print(input_set.difference(valid))### 输出:set(['brown']) 你也可以用{}符号来创建集合 a_set = {'red', 'blue', 'green'}print(type(a_set))### 输出: \u003ctype 'set'\u003e ","date":"2021-05-15","objectID":"/posts/intermediatepython/:6:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"三元运算符 三元运算符通常在Python里被称为条件表达式，这些表达式基于真(true)/假(false)的条件判断 伪代码 #如果条件为真，返回真 否则返回假condition_is_true if condition else condition_is_false 举例 number = 3flag = '单数' if number % 2 != 0 else '双数'print(flag)### 输出:单数 另外一种超级晦涩的语法 #(返回假，返回真)[真或假](if_test_is_false, if_test_is_true)[test]fat = Truefitness = (\"skinny\", \"fat\")[fat]print(\"Ali is\", fitness)#输出: Ali is fat ","date":"2021-05-15","objectID":"/posts/intermediatepython/:7:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"装饰器 修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿），新手跨越必备。 函数也是对象 def hi(name=\"yasoob\"): return \"hi \" + nameprint(hi())# output: 'hi yasoob'# 我们甚至可以将一个函数赋值给一个变量，比如greet = hi# 我们这里没有在使用小括号，因为我们并不是在调用hi函数# 而是在将它放在greet变量里头。我们尝试运行下这个print(greet())# output: 'hi yasoob'# 如果我们删掉旧的hi函数，看看会发生什么！del hiprint(hi())#outputs: NameErrorprint(greet())#outputs: 'hi yasoob' 函数中定义函数 def hi(name=\"yasoob\"): print(\"now you are inside the hi() function\") def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" print(greet()) print(welcome()) print(\"now you are back in the hi() function\")hi()#output:now you are inside the hi() function# now you are in the greet() function# now you are in the welcome() function# now you are back in the hi() function# 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。# 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：greet()#outputs: NameError: name 'greet' is not defined 从函数中返回函数 def hi(name=\"yasoob\"): def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" if name == \"yasoob\": return greet else: return welcomea = hi()print(a)#outputs: \u003cfunction greet at 0x7f2143c01500\u003e#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数#现在试试这个print(a())#outputs: now you are in the greet() function 将函数作为参数传给另一个函数 def hi(): return \"hi yasoob!\"def doSomethingBeforeHi(func): print(\"I am doing some boring work before executing hi()\") print(func())doSomethingBeforeHi(hi)#outputs:I am doing some boring work before executing hi()# hi yasoob! 装饰器应用 def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunctiondef a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\")a_function_requiring_decoration()#outputs: \"I am the function which needs some decoration to remove my foul smell\"a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)#now a_function_requiring_decoration is wrapped by wrapTheFunction()a_function_requiring_decoration()#outputs:I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func() 装饰起语法糖 @a_new_decoratordef a_function_requiring_decoration(): \"\"\"Hey you! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\")a_function_requiring_decoration()#outputs: I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func()#the @a_new_decorator is just a short way of saying:a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 使用场景 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中 from functools import wrapsdef requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated ","date":"2021-05-15","objectID":"/posts/intermediatepython/:8:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"slots魔法 在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这非常有用，因为它允许我们在运行时去设置任意的新属性。 然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象（我指的是成千上万个），它会消耗掉很多内存。 不过还是有一个方法来规避这个问题。这个方法需要使用__slots__来告诉Python不要使用字典，而且只给一个固定集合的属性分配空间。 不使用__slots__: class MyClass(object): def __init__(self, name, identifier): self.name = name self.identifier = identifier self.set_up() 使用__slots__ class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self.name = name self.identifier = identifier self.set_up() 第二段代码会为你的内存减轻负担。通过这个技巧，有些人已经看到内存占用率几乎40%~50%的减少。 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:9:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"虚拟环境Virtualenv 什么是虚拟环境？ Virtualenv 是一个工具，它能够帮我们创建一个独立(隔离)的Python环境。想象你有一个应用程序，依赖于版本为2的第三方模块，但另一个程序依赖的版本是3，请问你如何使用和开发这些应用程序？ 如果你把一切都安装到了/usr/lib/python2.7/site-packages（或者其它平台的标准位置），那很容易出现某个模块被升级而你却不知道的情况。 在另一种情况下，想象你有一个已经开发完成的程序，但是你不想更新它所依赖的第三方模块版本；但你已经开始另一个程序，需要这些第三方模块的版本。 虚拟环境安装 pip install virtualenv 虚拟环境启动 $ virtualenv myproject $ source myproject/bin/activate 执行第一个命令在myproject文件夹创建一个隔离的virtualenv环境，第二个命令激活这个隔离的环境(virtualenv)。 如果你想让你的virtualenv使用系统全局模块，请使用--system-site-packages 虚拟环境关闭 $ deactivate 小工具 smartcd你可以使用smartcd来帮助你管理你的环境，当你切换目录时，它可以帮助你激活（activate）和退出（deactivate）你的virtualenv ","date":"2021-05-15","objectID":"/posts/intermediatepython/:10:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"容器(collections) defaultdict defaultdict与dict类型不同，你不需要检查key是否存在，所以能这样做 from collections import defaultdictcolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'),)favourite_colours = defaultdict(list)for name, colour in colours: favourite_colours[name].append(colour)print(favourite_colours)# defaultdict(\u003ctype 'list'\u003e,# {'Arham': ['Green'],# 'Yasoob': ['Yellow', 'Red'],# 'Ahmed': ['Silver'],# 'Ali': ['Blue', 'Black']# }) 当你在一个字典中对一个键进行嵌套赋值时，如果这个键不存在，会触发keyError异常。 defaultdict允许我们用一个聪明的方式绕过这个问题。 首先我分享一个使用dict触发KeyError的例子，然后提供一个使用defaultdict的解决方案 some_dict = {}some_dict['colours']['favourite'] = \"yellow\"## 异常输出：KeyError: 'colours'import collectionstree = lambda: collections.defaultdict(tree)some_dict = tree()some_dict['colours']['favourite'] = \"yellow\"## 运行正常 counter counter是一个计数器，帮助我们对数据进行计数 from collections import Countercolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'),)favs = Counter(name for name, colour in colours)print(favs)## 输出:## Counter({## 'Yasoob': 2,## 'Ali': 2,## 'Arham': 1,## 'Ahmed': 1## }) 我们也可以在利用它统计一个文件 with open('filename', 'rb') as f: line_count = Counter(f)print(line_count) deque deque提供了一个双端队列，你可以从头和尾两端添加或者删除元素。 from collections import dequed = deque()d.append('1')d.append('2')d.append('3')print(len(d))# output:3print(d[0])# output:'1'print(d[-1])# output:'3' 从两端取出(pop)数据： d = deque(range(5))print(len(d))## 输出: 5d.popleft()## 输出: 0d.pop()## 输出: 4print(d)## 输出: deque([1, 2, 3]) namedtuple enum.Enum ","date":"2021-05-15","objectID":"/posts/intermediatepython/:11:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"枚举Enumerate 枚举(enumerate)是Python内置函数 my_list = ['apple', 'banana', 'grapes', 'pear']for c, value in enumerate(my_list, 1): print(c, value)# 输出:(1, 'apple')(2, 'banana')(3, 'grapes')(4, 'pear') ","date":"2021-05-15","objectID":"/posts/intermediatepython/:12:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"对象自省 自省(introspection)，在计算机编程领域里，是指在运行时来判断一个对象的类型的能力。它是Python的强项之一。Python中所有一切都是一个对象，而且我们可以仔细勘察那些对象。Python还包含了许多内置函数和模块来帮助我们。 dir 返回一个列表，列出了一个对象所拥有的属性和方法。自省给了我们一个列表对象的所有方法的名字。当你没法回忆起一个方法的名字，这会非常有帮助。 my_list = [1, 2, 3]dir(my_list)# Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',# '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',# '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',# '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',# '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',# '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',# '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',# 'remove', 'reverse', 'sort'] type和id type函数返回一个对象的类型 print(type(''))# Output: \u003ctype 'str'\u003eprint(type([]))# Output: \u003ctype 'list'\u003eprint(type({}))# Output: \u003ctype 'dict'\u003eprint(type(dict))# Output: \u003ctype 'type'\u003eprint(type(3))# Output: \u003ctype 'int'\u003e id()函数返回任意不同种类对象的唯一ID name = \"Yasoob\"print(id(name))# Output: 139972439030304 inspect模块 inspect模块也提供了许多有用的函数，来获取活跃对象的信息。 import inspectprint(inspect.getmembers(str))# Output: [('__add__', \u003cslot wrapper '__add__' of ... ... ","date":"2021-05-15","objectID":"/posts/intermediatepython/:13:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"推导式 推导式（又称解析式）是Python的一种独有特性，推导式可以从一个数据序列构建另外一个数据序列的结构体。 列表推导式 字典推导式 集合推导式 List Comprehension 列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。 它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以if和for语句为上下文的表达式运行完成之后产生。 variable = [out_exp for out_exp in input_list if out_exp == 2] Dictionary Comprehension mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}mcase_frequency = { k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()}# mcase_frequency == {'a': 17, 'z': 3, 'b': 34} 快速对换一个字典的键和值 {v: k for k, v in some_dict.items()} Set Comprehension 它们跟列表推导式也是类似的。 唯一的区别在于它们使用大括号{} squared = {x**2 for x in [1, 1, 2]}print(squared) ","date":"2021-05-15","objectID":"/posts/intermediatepython/:14:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"异常 异常处理是一种艺术，一旦你掌握，会授予你无穷的力量 try: file = open('test.txt', 'rb')except IOError as e: print(\"An IOError occurred. {}\".format(e.args[-1])) 处理多个异常 第一种方法需要把所有可能发生的异常放到一个元组里。像这样： try: file = open('test.txt', 'rb')except (IOError, EOFError) as e: print(\"An error occurred. {}\".format(e.args[-1])) 另外一种方式是对每个单独的异常在单独的except语句块中处理。我们想要多少个except语句块都可以。 try: file = open('test.txt', 'rb')except EOFError as e: print(\"An EOF error occurred.\") raise eexcept IOError as e: print(\"An error occurred.\") raise e 捕获所有异常 try: file = open(\"test.txt\", 'rb')except Exception: # 打印一些异常日志，如果你想要的话 raise finally 从句 包裹到finally从句中的代码不管异常是否触发都将会被执行。这可以被用来在脚本执行之后做清理工作。 try: file = open(\"test.txt\", 'rb')except IOError as e: print(\"An IOError occurred.{}\".format(e.args[-1]))finally: print(\"This would be printed wheher or not an exception occurred!\") try / else从句 else可以用在不触发异常的情况下执行一些代码 try: print('I am sure no exception is going to occur!')except Exception: print('exception')else: # 这里的代码只会在try语句里没有触发异常时运行, # 但是这里的异常将 *不会* 被捕获 print('This would only run if no exception occurs. And an error here ' 'would NOT be caught.')finally: print('This would be printed in every case.')# Output: I am sure no exception is going to occur!# This would only run if no exception occurs.# This would be printed in every case. ","date":"2021-05-15","objectID":"/posts/intermediatepython/:15:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"lambda表达式 它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式 原型 lambda 参数:操作(参数) 例子 add = lambda x, y: x + yprint(add(3, 5))# Output: 8 列表排序 a = [(1, 2), (4 ,1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1])print(a)# Output: [(13, -3), (4, 1), (1, 2), (9, 10)] ","date":"2021-05-15","objectID":"/posts/intermediatepython/:16:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"一行式 简易Web Server 你是否想过通过网络快速共享文件？好消息，Python为你提供了这样的功能。 # Python 2python -m SimpleHTTPServer# Python 3python -m http.server 漂亮的打印 你可以在Python REPL漂亮的打印出列表和字典。这里是相关的代码： from pprint import pprintmy_dict = {'name': 'Yasoob', 'age': 'undefined', 'personality': 'awesome'} pprint(my_dict) 想快速漂亮的从文件打印出json数据，那么你可以这么做 cat file.json | python -m json.tool 脚本性能分析 这可能在定位你的脚本中的性能瓶颈时 python -m cProfile my_scripy.py CSV转换为json python -c \"import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))\" 一行式的构造器 class A(object): def __init__(self, a, b, c, d, e, f): self.__dict__.update({k: v for k, v in locals().items() if k != 'self'}) ","date":"2021-05-15","objectID":"/posts/intermediatepython/:17:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"For-else else从句会在循环正常结束时执行。这意味着，循环没有遇到任何break 有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使用break来中断这个循环。有两个场景会让循环停下来。 第一个是当一个元素被找到，break被触发。 第二个场景是循环结束。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n / x) break else: # loop fell through without finding a factor print(n , 'is a prime number') ","date":"2021-05-15","objectID":"/posts/intermediatepython/:18:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"使用C扩展 开发者有三种方法可以在自己的Python代码中来调用C编写的函数-ctypes，SWIG，Python/C API。每种方式也都有各自的利弊。 要在Python中调用C？原因如下： 你要提升代码的运行速度，而且你知道C要比Python快50倍以上 C语言中有很多传统类库，而且有些正是你想要的，但你又不想用Python去重写它们 想对从内存到文件接口这样的底层资源进行访问 不需要理由，就是想这样做 Ctypes Python中的ctypes模块可能是Python调用C方法中最简单的一种。ctypes模块提供了和C语言兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。也正是如此奠定了这种方法的简单性。 SWIG SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种方法。在这个方法中，开发人员必须编写一个额外的接口文件来作为SWIG(终端工具)的入口。 Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。 Python/C API Python/C API可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:19:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"函数缓存 函数缓存允许我们将一个函数对于给定参数的返回值缓存起来。 当一个I/O密集的函数被频繁使用相同的参数调用的时候，函数缓存可以节约时间。 在Python 3.2版本以前我们只有写一个自定义的实现。在Python 3.2以后版本，有个lru_cache的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存。 python3.2+ 实现一个斐波那契计算器，并使用lru_cache ","date":"2021-05-15","objectID":"/posts/intermediatepython/:20:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["前端"],"content":"Createitv","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Lecture 0 Introduction Web Programming HTML (Hypertext Markup Language) Document Object Model (DOM) More HTML Elements Forms CSS (Cascading Style Sheets) Responsive Design Bootstrap Sass (Syntactically Awesome Style Sheets) ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:0:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Introduction In this course, we’re picking up where CS50 left off and diving into the design and creation of web applications. We’ll build our web-design skills by working on a number of projects throughout the course, including an open-ended final project where you’ll have the chance to create a website of your own! In this course, you’ll need a text editor where you can write code locally on your computer. Some popular ones include Visual Studios Code, Sublime Text, Atom, and Vim, but there are many more to choose from! ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:1:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Web Programming Course Topics: We’ll go into more detail later, but here’s a brief overview of what we’ll be working on during this course: HTML and CSS (a markup language used to outline a webpage, and a procedure for making our sites more visually appealing) Git (used for version control and collaboration) Python (a widely-used programming language we’ll use to make our sites more dynamic) Django (a popular web framework we’ll use for the backend of our sites) SQL, Models, and Migrations (a language used for storing and retrieving data, and Django-specific methods that make it easier to interact with SQL databases) JavaScript (a programming language used to make websites faster and more interactive) User Interfaces (methods used to make a website as easy to use as possible) Testing, CI, CD (learning about different methods used to make sure updates to web pages proceed smoothly) Scalability and Security (making sure our websites can be accessed by many users at once, and that they are safe from malicious intent) ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:2:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"HTML (Hypertext Markup Language) HTML is a markup language that defines the structure of a web page. It is interpreted by your web browser (Safari, Google Chrome, Firefox, etc.) in order to display content on your screen. Let’s get started by writing a simple HTML file! \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e When we open up this file in our browser, we get: Now, let’s take some time to talk about the file we just wrote, which seems to be pretty complicated for such a simple page. In the first line, we are declaring (to the web browser) that we are writing the document in the latest version of HTML: HTML5. After that, the page consists of nested HTML elements (such as html and body), each with an opening and closing tag marked with either \u003celement\u003e for an opening and \u003c/element\u003e for a closing. Notice how each of the inner elements is indented just a bit further than the last. While this is not necessarily required by the browser, it will be very helpful to keep this up in your own code. HTML elements can include attributes, which give the browser extra information about the element. For example, when we include lang=\"en\" in our initial tag, we are telling the browser that we are using English as our primary language. Inside the HTML element, we typically want to include both a head and a body tag. The head element will include information about your page that is not necessarily displayed, and the body element will contain what is actually visible to users who visit the site. Within the head, we have included a title for our webpage, which you’ll notice is displayed in the tab at the top of our web browser. Finally, we’ve included the text “Hello, world!” in the body, which is the visible part of our page. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Document Object Model (DOM) The DOM is a convenient way of visualizing the way HTML elements relate to each other using a tree-like structure. Above is an example of the DOM layout for the page we just wrote. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:1","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"More HTML Elements There are many HTML elements you may want to use to customize your page, including headings, lists, and bolded sections. In this next example, we’ll see a few of of these in action. One more thing to note: \u003c!-- --\u003e gives us a comment in HTML, so we’ll use that below to explain some of the elements. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHTML Elements\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- We can create headings using h1 through h6 as tags. --\u003e \u003ch1\u003eA Large Heading\u003c/h1\u003e \u003ch2\u003eA Smaller Heading\u003c/h2\u003e \u003ch6\u003eThe Smallest Heading\u003c/h6\u003e \u003c!-- The strong and i tags give us bold and italics respectively. --\u003e A \u003cstrong\u003ebold\u003c/strong\u003e word and an \u003ci\u003eitalicized\u003c/i\u003e word! \u003c!-- We can link to another page (such as cs50's page) using a. --\u003e View the \u003ca href=\"https://cs50.harvard.edu/\"\u003eCS50 Website\u003c/a\u003e! \u003c!-- We used ul for an unordered list and ol for an ordered one. both ordered and unordered lists contain li, or list items. --\u003e An unordered list: \u003cul\u003e \u003cli\u003efoo\u003c/li\u003e \u003cli\u003ebar\u003c/li\u003e \u003cli\u003ebaz\u003c/li\u003e \u003c/ul\u003e An ordered list: \u003col\u003e \u003cli\u003efoo\u003c/li\u003e \u003cli\u003ebar\u003c/li\u003e \u003cli\u003ebaz\u003c/li\u003e \u003c/ol\u003e \u003c!-- Images require a src attribute, which can be either the path to a file on your computer or the link to an image online. It also includes an alt attribute, which gives a description in case the image can't be loaded. --\u003e An image: \u003cimg src=\"../../images/duck.jpeg\" alt=\"Rubber Duck Picture\"\u003e \u003c!-- We can also see above that for some elements that don't contain other ones, closing tags are not necessary. --\u003e \u003c!-- Here, we use a br tag to add white space to the page. --\u003e \u003cbr/\u003e \u003cbr/\u003e \u003c!-- A few different tags are necessary to create a table. --\u003e \u003ctable\u003e \u003cthead\u003e \u003cth\u003eOcean\u003c/th\u003e \u003cth\u003eAverage Depth\u003c/th\u003e \u003cth\u003eMaximum Depth\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003ePacific\u003c/td\u003e \u003ctd\u003e4280 m\u003c/td\u003e \u003ctd\u003e10911 m\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAtlantic\u003c/td\u003e \u003ctd\u003e3646 m\u003c/td\u003e \u003ctd\u003e8486 m\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003chtml\u003e This page, when rendered, looks something like this: In case you’re worried about it, know that you’ll never have to memorize these elements. It’s very easy to simply search something like “image in HTML” to find the img tag. One resource that’s especially helpful for learning about these elements is W3 Schools. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:2","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Forms Another set of elements that is really important when creating a website is how to collect information from users. You can allow users to enter information using an HTML form, which can contain several different types of input. Later in the course, we’ll learn about how to handle information once a form has been submitted. Just as with other HTML elements, there’s no need to memorize these, and W3 Schools is a great resource for learning about them! \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eForms\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform\u003e \u003cinput type=\"text\" placeholder=\"First Name\" name=\"first\"\u003e \u003cinput type=\"password\" placeholder=\"Password\" name=\"password\"\u003e \u003cdiv\u003e Favorite Color: \u003cinput name=\"color\" type=\"radio\" value=\"blue\"\u003e Blue \u003cinput name=\"color\" type=\"radio\" value=\"green\"\u003e Green \u003cinput name=\"color\" type=\"radio\" value=\"yellow\"\u003e Yellow \u003cinput name=\"color\" type=\"radio\" value=\"red\"\u003e Red \u003c/div\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:3","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"CSS (Cascading Style Sheets) CSS is used to customize the appearance of a website. While we’re just getting, started, we can add a style attribute to any HTML element in order to apply some CSS to it. We change style by altering the CSS properties of an element, writing something like color: blue or text-align: center In this example below, we make a slight change to our very first file to give it a colorful heading: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"color: blue; text-align: center;\"\u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e If we style an outer element, all of the inner elements automatically take on that style. We can see this if we move the styling we just applied from the header tag to the body tag: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody style=\"color: blue; text-align: center;\"\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e While we can style our web page as we’ve done above, to achieve better design, we should be able to move our styling away from the individual lines. One way of doing this is to add your styling between \u003cstyle\u003e tags in the head. Inside these tags, we write which types of elements we want to be style, and the styling we wish to apply to them. For example: \u003chtml lang=\"en\"\u003e \u003c!DOCTYPE html\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003cstyle\u003e h1 { color: blue; text-align: center; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003c/html\u003e Another way is to include in a \u003clink\u003e element in your head with a link to a styles.css file that contains some styling. This means the HTML file would look like: \u003chtml lang=\"en\"\u003e \u003c!DOCTYPE html\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003c/html\u003e And our file called styles.css would look like: h1 { color: blue; text-align: center; } There are far too many CSS properties to go over here, but just like HTML elements, it’s typically easy to Google something along the lines of “change font to blue CSS” to get the result. Some of the most common ones though are: color: the color of text text-align: where elements are placed on the page background-color: can be set to any color width: in pixels or percent of a page height: in pixels or percent of a page padding: how much space should be left inside an element margin: how much space should be left outside an element font-family: type of font for text on page font-size: in pixels border: size type (solid, dashed, etc) color Let’s use some of what we just learned to improve upon our oceans table from above. Here’s some HTML to start us off: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eNicer Table\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003cthead\u003e \u003cth\u003eOcean\u003c/th\u003e \u003cth\u003eAverage Depth\u003c/th\u003e \u003cth\u003eMaximum Depth\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003ePacific\u003c/td\u003e \u003ctd\u003e4280 m\u003c/td\u003e \u003ctd\u003e10911 m\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAtlantic\u003c/td\u003e \u003ctd\u003e3646 m\u003c/td\u003e \u003ctd\u003e8486 m\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003chtml\u003e The above looks a lot like what we had before, but now, either by including a style tag or a link to a stylesheet in the head element, we add the following css: table { border: 1px solid black; border-collapse: collapse; } td { border: 1px solid black; padding: 2px; } th { border: 1px solid black; padding: 2px; } Which leaves us with this nicer-looking table: You may already be thinking that there’s some needless repetition in our CSS at the moment, as td and th have the same styling. We can (and should) condense this down to the following code, using a comma to show the styling should apply to more than one element type. table { border: 1px solid black; border-collapse: collapse; } td, th { border: 1px solid black; padding: 2px; } This is a good introduction into what are known as CSS selectors . There are many ways to determine which HTML elements you are styling, some of which we’ll mention here: element type: this is what we’ve been doing so far: styli","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:4:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Responsive Design Today, many people view websites on devices other than computers, such as smartphones and tablets. It’s important to make sure your website is readable to people on all devices. One way we can achieve this is through knowledge of the viewport. The viewport is the part of the screen that is actually visible to the user at any given time. By default, many webpages assume that the viewport is the same on any device, which is what leads to many sites (especially older ones) being difficult to interact with on mobile devices. One simple way to improve the appearance of a site on a mobile device is to add the following line in the head of our HTML files. This line tells the mobile device to use a viewport that is the same width as that of the device you’re using rather than a much larger one. \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e Another way we can deal with different devices is through media queries. Media queries are ways of changing the style of a page based on how the page is being viewed. For an example of a media query, let’s try to simply change the color of the screen when it shrinks down to a certain size. We signal a media query by typing @media followed by the type of query in parentheses: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eScreen Size\u003c/title\u003e \u003cstyle\u003e @media (min-width: 600px) { body { background-color: red; } } @media (max-width: 599px) { body { background-color: blue; } } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to the page!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e Another way to deal with differing screen size is using a new CSS attribute known as a flexbox. This allows us to easily have elements wrap around to the next line if they don’t fit horizontally. We do this by putting all of our elements in a div that we’ll call our container. We then add some styling to that div specifying that we want to use a flexbox display for the elements inside of it. We’ve also added some additional styling to the inner divs to better illustrate the wrapping that’s occuring here. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eScreen Size\u003c/title\u003e \u003cstyle\u003e #container { display: flex; flex-wrap: wrap; } #container \u003e div { background-color: green; font-size: 20px; margin: 20px; padding: 20px; width: 200px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"container\"\u003e \u003cdiv\u003eSome text 1!\u003c/div\u003e \u003cdiv\u003eSome text 2!\u003c/div\u003e \u003cdiv\u003eSome text 3!\u003c/div\u003e \u003cdiv\u003eSome text 4!\u003c/div\u003e \u003cdiv\u003eSome text 5!\u003c/div\u003e \u003cdiv\u003eSome text 6!\u003c/div\u003e \u003cdiv\u003eSome text 7!\u003c/div\u003e \u003cdiv\u003eSome text 8!\u003c/div\u003e \u003cdiv\u003eSome text 9!\u003c/div\u003e \u003cdiv\u003eSome text 10!\u003c/div\u003e \u003cdiv\u003eSome text 11!\u003c/div\u003e \u003cdiv\u003eSome text 12!\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Another popular way of styling a page is using an HTML grid. In this grid, we can specify style attributes such as column widths and gaps between columns and rows, as demonstrated below. Note that when we specify column widths, we say the third one is auto, meaning it should fill the rest of the page. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cstyle\u003e .grid { background-color: green; display: grid; padding: 20px; grid-column-gap: 20px; grid-row-gap: 10px; grid-template-columns: 200px 200px auto; } .grid-item { background-color: white; font-size: 20px; padding: 20px; text-align: center; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"grid\"\u003e \u003cdiv class=\"grid-item\"\u003e1\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e2\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e3\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e4\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e5\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e6\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e7\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e8\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e9\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e10\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e11\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e12\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:5:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Bootstrap It turns out that there are many libraries that other people have already written that can make the styling of a webpage even simpler. One popular library that we’ll use throughout the course is known as bootstrap. We can include bootstrap in our code by adding a single line to the head of our HTML file: \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"\u003e Next, we can look at some of bootstrap’s features by navigating to the documentation portion of their website. On this page, you’ll find many examples of classes you can add to elements that allow them to be styled with bootstrap. One popular bootstrap feature is their grid system. Bootstrap automatically splits a page into 12 columns, and we can decide how many columns an element takes up by adding the class col-x where x is a number between 1 and 12. For example, in the following page, we have a row of columns of equal width, and then a row where the center column is larger: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"\u003e \u003cstyle\u003e .row \u003e div { padding: 20px; background-color: teal; border: 2px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-4\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-4\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-4\"\u003e This is a third section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cbr/\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-3\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-6\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-3\"\u003e This is a third section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e To improve mobile-responsiveness, bootstrap also allows us to specify column sizes that differ depending on the screen size. In the following example, we use col-lg-3 to show that an element should take up 3 columns on a large screen, and col-sm-6 to show an element should take up 6 columns when the screen is small: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"\u003e \u003cstyle\u003e .row \u003e div { padding: 20px; background-color: teal; border: 2px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a third section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a fourth section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:6:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Sass (Syntactically Awesome Style Sheets) So far, we’ve found a few ways to eliminate redundancy in CSS such as moving it to separate files or using bootstrap, but there are still quite a few places where we can still make improvements. For example, what if we want several elements to have different styles, but for all of them to be the same color? If we decide later we want to change the color, then we would have to change it within several different elements. Sass is a language that allows us to write CSS more efficiently in several ways, one of which is by allowing us to have variables, as in the following example. When writing in Sass, we create a new file with the extension filename.scss. In this file, we can create a new variable by adding a $ before a name, then a colon, then a value. For example, we would write $color: red to set the variable color to the value red. We then access that variable using $color. Here’s an example of our variables.scss file: $color: red; ul { font-size: 14px; color: $color; } ol { font-size: 18px; color: $color; } Now, in order to link this styling to our HTML file, we can’t just link to the .scss file because most web browsers only recognize .css files. To deal with this problem, we have to download a program called Sass onto our computers. Then, in our terminal, we write sass variables.scss:variables.css This command will compile a .scss file named variables.scss into a .css file named variables.css, to which you can add a link in your HTML page. To speed up this process, we can use the command sass --watch variables.scss:variables.css which automatically changes the .css file every time a change is detected in the .scss file. While using Sass, we can also physically nest our styling rather than use the CSS selectors we talked about earlier. For example, if we want to apply some styling only to paragraphs and unordered lists within a div, we can write the following: div { font-size: 18px; p { color: blue; } ul { color: green; } } Once compiled into CSS, we would get a file that looks like: div { font-size: 18px; } div p { color: blue; } div ul { color: green; } One more feature that Sass gives us is known as inheritance. This allows us to create a basic set of styling that can be shared by several different elements. We do this by adding a % before a name of a class, adding some styling, and then later adding the line @extend %classname to the beginning of some styling. For example, the following code applies the styling within the message class to each of the different classes below, resulting in a webpage that looks like the one below. %message { font-family: sans-serif; font-size: 18px; font-weight: bold; border: 1px solid black; padding: 20px; margin: 20px; } .success { @extend %message; background-color: green; } .warning { @extend %message; background-color: orange; } .error { @extend %message; background-color: red; } That wraps up our content for today! ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:7:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["总结"],"content":" 求证的合群，不如自证的孤独 本月主题 ： python爬虫， ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"读书记录 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:1:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"python编程之美 爬虫Request库作者所书，难度适中，封面美丽。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:1:1","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"学习 这个月学习主题多有涉及：vim编辑器、算法复杂度、队列、爬虫解析xpath，re，Bs4、代理爬虫。主要是涉及了爬虫爬虫比我想象中要难，尤其是各种验证码识别，反爬虫破解。已经做到可以爬取豆瓣电影Top250，拉勾网招聘爬虫，小有收获。python csv，json，sql数据库还不太熟悉。4月份打算放一放scrapy先耍耍Django，再回头。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:2:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"投资 耐心等待周期 ☞第一，不要去追求“银弹”，即所谓的低风险甚至无风险的高收益。因为，这种“银弹”会引诱人们动用杠杆或是一把梭，结果可能会有不错的收益，但也有可能出现一系列极其糟糕的结果，而后者在市场里出现的概率更为普遍。当重大损失发生后，而后市场又刚好出现好机会，那么此时的机会必然与自身擦肩而过。 ☞第二，面对市场低迷期，在确定标的长期可持续增长的情况下，持续买入。因为，你耐心地持有，周期的力量会让它的内在价值和价格趋于一致。 ☞第三，持续的学习，只有持续的学习，并习得独立思考判断的能力，才能在耐心等待过程中，识别出机会并抓住它。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:3:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":" 正月已过，重新启程。先做正确的事情，再把事情做对 本月主题 ： 区块链技术入门，密西根Python3 Programming， 如何销售 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"读书记录 区块链革命 没想道会有Apple II之父沃兹尼亚克推荐，可见比特币和区块链技术已经成为了硅谷共识，不得不关注。这本书居区块链入门书籍中高阶部分，所以不像其他区块链通识书籍，阅读起来较为困难，导致豆瓣评分不高。上阵父子兵，没想到写书还有父子兵。Coursera还有两位作者一起创作的Mooc，也以本书为参考教材。本书涉及区块链设计原则较多，而非区块链底层原理。 数字黄金 区块链小白书，豆瓣评分也明显偏高。涉及比特币原理：区块链技术、密码箱原理、分布式账本、挖矿、共识机制。 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:1","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"学习 不得不说国外的Mooc是真TM贴心，云环境，网页编辑器，课本、视频、练习、作业、考核、评论。完全跨过操作系统限制、环境配置、网络，能够体会到背后的用心，这也是我喜欢靠自己自学的原因。课程质量高一圈，体贴程度也是高一圈。下一步玩玩爬虫，做个蜘蛛侠，也巩固下学习内容。 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:2","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"销售 不得不吹一下Box定投践行群，第一期销售训练营也都是实打实的分享，基本上都在我主动边界以外的内容，不加群根本不知道还可以这样做销售，销售也只有一个理念，价值服务。 销售的不是产品，是你自己 过滤你的顾客 顾客买的不是产品，买的为什么 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:3","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"投资 开年以来交易日均值回归，📉跌幅尽在射程范围以内。从预计年化101%直接到20%，我的目标是年化15%足矣。此外张坤的易方达中小盘今年分红竟然有9%，赚钱只有一个姿势：躺 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:4","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"}]