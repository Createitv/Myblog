[{"categories":["自己"],"content":"Createitv","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"25以后 这篇文章是我有限的思考中对于别人无足轻重、对于自己至关重要的总结。写下的都是主观的我认为，一流的作者下笔之前考虑的都是别人怎么看，在未成为一流的作者之前我只能做到仅关心自己以及以后的自己该怎么看。以下所有观点从来不是我与生俱来具有，向来都是借鉴于别人，大部分来自于他人或他人的相关书籍。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:0:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于Stop Doing List 如果知道我会死在哪里，那我将永远不去那个地方。这段话出至于股神巴菲特的小伙伴——查理·芒格。我第一次看见是在段永平的自传中，段永平说不是因为做了什么才有步步高，而是因为没有做家电、房地产、IT才成就了步步高。一般人学习理解是总是觉得做什么是最重要的，其实最重要的是不做什么。巴菲特能有今天最重要的是“不做什么”。Stop Doing List这个概念也是抄袭于段永平。我从来不知道做什么会让我感到幸福，但是我是一定知道做什么会感到不幸福。绝大部分都是知道自己不想做什么，但不是绝大部分人知道自己到底想做什么。 以下是自己的Stop Doing List，这份清单会随着年龄不断增加。 莫在乎他人 莫失眠 莫生气 莫关心前沿政治 莫常刷朋友圈 莫用百度 莫刷抖音 莫发微博 莫排队 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:1:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于自己 故事剧情的发展总会有一条主线，为人行事也有一条顶层原则。这里不得不提马斯洛的需求理论。马斯洛将人的需求分成五种不同的层级。 生理需要 安全需要 社交需要 尊重需要 自我实现需要 处于我们国家的现代社会基本上大部分人都处于尊重需要于自我实现需求之间，在我看来，我简单的把人的需求分为两种状态 第一种满足生存状态：即不断地以满足自己或家人的生产资料为主线。 第二种满足生活状态：即不断地正视自我、娱乐自我，实现自我为主线。 如果我的背后可以让我选择，一定会选择满足生活状态而不是满足生存状态，如果必须切换到满足生存状态，我也会毫不犹豫的切换到满足胜过状态。不过很庆幸，现在的我可以选择，选择满足满足生活状态。 刚毕业的时候，只知道讨厌的事情一堆，花了接近两年的时间总算是找到了喜欢又看起来有钱途的方向，又花了一年的时间去让自己配得上这份工作。终归是走在满足生活的状态上，再难的事情也多是欢喜。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:2:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于爱情 看过弗洛伦蒂诺·阿里萨对费尔米娜·达萨不可思议的恋情，杰伊·盖茨比对黛茜一厢情愿的爱情，杨绛与钱钟书的从未想过娶他人之爱，伊丽莎白于达西跨越阶级之爱，晓霞与少平之从未拥有的爱情。爱情到底是什么样子，谁知道呢？我相信只有医生才能解释清楚那只是残留在身体内让人欢愉的情愫，会生会老也会死。 。不过最羡慕的应该是《人世间》中秉坤和郑娟。关于爱情在我心中没有人比仓央嘉措写的还要符合我心，不曾得到又何谈失去。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:3:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"十诫诗 第一最好不相见，如此便可不相恋 第二最好不相知，如此便可不相思 第三最好不相伴，如此便可不相欠。 第四最好不相惜，如此便可不相忆。 第五最好不相爱，如此便可不相弃。 第六最好不相对，如此便可不相会。 第七最好不相误，如此便可不相负。 第八最好不相许，如此便可不相续。 第九最好不相依，如此便可不相偎。 第十最好不相遇，如此便可不相聚。 但曾相见便相知，相见何如不见时。 安得与君相诀绝，免教生死作相思。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:3:1","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"问佛 我问佛：为何不给所有女子羞花闭月的容颜？ 佛曰：那只是昙花的一现，用来蒙蔽世俗的眼 没有什么美可以抵过一颗纯净仁爱的心 我把它赐给每一个女子 可有人让它蒙上了灰 我问佛：世间为何有那么多遗憾？ 佛曰：这是一个娑婆世界，娑婆即遗憾 没有遗憾，给你再多幸福也不会体会快乐 我问佛：如何让人们的心不再感到孤单？ 佛曰：每一颗心生来就是孤单而残缺的 多数带着这种残缺度过一生 只因与能使它圆满的另一半相遇时 不是疏忽错过，就是已失去了拥有它的资格 我问佛：如果遇到了可以爱的人，却又怕不能把握该怎么办？ 佛曰：留人间多少爱，迎浮世千重变 和有情人，做快乐事 别问是劫是缘 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:4:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于快乐 顶级快乐：看小说 次顶级：敲代码 || 足球 小小快乐：撩妹 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:5:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于小说 精神干粮，主看国内近现代小说。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:6:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于编程 Talk is cheap，Code is artistic，编程是一门只有少入人才能参透的艺术。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:7:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于足球 我把足球当个啥？还未思考。 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:8:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于朋友 君子之交淡若水 亦能载舟，亦能覆舟 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:9:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"关于事业 尽兴皆可 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:10:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["自己"],"content":"参考 《段永平传》 《仓央嘉措诗歌全集》 《傲慢与偏见》 《平凡的世界》 《霍乱时期的爱情》 《了不起的盖茨比》 《人世间》 ","date":"2022-02-06","objectID":"/posts/25%E4%BB%A5%E5%90%8E/:11:0","tags":[],"title":"25以后","uri":"/posts/25%E4%BB%A5%E5%90%8E/"},{"categories":["http"],"content":"Createitv","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP协议 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:0:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"1.HTTP协议基本认识 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:1:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP历史 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:1:1","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"TCP/IP协议簇 TCP/IP协议簇是一个****四层协议系统****，自顶向下分别是：应用层 传输层 网路层 数据链路层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:1:2","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"TCP三次握手 为了确定连接的可靠性，tcp协议采用了三次握手策略，确保发送端和客户端都在正常工作。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:1:3","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"2.HTTP特点 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP特点 数据类型灵活 HTTP允许传输任意类型的数据对象，正在传输的内容由Content-Type加以标记。 无状态连接 每次连接只处理一个连接，处理完客户请求即断开连接，每次的请求都是新的一次请求。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:1","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP请求报文 HTTP的报文头大体可以分为四类，分别是通用报文头、请求报文头、响应报文头和实体报文头 Connection：keep-alve当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问。这个服务器上的网页，会继续使用这一条已经建立的连接。 Connection： close代表个 Reques垸完成后，客户端和服务器之间用于传输HTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接 Content-Type◆作用：说明了报文体内对象的媒体类型 text/hmtl：HTML格式 text/plain：纯文本格式 text/xml：XML格式 Image/gif：gi图片格式 Image/jpeg：jpg图片格式 Image/png：png图片格式 application/ Xhtml+xml： XHTML格式 application/xml：ⅩML数据格式 application/atom+xml： Atom XML聚合格式 application/json：JSoN数据格式 application/pdf pdf格式 application/msword：word文档格式 application/octet-stream：二进制流数据（如常见的文件下载） application/WWW-form-urlencoded：表单提交 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:2","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP响应报文 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:3","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP请求方法 HTTP/1.1常用方法 ①GET ②POST ③PUT ④HEAD ⑤ DELETE ⑥OPTIONS ⑦ TRACE ⑧ CONNECT OPTIONS用来査询针对请求∪R指定的资源支持的方法 TRACE回显服务器收到的请求，主要用于测试或诊断 CONNECT开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:4","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP请求状态码 常见的 HTTP 状态码： 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:5","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP无状态解决方案：Cookies和Session HTTP 协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。 Cookie的工作原理 （1）浏览器端第一次发送请求到服务器端 （2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端 （3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie （4）服务器端通过Cookie中携带的数据区分不同的用户 Session的工作原理 （1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端 （2）浏览器端发送第N（N\u003e1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象 （3）服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。 name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookie name为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象 value为SessionId不存在**（Session对象默认存活30分钟）**，返回1中重新去创建Session与特殊的Cookie value为SessionId存在，返回session对象 区别： cookie数据保存在客户端，session数据保存在服务端。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:2:6","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"3.通信协议结构和通信原理 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"字符集和编码 在HTTP中，与字符集和字符编码相关的信息头是Accept-Charset/Content-Type，另外主要区分Accept-Charset、Accept-Encoding、Accept-Language、Content-Type、Content-Encoding、Content-Language ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:1","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"基础身份认证 BASIC认证（基本认证） DIGEST认证虽然采用的是Base64编码方式，但是不是采用的加密处理，不需任何附加信息便可对Base64进行解码，达不到多数Web网站希望的安全性等级。 DIGEST认证 质询/响应的方式：值一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码，最后将响应码返回给对方进行认证的一种方式 SSL客户端认证 SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证服务器可确认访问是否来自已登录的客户端 高度的安全等级，费用较高。 FormBase认证 Web应用表单提交认证最常见，有许多的安全问题。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:2","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"长连接与短连接 HTTP的长连接和短连接本质上是TCP长连接和短连接。 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:3","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP代理 Fiddler代理，Express代理。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:4","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP网关 网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。网关扮演的是“协议转换器”的角色。 网关可以向数据库发送查询数据，发邮件，生成动态内容，像一个门一样，进入一个请求，出来一个响应。最常见的网关，应用程序服务器，会将目标服务器与网关结合在一个服务器中实现。 应用程序服务器是服务器端网关，与客户端通过HTTP进行通信，并与服务器端的应用程序相连。客户端是通过HTTP连接到应用程序服务器的。但应用程序服务器并没有回送文件，而是将请求通过一个网关应用编程接口(Application Programming Interface，API)发送给运行在服务器上的应用程序。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:5","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP缓存 http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。常见的http缓存只能缓存get请求响应的资源。 HTTP缓存机制是根据HTTP报文的缓存标识进行的。HTTP缓存分为强缓存和协商缓存。优先级最高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。 强缓存 强缓存是利用http头中的Expires和Cache-Control两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的Expires和Cache-Control判断目标资源是否“命中”强缓存，如果命中则直接从缓存中获取资源，不会再与服务端发生通信。命中强缓存的情况下，返回的HTTP状态码为200。 Cache-Control包含的值很多： public：表明响应可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。 private：表明响应只能被客户端缓存。 no-cache：跳过强缓存，直接进入协商缓存阶段。 no-store：表示当前请求资源禁用缓存 max-age=：设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒） s-maxage=：覆盖max-age或者Expires头。如果s-maxage未过期，则向代理服务器请求其缓存内容 协商缓存 协商缓存，也称为对比缓存。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。控制协商缓存的字段分别有：Last-Modified和Etag，其中Etag的优先级比Last-Modified高 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:6","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP断点续传 也就是要从文件已经下载的地方开始继续下载。在以前版本的 HTTP 协议是不支持断点的，HTTP/1.1 开始就支持了。一般断点下载时才用到 Range 和 Content-Range 实体头。 Range 用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式： Range:(unit=first byte pos)-[last byte pos] Content-Range 用于响应头，指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： Content-Range: bytes (unit first byte pos) - last byte pos/entity legth ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:3:7","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"3.HTTPS HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL 服务器为每个客户端生成一个公钥，将公钥发送给客户端 客户端选择一个加密算法，然后用公钥加密以后发送给服务器 服务器收到这个公钥加密后的算法以后拿自己的私钥解密，然后就知道这个加密算法是哪个了。今后就一直用这个算法通信。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:4:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"CA证书 可以自己制作证书，然后把这个证书的公钥放在客户端（例如app的安装目录下），这样app只要使用自己的证书公钥即可 解密了，不需要使用系统的。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:4:1","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTPS常见问题 费用 连接耗时 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:4:2","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"4.HTTP改良协议 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:5:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"WebSocket协议 WebSocket建立在HTTP基础上，发起方还是客户端，但是在建立连接后，客户端和服务器都可直接向对方发送报文。 为了实现WebSocket通信，在HTTP建立连接后，需要完成一次“握手”的步骤，需要用到HTTP的Upgrade首部字段，以达到握手的目的。 成功握手确定WebSocket连接后，通信时不再使用HTTP数据帧，采用WebSocket独立的数据帧。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:5:1","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"HTTP2.0 HTTP2.0在2014-11实现标准化。目标是改善用户在使用Web中的速度体验。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:5:2","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["http"],"content":"5.HTTP题目 访问www.baidu.com之后发生了什么 (1) 浏览器获取输入的域名www.baidu.com (2) 浏览器向DNS请求解析www.baidu.com的IP地址 (3) 域名系统DNS解析出百度服务器的IP地址 (4) 浏览器与该服务器建立TCP连接(默认端口号80) (5) 浏览器发出HTTP请求，请求百度首页 (6) 服务器通过HTTP响应把首页文件发送给浏览器 (7) TCP连接释放 (8) 浏览器将首页文件进行解析，并将Web页显示给用户。 ","date":"2022-02-05","objectID":"/posts/http%E5%8D%8F%E8%AE%AE/:6:0","tags":[],"title":"Http协议","uri":"/posts/http%E5%8D%8F%E8%AE%AE/"},{"categories":["golang"],"content":"Createitv","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"Gin项目中的日志库管理 本文先介绍了Go语言原生的日志库的使用，然后详细介绍了非常流行的Uber开源的zap日志库，同时介绍了如何搭配Lumberjack实现日志的切割和归档 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:0:0","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"介绍 在许多Go语言项目中，我们需要一个好的日志记录器能够提供下面这些功能： 能够将事件记录到文件中，而不是应用程序控制台。 日志切割-能够根据文件大小、时间或间隔等来切割日志文件。 支持不同的日志级别。例如INFO，DEBUG，ERROR等。 能够打印基本信息，如调用文件/函数名和行号，日志时间等。 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:1:0","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"1.Go原生的日志管理 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:2:0","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"实现Go Logger 实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。 设置Logger 我们可以像下面的代码一样设置日志记录器 func SetupLogger() { logFileLocation, _ := os.OpenFile(\"/Users/q1mi/test.log\", =os.O_CREATE|os.O_APPEND|os.O_RDWR, 0744) log.SetOutput(logFileLocation) } 使用Logger 让我们来写一些虚拟的代码来使用这个日志记录器。 在当前的示例中，我们将建立一个到URL的HTTP连接，并将状态代码/错误记录到日志文件中。 func simpleHttpGet(url string) { resp, err := http.Get(url) if err != nil { log.Printf(\"Error fetching url %s : %s\", url, err.Error()) } else { log.Printf(\"Status Code for %s : %s\", url, resp.Status) resp.Body.Close() } } Logger的运行 现在让我们执行上面的代码并查看日志记录器的运行情况。 func main() { SetupLogger() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } 当我们执行上面的代码，我们能看到一个test.log文件被创建，下面的内容会被添加到这个日志文件中。 2019/05/24 01:14:13 Error fetching url www.google.com : Get www.google.com: unsupported protocol scheme \"\" 2019/05/24 01:14:14 Status Code for http://www.google.com : 200 OK ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:2:1","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"Go Logger的优势和劣势 优势 它最大的优点是使用非常简单。我们可以设置任何io.Writer作为日志记录输出并向其发送要写入的日志。 劣势 仅限基本的日志级别 只有一个Print选项。不支持INFO/DEBUG等多个级别。 对于错误日志，它有Fatal和Panic Fatal日志通过调用os.Exit(1)来结束程序 Panic日志在写入日志消息之后抛出一个panic 但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误 缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。 不提供日志切割的能力。 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:2:2","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"2.Zap使用 Zap是非常快的、结构化的，分日志级别的Go日志库。 它同时提供了结构化日志记录和printf风格的日志记录 它非常的快 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:0","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"安装 运行下面的命令安装zap go get -u go.uber.org/zap ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:1","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"配置Zap Logger Zap提供了两种类型的日志记录器—Sugared Logger和Logger。 在性能很好但不是很关键的上下文中，使用SugaredLogger。它比其他结构化日志记录包快4-10倍，并且支持结构化和printf风格的日志记录。 在每一微秒和每一次内存分配都很重要的上下文中，使用Logger。它甚至比SugaredLogger更快，内存分配次数也更少，但它只支持强类型的结构化日志记录。 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:2","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"创建实例 通过调用zap.NewProduction()/zap.NewDevelopment()或者zap.Example()创建一个Logger。这三个方法的区别在于它将记录的信息不同，参数只能是string类型 //代码 var log *zap.Logger log = zap.NewExample() log, _ := zap.NewDevelopment() log, _ := zap.NewProduction() log.Debug(\"This is a DEBUG message\") log.Info(\"This is an INFO message\") //Example 输出 {\"level\":\"debug\",\"msg\":\"This is a DEBUG message\"} {\"level\":\"info\",\"msg\":\"This is an INFO message\"} //Development 输出 2022-01-23T17:14:22.459+0800 DEBUG development/main.go:7 This is a DEBUG message 2022-01-23T17:14:22.459+0800 INFO development/main.go:8 This is an INFO message //Production 输出 {\"level\":\"info\",\"ts\":1540891173.3190675,\"caller\":\"production/main.go:8\",\"msg\":\"This is an INFO message\"} {\"level\":\"info\",\"ts\":1540891173.3191047,\"caller\":\"production/main.go:9\",\"msg\":\"This i 三种创建方式对比： Example和Production使用的是json格式输出，Development使用行的形式输出 Development 从警告级别向上打印到堆栈中来跟踪 始终打印包/文件/行（方法） 在行尾添加任何额外字段作为json字符串 以大写形式打印级别名称 以毫秒为单位打印ISO8601格式的时间戳 Production 调试级别消息不记录 Error,Dpanic级别的记录，会在堆栈中跟踪文件，Warn不会 始终将调用者添加到文件中 以时间戳格式打印日期 以小写形式打印级别名称 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:3","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"同时输出控制台和文件 如果需要同时输出控制台和文件，只需要改造一下zapcore.NewCore即可，示例： package main import ( \"github.com/natefinch/lumberjack\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" \"os\" ) var log *zap.Logger func main() { //获取编码器,NewJSONEncoder()输出json格式，NewConsoleEncoder()输出普通文本格式 encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder //指定时间格式 encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder encoder := zapcore.NewConsoleEncoder(encoderConfig) //文件writeSyncer fileWriteSyncer := zapcore.AddSync(\u0026lumberjack.Logger{ Filename: \"./info.log\", //日志文件存放目录 MaxSize: 1, //文件大小限制,单位MB MaxBackups: 5, //最大保留日志文件数量 MaxAge: 30, //日志文件保留天数 Compress: false, //是否压缩处理 }) fileCore := zapcore.NewCore(encoder, zapcore.NewMultiWriteSyncer(fileWriteSyncer,zapcore.AddSync(os.Stdout)), zapcore.DebugLevel) //第三个及之后的参数为写入文件的日志级别,ErrorLevel模式只记录error级别的日志 log = zap.New(fileCore, zap.AddCaller()) //AddCaller()为显示文件名和行号 log.Info(\"hello world\") log.Error(\"hello world\") } ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:4","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"文件切割 日志文件会随时间越来越大，为了避免日志文件把硬盘空间占满，需要按条件对日志文件进行切割，zap包本身不提供文件切割的功能，但是可以用zap官方推荐的lumberjack包处理 //文件writeSyncer fileWriteSyncer := zapcore.AddSync(\u0026lumberjack.Logger{ Filename: \"./info.log\", //日志文件存放目录，如果文件夹不存在会自动创建 MaxSize: 1, //文件大小限制,单位MB MaxBackups: 5, //最大保留日志文件数量 MaxAge: 30, //日志文件保留天数 Compress: false, //是否压缩处理 }) ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:5","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"按级别写入文件 为了管理人员的查询方便，一般我们需要将低于error级别的放到info.log，error及以上严重级别日志存放到error.log文件中，我们只需要改造一下zapcore.NewCore方法的第3个参数，然后将文件WriteSyncer拆成info和error两个即可，示例： package main import ( \"github.com/natefinch/lumberjack\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" \"os\" ) var log *zap.Logger func main() { var coreArr []zapcore.Core //获取编码器 encoderConfig := zap.NewProductionEncoderConfig() //NewJSONEncoder()输出json格式，NewConsoleEncoder()输出普通文本格式 encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder //指定时间格式 encoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder //按级别显示不同颜色，不需要的话取值zapcore.CapitalLevelEncoder就可以了 //encoderConfig.EncodeCaller = zapcore.FullCallerEncoder //显示完整文件路径 encoder := zapcore.NewConsoleEncoder(encoderConfig) //日志级别 highPriority := zap.LevelEnablerFunc(func(lev zapcore.Level) bool{ //error级别 return lev \u003e= zap.ErrorLevel }) lowPriority := zap.LevelEnablerFunc(func(lev zapcore.Level) bool { //info和debug级别,debug级别是最低的 return lev \u003c zap.ErrorLevel \u0026\u0026 lev \u003e= zap.DebugLevel }) //info文件writeSyncer infoFileWriteSyncer := zapcore.AddSync(\u0026lumberjack.Logger{ Filename: \"./log/info.log\", //日志文件存放目录，如果文件夹不存在会自动创建 MaxSize: 1, //文件大小限制,单位MB MaxBackups: 5, //最大保留日志文件数量 MaxAge: 30, //日志文件保留天数 Compress: false, //是否压缩处理 }) infoFileCore := zapcore.NewCore(encoder, zapcore.NewMultiWriteSyncer(infoFileWriteSyncer,zapcore.AddSync(os.Stdout)), lowPriority) //第三个及之后的参数为写入文件的日志级别,ErrorLevel模式只记录error级别的日志 //error文件writeSyncer errorFileWriteSyncer := zapcore.AddSync(\u0026lumberjack.Logger{ Filename: \"./log/error.log\", //日志文件存放目录 MaxSize: 1, //文件大小限制,单位MB MaxBackups: 5, //最大保留日志文件数量 MaxAge: 30, //日志文件保留天数 Compress: false, //是否压缩处理 }) errorFileCore := zapcore.NewCore(encoder, zapcore.NewMultiWriteSyncer(errorFileWriteSyncer,zapcore.AddSync(os.Stdout)), highPriority) //第三个及之后的参数为写入文件的日志级别,ErrorLevel模式只记录error级别的日志 coreArr = append(coreArr, infoFileCore) coreArr = append(coreArr, errorFileCore) log = zap.New(zapcore.NewTee(coreArr...), zap.AddCaller()) //zap.AddCaller()为显示文件名和行号，可省略 log.Info(\"hello info\") log.Debug(\"hello debug\") log.Error(\"hello error\") } 这样修改之后，info和debug级别的日志就存放到info.log，error级别的日志单独放到error.log文件中了 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:6","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"自定义输出格式 encoderConfig.EncodeTime = zapcore.TimeEncoderOfLayout(\"2006-01-02 15:04:05\") // 自定义指定时间格式 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:7","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"3.Gin中Zap中间件封装 func ZapLogger() gin.HandlerFunc { logger := config.InitLogger() return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() cost := time.Since(start) // *zap.Logger配置 // logger.Info(path, // zap.Int(\"status\", c.Writer.Status()), // zap.String(\"method\", c.Request.Method), // zap.String(\"path\", path), // zap.String(\"query\", query), // zap.String(\"ip\", c.ClientIP()), // zap.String(\"user-agent\", c.Request.UserAgent()), // zap.String(\"errors\", c.Errors.ByType(gin.ErrorTypePrivate).String()), // zap.Duration(\"cost\", cost), // ) logger.Infof(\"url %s statusCode: %d method: %s query: %s ip: %s user-agent: %s\"+ \" errors: %s cost %s\", path, c.Writer.Status(), c.Request.Method, query, c.ClientIP(), c.Request.UserAgent(), c.Errors.ByType(gin.ErrorTypePrivate).String(), cost) } } 结果,此外还可以定制更多的请求消息 2022-01-23 22:11:02 INFO middleware/logger.go:28 url /vps/health statusCode: 200 method: GET query: ip: 127.0.0.1 user-agent: PostmanRuntime/7.28.0 errors: cost 0s 2022-01-23 22:11:11 INFO middleware/logger.go:28 url /vps/health statusCode: 200 method: GET query: ip: 127.0.0.1 user-agent: PostmanRuntime/7.28.0 errors: cost 0s 2022-01-23 22:11:11 INFO middleware/logger.go:28 url /vps/ram statusCode: 200 method: GET query: ip: 127.0.0.1 user-agent: PostmanRuntime/7.28.0 errors: cost 0s 2022-01-23 22:11:11 INFO middleware/logger.go:28 url /vps/cpu statusCode: 200 method: GET query: ip: 127.0.0.1 user-agent: PostmanRuntime/7.28.0 errors: cost 45.5196ms 2022-01-23 22:11:11 INFO middleware/logger.go:28 url /vps/ram statusCode: 200 method: GET query: ip: 127.0.0.1 user-agent: PostmanRuntime/7.28.0 errors: cost 495.4µs ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:4:0","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["golang"],"content":"参考 https://www.liwenzhou.com/posts/Go/zap/ https://learnku.com/articles/62253 https://www.jianshu.com/p/910b626f67d9 ","date":"2022-01-23","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:5:0","tags":[],"title":"Zap日志库","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["数据结构与算法"],"content":"Createitv","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"问题描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 \u003c= n \u003c= 1000 0 \u003c= m \u003c= 1000 ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:1:0","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"解决思路 二维数组一遍遍历，然后二分搜索，复杂度$O(nlogn)$ 站在右上角看。这个矩阵其实就像是一个Binary Search Tree。从右上角开始比较，比它大就往下数一行，比它小就往左数一列。复杂度$O(m+n)$ ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:2:0","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"解决代码 ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:3:0","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"Javascript版本 var findNumberIn2DArray = function (matrix, target) { for (let i of matrix) { console.log(i) if (BinarySearch(i, target) === -1) { continue } else { return true } } return false } function BinarySearch(arr, target) { if (arr.length \u003c 1) return -1 else if (arr.length === 1) { if (arr[0] === target) return true else return -1 } // 低位下标 let lowIndex = 0 // 高位下标 let highIndex = arr.length - 1 while (lowIndex \u003c= highIndex) { // 中间下标 const midIndex = Math.floor((lowIndex + highIndex) / 2) if (target \u003c arr[midIndex]) { highIndex = midIndex - 1 } else if (target \u003e arr[midIndex]) { lowIndex = midIndex + 1 } else { // target === arr[midIndex] return midIndex } } return -1 } const arr = [[-5]] console.log(findNumberIn2DArray(arr, -2)) // 2. 站在右上角看。这个矩阵其实就像是一个Binary Search Tree。从右上角开始比较，比它大就往下数一行，比它小就往左数一列。 /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var findNumberIn2DArray = function (matrix, target) { if (matrix.length === 0 || matrix[0].length \u003c 1) return false let i = 0 let j = matrix[0].length - 1 while (i \u003c matrix.length \u0026\u0026 j \u003e= 0) { if (target === matrix[i][j]) { return true } else if (target \u003c matrix[i][j]) { j-- } else { i++ } } return false } ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:3:1","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"python3版本 class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -\u003e bool: i, j = len(matrix) - 1, 0 while i \u003e= 0 and j \u003c len(matrix[0]): if matrix[i][j] \u003e target: i -= 1 elif matrix[i][j] \u003c target: j += 1 else: return True return False ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:3:2","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"golang版本 func findNumberIn2DArray(matrix [][]int, target int) bool { row := len(matrix) if row == 0 { return false } for i, j := 0, len(matrix[0])-1; i \u003c row \u0026\u0026 j \u003e= 0; { if matrix[i][j] == target { return true } else if matrix[i][j] \u003e target { j-- } else { i++ } } return false } ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:3:3","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"提交执行结果 ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:3:4","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"一点想法 好的数据结构配好的算法，如何能把这样一个二维数组抽象成一棵二叉搜索树这个过程还需要时间。 ","date":"2022-01-17","objectID":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:3:5","tags":["剑指Offer"],"title":"剑指Offer04.二维数组中的查找","uri":"/posts/%E5%89%91%E6%8C%87offer04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["数据结构与算法"],"content":"Createitv","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"问题描述 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字(不是第一个)。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 \u003c= n \u003c= 100000 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:1:0","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"解决思路 遍历字典排序，每多一次值+1 集合去重，记录数组的各个数字，当查找到重复数字则直接返回 先对列表排序，排完以后重复元素必定相邻，故只需判断相邻元素是否相等即可 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:2:0","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"解决过程 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:3:0","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"坑一： for in 循环只遍历属性不遍历值。for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of for (const [key, value] in Object.entries(j)) 尽管对于处理存储数据，数组更实用些，但是你在处理有key-value数据（比如属性用作“键”），需要检查其中的任何键是否为某值的情况时，还是推荐用for ... in。 for ... in代码举例 var obj = {a:1, b:2, c:3}; for (var prop in obj) { console.log(\"obj.\" + prop + \" = \" + obj[prop]); } // Output: // \"obj.a = 1\" // \"obj.b = 2\" // \"obj.c = 3\" for ... of 代码举例 const array1 = ['a', 'b', 'c']; 如果你不想修改语句块中的变量 , 也可以使用const代替let。 for (const element of array1) { console.log(element); } // expected output: \"a\" // expected output: \"b\" // expected output: \"c\" var findRepeatNumber = function (nums) { let j = {} for (let i of nums) { if (!(i + '' in j)) { j[i] = 1 continue } j[i] += 1 } console.log(Object.entries(j)); for (const [key, value] of Object.entries(j)) { if (value \u003e 1) { return key } } }; console.log(findRepeatNumber([5, 2, 23, 5, 3, 1, 0, 2, 5, 3])); ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:3:1","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"坑二 Object.entries(j)如果key是字符串遍历后的顺序会按照key大小排序。 var findRepeatNumber = function (nums) { let j = {} for (let i of nums) { if (!(i + '' in j)) { j[i] = 1 continue } j[i] += 1 } console.log(Object.entries(j)); for (const [key, value] of Object.entries(j)) { if (value \u003e 1) { return key } } }; console.log(findRepeatNumber([100, 12312, 5, 2, 23, 5, 3, 1, 0, 2, 5, 3])); [ [ '0', 1 ], [ '1', 1 ], [ '2', 2 ], [ '3', 2 ], [ '5', 3 ], [ '23', 1 ], [ '100', 1 ], [ '12312', 1 ] ] 如果key是字母不会排序 const obj = { d: 5, b: 7, c: 9 }; for (const [key, value] of Object.entries(obj)) { console.log(`${key}${value}`); // \"d 5\", \"b 7\", \"c 9\" } ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:3:2","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"解决代码 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:4:0","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"Javascript版本 执行用104ms，在所有提交中击败了21.83%的用户 内存消耗：52.6MB，在所有提交中击败了4.99%的用户 // 哈希表版本一 存储所有数组中的元素，再循环判断字典的值是否多余一个 var findRepeatNumber = function (nums) { let j = {} for (let i of nums) { if (!(i + '' in j)) { j[i] = 1 continue } j[i] += 1 } for (let i of nums) { if (j[i] \u003e 1) { return i } } }; 执行用时：88ms，在所有 JavaScript提交中击败了41.88%的用户 内存消耗：44.2MB，在所有 JavaScript提交中击败了6770%的用户 //哈希表版本二 不用存储所有数组中的元素，第一次判断字典中有没有此元素，无赋值true，有直接返回 var findRepeatNumber = function(nums) { let obj = {} let cur for(let i = 0; i \u003c nums.length; i++){ cur = nums[i] if(obj[cur] == true){ return cur }else{ obj[cur] = true } } } //集合版本 var findRepeatNumber = function(nums) { let map = new Map(); for(let i of nums){ if(map.has(i)) return i; map.set(i, 1); } return null; }; ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:4:1","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"python3版本 执行用时：44ms，在所有提交中击败了58.04%的用户 内存消耗：23.5MB，在所有提交中击败了53.09%的用户 class Solution: def findRepeatNumber(self, nums: [int]) -\u003e int: dic = set() for num in nums: if num in dic: return num dic.add(num) return -1 同样的解体思路，python3运行时间更短，内存消耗更少 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:4:2","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"golang版本 执行用时：32ms，在所有Go提交中击败了88.77%的用户 内存消耗：8MB，在所有Go提交中击败了47.74%的用户 package main import \"fmt\" func findRepeatNumber(nums []int) int { m := make(map[int]bool) for _, i := range nums { if _, ok := m[i]; ok { return i } else { m[i] = true } } return -1 } func main() { // map测试代码 m := map[string]int{ \"a\": 1, \"b\": 2, \"c\": 3, } fmt.Println(\"Geting values\") courseName, ok := m[\"d\"] //ok为false fmt.Println(courseName, ok) courseName, ok = m[\"a\"] fmt.Println(courseName, ok) if courseName, ok = m[\"d\"]; ok { fmt.Println(courseName) } else { fmt.Println(\"key does not exist\") } // map测试代码 fmt.Println(findRepeatNumber([]int{2, 3, 1, 0, 2, 5, 3})) } 同样的解题办法，不得不吹golang一波。执行之时间最少，内存消耗也最少，代码看起来也易懂。 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:4:3","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["数据结构与算法"],"content":"其他想法 这是第二遍刷剑指offer，第一遍的感觉和第二遍完全不同，第一遍只用了python3.API调用方便，只为囫囵吞枣的解决问题，基本上刷完了忘了。第二遍的刷题思路就完全不一样，第二遍着重看见运行效率。也就是leetcode判定的两个指标，运行时间和内存消耗。同样的问题，不同的解决问题的思路。效率千差万别，同样的问题，不同的编程语言来解决，虽然仅仅是API调用不同，但是运行效率却差很多。最后用高级语言的鼻祖C语言试试。仅仅对这一个特定问题基本上和Go没太大区别 执行用时：32ms，在所有C提交中击败了72.84%的用户 内存消耗：11.9MB，在所有C提交中击败了7.82%的用户 int findRepeatNumber(int* nums, int numsSize) { int res = 0; int* hashTable = (int*)calloc(100000, sizeof(int)); for (int i = 0; i \u003c numsSize; i++) { if (hashTable[nums[i]] == 0) { hashTable[nums[i]]++; } else { res = nums[i]; break; } } return res; } 知道为什么刷题很重要，刷题的思路，刷题的想法很重要，如果仅仅为了面试过了关，必定体会不到算法与程序设计的精髓。刷题的过程确实让我更加熟悉一些API，对于语言的合适常景的选择也有了一定的判断。 ","date":"2022-01-15","objectID":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:4:4","tags":["剑指offer"],"title":"剑指offer 03数组中重复的数字","uri":"/posts/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["码匠"],"content":"Createitv","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":" 道生一、一生二、二生三、三生万物 何为一：变量 The most obvious benefit to GoodVariableNames can reduce the need for extensive comments, producing SelfDocumentingCode. When reading code peppered with well thought out variable names it’s like reading poetry or music. 好的命名能够让代码概念更加清晰，增加代码的表达力。 命名为什么难呢？因为命名的过程本身就是一个抽象和思考的过程，在工作中，当我们不能给一个模块、一个对象、一个函数，甚至一个变量找到合适的名称的时候，往往说明我们对问题的理解还不够透彻，需要重新去挖掘问题的本质，对问题域进行重新分析和抽象，有时还要调整设计和重构代码。因此，好的命名是我们写出好代码的基础。 像Stack Overflow的创始人Joel Spolsky所说的：“起一个好名字应该很难，因为一个好名字需要把要义浓缩在一到两个词中。（Creating good names is hard, but it should be hard, because a great name captures essential meaning in just one or two words.）” 此外，Martin Fowler也表示过，他最喜欢的一句谚语是：“在计算机科学中有两件难事：缓存失效和命名。（There are only two hard things in Computer Science: cache invalidation and naming things.）” ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:0:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"什么是有意义的变量命名 代码即文档，可读性好的代码应该有一定的自明性，也就是不借助注释和文档，代码本身就能显性化地表达开发者的意图。这种自明性在很大程度上依赖于我们对问题域的理解，以及命名是否合理。 通常，如果你无法想出一个合适的名字，很可能意味着代码“坏味道”、设计有问题。这时可以思考一下：是不是一个方法里实现了太多的功能？或者类的封装内聚性不够？又或者是你对问题的理解还不够透彻，需要获取更多的信息？ 什么是好的变量名 变量名应该是名词，能够正确地描述业务，有表达力。 // None of these names provide useful information int d; String n; boolean sg; // These names clearly state what they represent int distanceInLightYears; String starName; boolean isSupergiant; Embed meaningful domain knowledge into the name. It must be clear what entity from the domain a variable represents. A name like bitFlag is not as meaningful as isUserLoggedIn or isEngineReady. Whenever possible, favor names that have clear relations with your problem’s domain. Use your software knowledge. Factory and List are words with a special meaning for software developers. Words for programming concepts let you express complex ideas in a few words that are easily understandable by fellow programmers. In fact, programming lingo offers you heaps of information compression for free, so feel free to use it. 命名原则 遵守各编程语言的代码规范 问题导向命名 保持一致性 不要出现特殊的字符 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:1:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"变量命名 变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法） 变量名应该是名词，能正确的表达描述业务，有表达力。如果一个变量必须用注释来加以解释说明，说明变量的表达能力还不够。 int d;//表示过去的天数 int elapsedTimeInDays; int seconds;//一天多少秒 int secondsPerDay; 通常约定，**类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。**首字母大写的 UpperCamelCase，首字母小写的 lowerCamelCase 以及全部大写的并用下划线分割单词的 UPPER_CAMEL_UNSER_SCORE。 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"1 返回真伪值的方法 注：Prefix-前缀，Suffix-后缀，Alone-单独使用 位置 单词 意义 例 Prefix is 对象是否符合期待的状态 isValid Prefix can 对象能否执行所期待的动作 canRemove Prefix should 调用方执行某个命令或方法是好还是不好,应不应该，或者说推荐还是不推荐 shouldMigrate Prefix has 对象是否持有所期待的数据和属性 hasObservers Prefix needs 调用方是否需要执行某个命令或方法 needsMigrate ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:1","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"2 用来检查的方法 单词 意义 例 ensure 检查是否为期待的状态，不是则抛出异常或返回 error code ensureCapacity validate 检查是否为正确的状态，不是则抛出异常或返回 error code validateInputs ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:2","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"3 按需求才执行的方法 位置 单词 意义 例 Suffix IfNeeded 需要的时候执行，不需要的时候什么都不做 drawIfNeeded Prefix might 同上 mightCreate Prefix try 尝试执行，失败时抛出异常或是返回 errorcode tryCreate Suffix OrDefault 尝试执行，失败时返回默认值 getOrDefault Suffix OrElse 尝试执行、失败时返回实际参数中指定的值 getOrElse Prefix force 强制尝试执行。error 抛出异常或是返回值 forceCreate, forceStop ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:3","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"4 异步相关方法 位置 单词 意义 例 Prefix blocking 线程阻塞方法 blockingGetUser Suffix InBackground 执行在后台的线程 doInBackground Suffix Async 异步方法 sendAsync Suffix Sync 对应已有异步方法的同步方法 sendSync Prefix or Alone schedule Job 和 Task 放入队列 schedule, scheduleJob Prefix or Alone post 同上 postJob Prefix or Alone execute 执行异步方法（注：我一般拿这个做同步方法名） execute, executeTask Prefix or Alone start 同上 start, startJob Prefix or Alone cancel 停止异步方法 cancel, cancelJob Prefix or Alone stop 同上 stop, stopJob ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:4","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"5 回调方法 位置 单词 意义 例 Prefix on 事件发生时执行 onCompleted Prefix before 事件发生前执行 beforeUpdate Prefix pre 同上 preUpdate Prefix will 同上 willUpdate Prefix after 事件发生后执行 afterUpdate Prefix post 同上 postUpdate Prefix did 同上 didUpdate Prefix should 确认事件是否可以发生时执行 shouldUpdate ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:5","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"6 操作对象生命周期的方法 单词 意义 例 initialize 初始化。也可作为延迟初始化使用 initialize pause 暂停 onPause ，pause stop 停止 onStop，stop abandon 销毁的替代 abandon destroy 同上 destroy dispose 同上 dispose ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:6","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"7 与集合操作相关的方法 单词 意义 例 contains 是否持有与指定对象相同的对象 contains add 添加 addJob append 添加 appendJob insert 插入到下标 n insertJob put 添加与 key 对应的元素 putJob remove 移除元素 removeJob enqueue 添加到队列的最末位 enqueueJob dequeue 从队列中头部取出并移除 dequeueJob push 添加到栈头 pushJob pop 从栈头取出并移除 popJob peek 从栈头取出但不移除 peekJob find 寻找符合条件的某物 findById ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:7","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"8 与数据相关的方法 单词 意义 例 create 新创建 createAccount new 新创建 newAccount from 从既有的某物新建，或是从其他的数据新建 fromConfig to 转换 toString update 更新既有某物 updateAccount load 读取 loadAccount fetch 远程读取 fetchAccount delete 删除 deleteAccount remove 删除 removeAccount save 保存 saveAccount store 保存 storeAccount commit 保存 commitChange apply 保存或应用 applyChange clear 清除数据或是恢复到初始状态 clearAll reset 清除数据或是恢复到初始状态 resetAll ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:8","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"9 成对出现的动词 单词 意义 get 获取 set 设置 add 增加 remove 删除 create 创建 destory 移除 start 启动 stop 停止 open 打开 close 关闭 read 读取 write 写入 load 载入 save 保存 create 创建 destroy 销毁 begin 开始 end 结束 backup 备份 restore 恢复 import 导入 export 导出 split 分割 merge 合并 inject 注入 extract 提取 attach 附着 detach 脱离 bind 绑定 separate 分离 view 查看 browse 浏览 edit 编辑 modify 修改 select 选取 mark 标记 copy 复制 paste 粘贴 undo 撤销 redo 重做 insert 插入 delete 移除 add 加入 append 添加 clean 清理 clear 清除 index 索引 sort 排序 find 查找 search 搜索 increase 增加 decrease 减少 play 播放 pause 暂停 launch 启动 run 运行 compile 编译 execute 执行 debug 调试 trace 跟踪 observe 观察 listen 监听 build 构建 publish 发布 input 输入 output 输出 encode 编码 decode 解码 encrypt 加密 decrypt 解密 compress 压缩 decompress 解压缩 pack 打包 unpack 解包 parse 解析 emit 生成 connect 连接 disconnect 断开 send 发送 receive 接收 download 下载 upload 上传 refresh 刷新 synchronize 同步 update 更新 revert 复原 lock 锁定 unlock 解锁 check out 签出 check in 签入 submit 提交 commit 交付 push 推 pull 拉 expand 展开 collapse 折叠 begin 起始 end 结束 start 开始 finish 完成 enter 进入 exit 退出 abort 放弃 quit 离开 obsolete 废弃 depreciate 废旧 collect 收集 aggregate 聚集 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:2:9","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"函数命名 函数作为最小的逻辑单元，根据单一职责原则函数的名字要具体。不要过于泛化,函数要体现做什么而不是怎么做，怎么做是函数体的内容。 processUserInfo(); //bad ValidateUserTel(); //Good 函数命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:3:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"类命名 类是面向对象中重要的概念之一，是对一组数据和操作的封装。 类名使用大驼峰命名形式，类命通常时名词或名词短语，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以 Test 结尾，如 HashMapTest。 对于一些特殊特有名词缩写也可以使用全大写命名，比如 XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中 fastjson 用 JSONObject 作为类命，而 google 则使用 JsonObjectRequest 命名，对于这种特殊的缩写，原则是统一就好。 属性 约束 例 抽象类 Abstract 或者 Base 开头 BaseUserService 枚举类 Enum 作为后缀 GenderEnum 工具类 Utils 作为后缀 StringUtils 异常类 Exception 结尾 RuntimeException 接口实现类 接口名+ Impl UserServiceImpl 领域模型相关 /DO/DTO/VO/DAO 正例：UserDAO 反例：UserDo， UserDao 设计模式相关类 Builder，Factory 等 当使用到设计模式时，需要使用对应的设计模式作为后缀，如 ThreadFactory 处理特定功能的 Handler，Predicate, Validator 表示处理器，校验器，断言，这些类工厂还有配套的方法名如 handle，predicate，validate 测试类 Test 结尾 UserServiceTest， 表示用来测试 UserService 类的 MVC 分层 Controller，Service，ServiceImpl，DAO 后缀 UserManageController，UserManageDAO ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:4:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"包命名 包代表了一组有关系的类的集合，起到分类组合和命名空间的作用。包名需要反应一组类在更高层次的抽象上的练习。 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。 包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种： 前缀名 例 含义 indi（或 onem ） indi.发起者名.项目名.模块名.…… 个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright 主要属于发起者。 pers pers.个人名.项目名.模块名.…… 个人项目，指个人发起，独自完成，可分享的项目，copyright 主要属于个人 priv priv.个人名.项目名.模块名.…… 私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright 属于个人。 team team.团队名.项目名.模块名.…… 团队项目，指由团队发起，并由该团队开发的项目，copyright 属于该团队所有 顶级域名 com.公司名.项目名.模块名.…… 公司项目，copyright 由项目发起的公司所有 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:5:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"模块命名 相当于来说，模块的信息颗粒度更大通常一个模块包含了多个包，模块名应该表达架构的层次。 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:6:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"注解 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:7:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"注解的原则 好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。 Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。 Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。 // 根据id获取信息【废话注解】 getMessageById(id) Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:7:1","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"包注解 包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包 ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:7:2","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"变量命名工具 codelf Google ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:8:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["码匠"],"content":"参考 编码5分钟，命名2小时？史上最全的Java命名规范参考！ ","date":"2022-01-06","objectID":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/:9:0","tags":[],"title":"变量命名","uri":"/posts/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"},{"categories":["golang"],"content":"Createitv","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"协程如何退出 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:1:0","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"1. 运行完毕自行退出 Context是控制并发的另一种方式。一个协程启动后，大部分情况需要等待里面的代码执行完毕，然后协程会自行退出。但是如果有一种情景，需要让协程提前退出怎么办呢? package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() watchDog() }() wg.Wait() } func watchDog() { for { select { default: fmt.Println(\"正在监控房间动静\") } time.Sleep(1 * time.Second) } } 第一端持续监控的代码，程序无法自行终断。如果需要让监控狗停止监控、退出程序，一个办法是定义一个全局变量，其他地方可以通过修改这个变量发出停止监控狗的通知。然后在协程中先检查这个变量，如果发现被通知关闭就停止监控，退出当前协程。 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:1:1","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"2.变量监控 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup wg.Add(1) stop := make(chan bool) go func() { defer wg.Done() watchDog(stop) }() time.Sleep(5 * time.Second) stop \u003c- false wg.Wait() } func watchDog(stop chan bool) { for { select { case \u003c- stop: //外部传递的结束信号 fmt.Println(\"收到结束信号马上停止goroutine\") return default: fmt.Println(\"正在监控房间动静\") } time.Sleep(1 * time.Second) } } 使用 select+channel 的方式改造的 watchDog 函数，实现了通过 channel 发送指令让监控狗停止，进而达到协程退出的目的 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:1:2","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"3.Context协程管理 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup wg.Add(1) // stop := make(chan bool) ctx, stop := context.WithCancel(context.Background()) go func() { defer wg.Done() watchDog(ctx) }() time.Sleep(5 * time.Second) // stop \u003c- false stop() wg.Wait() } func watchDog(ctx context.Context) { for { select { case \u003c- ctx.Done(): fmt.Println(\"收到结束信号马上停止goroutine\") return default: fmt.Println(\"正在监控房间动静\") } time.Sleep(1 * time.Second) } } 使用 context.WithCancel(context.Background()) 函数生成一个可以取消的 Context，用于发送停止指令。这里的 context.Background() 用于生成一个空 Context，一般作为整个 Context 树的根节点。 原来的 stop \u003c- true 停止指令，改为 context.WithCancel 函数返回的取消函数 stop()。 可以实现同样的功能看起来更优雅、而且功能更加全面 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup wg.Add(1) // stop := make(chan bool) ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) go func() { defer wg.Done() watchDog(ctx) }() time.Sleep(10 * time.Second) // stop \u003c- false cancel() wg.Wait() } func watchDog(ctx context.Context) { for { select { case \u003c- ctx.Done(): fmt.Println(\"收到结束信号马上停止goroutine\") return default: fmt.Println(\"正在监控房间动静\") } time.Sleep(1 * time.Second) } } context.WithTimeout设定几秒之后传递Cancel信号结束goroutine ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:1:3","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"什么是Context 一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。 如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。 Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。 Context 接口只有四个方法，下面进行详细介绍，在开发中你会经常使用它们，你可以结合下面的代码来看。 type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } Deadline 方法可以获取设置的截止时间，第一个返回值 deadline 是截止时间，到了这个时间点，Context 会自动发起取消请求，第二个返回值 ok 代表是否设置了截止时间。 Done 方法返回一个只读的 channel，类型为 struct{}。在协程中，如果该方法返回的 chan 可以读取，则意味着 Context 已经发起了取消信号。通过 Done 方法收到这个信号后，就可以做清理操作，然后退出协程，释放资源。 Err 方法返回取消的错误原因，即因为什么原因 Context 被取消。 Value 方法获取该 Context 上绑定的值，是一个键值对，所以要通过一个 key 才可以获取对应的值。 Context 接口的四个方法中最常用的就是 Done 方法，它返回一个只读的 channel，用于接收取消信号。当 Context 取消的时候，会关闭这个只读 channel，也就等于发出了取消信号。 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:2:0","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"Context 树 我们不需要自己实现 Context 接口，Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。 从使用功能上分，有四种实现好的 Context。 空 Context：不可取消，没有截止时间，主要用于 Context 树的根节点。 可取消的 Context：用于发出取消信号，当取消的时候，它的子 Context 也会取消。 可定时取消的 Context：多了一个定时的功能。 值 Context：用于存储一个 key-value 键值对。 从下图 Context 的衍生树可以看到，最顶部的是空 Context，它作为整棵 Context 树的根节点，在 Go 语言中，可以通过 context.Background() 获取一个根节点 Context。 （四种 Context 的衍生树） 有了根节点 Context 后，这颗 Context 树要怎么生成呢？需要使用 Go 语言提供的四个函数。 WithCancel(parent Context)：生成一个可取消的 Context。 WithDeadline(parent Context, d time.Time)：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。 WithTimeout(parent Context, timeout time.Duration)：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消 WithValue(parent Context, key, val interface{})：生成一个可携带 key-value 键值对的 Context。 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:2:1","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"Context传值 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup wg.Add(1) ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) valCtx := context.WithValue(ctx, \"robotID\", \"客厅监控number：0001\") go func() { defer wg.Done() watchDog(valCtx) }() time.Sleep(10 * time.Second) cancel() wg.Wait() } func watchDog(ctx context.Context) { for { select { case \u003c-ctx.Done(): fmt.Println(\"收到结束信号马上停止goroutine\") return default: fmt.Println(\"正在监控房间动静\") robotID := ctx.Value(\"robotID\") fmt.Println(\"监控机器人为：\", robotID) time.Sleep(1 * time.Second) } time.Sleep(1 * time.Second) } } 通过 context.WithValue 函数存储一个 robotID为 2 的键值对，就可以在 getUser 函数中通过 ctx.Value(“robotID”) 方法把对应的值取出来，达到传值的目的。 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:2:2","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"Context 使用原则 Context 是一种非常好的工具，使用它可以很方便地控制取消多个协程。在 Go 语言标准库中也使用了它们，比如 net/http 中使用 Context 取消网络的请求。 要更好地使用 Context，有一些使用原则需要尽可能地遵守。 Context 不要放在结构体中，要以参数的方式传递。 Context 作为函数的参数时，要放在第一位，也就是第一个参数。 要使用 context.Background 函数生成根节点的 Context，也就是最顶层的 Context。 Context 传值要传递必须的值，而且要尽可能地少，不要什么都传。 Context 多协程安全，可以在多个协程中放心使用。 以上原则是规范类的，Go 语言的编译器并不会做这些检查，要靠自己遵守。 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:2:3","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["golang"],"content":"总结 Context 通过 With 系列函数生成 Context 树，把相关的 Context 关联起来，这样就可以统一进行控制。一声令下，关联的 Context 都会发出取消信号，使用这些 Context 的协程就可以收到取消信号，然后清理退出。你在定义函数的时候，如果想让外部给你的函数发取消信号，就可以为这个函数增加一个 Context 参数，让外部的调用者可以通过 Context 进行控制，比如下载一个文件超时退出的需求。 ","date":"2022-01-02","objectID":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/:3:0","tags":[],"title":"Context包使用","uri":"/posts/context%E5%8C%85%E4%BD%BF%E7%94%A8/"},{"categories":["Golang"],"content":"Createitv","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"JWT是什么？ JWT (JSON Web Token)是一个开放标准（RFC 7519），指基于JSON的、用于在网络上声明某种主张的令牌（token），以保证各方之间安全的传输信息。 JWT通过将用户信息加密到token中，服务端不需要保存任何用户信息。服务端只需要通过保存的密钥来验证token正确性，如果正确即通过验证。 ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:1:0","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"JWT的组成 JWS实际上就是一个字符串，由三部分组成，头部(Header)、载荷(Payload)、签名(Signature)，并以.进行拼接。其中头部和载荷都是以JSON格式存放数据，只是进行了编码。 ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:2:0","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"1. 头部(Header) 每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256。 { \"alg\": \"HS256\", \"typ\": \"JWT\" } 因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下： `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 ` ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:2:1","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"2. 载荷(Payload) 载荷即消息体，这里会存放实际的内容，也就是Token的数据声明(Claim)。这一段有一些是标准字段，当然也可以根据自己需要添加自己需要的字段。标准字段如下： iss: Token签发者。格式是区分大小写的字符串或者uri，用于唯一标识签发token的一方。 sub: Token的主体，即它的所有人。格式是区分大小写的字符串或者uri。 aud: 接收Token的一方。格式为区分大小写的字符串或uri，或者这两种的数组。 exp: Token的过期时间，格式为时间戳。 nbf: 指定Token在nbf时间之前不能使用，即token开始生效的时间，格式为时间戳。 iat: Token的签发时间，格式为时间戳。 jti: 指此Token的唯一标识符字符串。主要用于实现唯一性保证，防止重放。 下面是一个示例： { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 } 同样进行Base64编码后，字符串如下： `eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ ` ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:2:2","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"3. 签名(Signature) 签名是对头部和载荷内容进行签名，一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致。 签名的过程： 对header的json数据进行Base64URL编码，得到一个字符串str1 对payload的json数据进行Base64URL编码，得到一个字符串str2 使用.对以上两个字符串进行拼接，得到字符串str3 使用header中声明的算法，以及服务端的密钥，对拼接字符串进行加密，生成签名 如果用伪代码表示就是(以HS256为例)： HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret ) 将三组字符串，以.相连，就得到了一个完整的token，例如： `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.OFHM3R8PSyHDT_vuzRF5fYkYWdhExM_9pE81kG05qAk ` ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:2:3","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"如何使用JWT？ 在之前的传统的方法时在服务端存储一个session，并给客户端返回一个cookie。而如果是使用jwt来做身份鉴定的话，当用户登录成功，会给用户一个token，前端只需要在本地保存该token即可(通常使用localStorage，也可以使用cookie)。 当用户需要访问一个受保护的资源时，需要再Header中使用Bearer模式的Authorization头。其内容看起来是下面这样： `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.OFHM3R8PSyHDT_vuzRF5fYkYWdhExM_9pE81kG05qAk ` ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:3:0","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"JWT的优缺点 优点： json具有通用性，所以可以跨语言。 组成简单，字节占用小，便于传输 服务端无需保存会话信息，很容易进行水平扩展 一处生成，多处使用，可以在分布式系统中，解决单点登录问题 可防护CSRF攻击 缺点： payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息 需要保护好加密密钥，一旦泄露后果不堪设想 为避免token被劫持，最好使用https协议 针对已经办法的令牌，无法作废，不容易应对数据过期的问题。 ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:4:0","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"Golang实现 / 指定加密密钥 var jwtSecret=[]byte(setting.JwtSecret) //Claim是一些实体（通常指的用户）的状态和额外的元数据 type Claims struct{ Username string `json:\"username\"` Password string `json:\"password\"` jwt.StandardClaims } // 根据用户的用户名和密码产生token func GenerateToken(username ,password string)(string,error){ //设置token有效时间 nowTime:=time.Now() expireTime:=nowTime.Add(3*time.Hour) claims:=Claims{ Username: username, Password: password, StandardClaims: jwt.StandardClaims{ // 过期时间 ExpiresAt:expireTime.Unix(), // 指定token发行人 Issuer:\"gin-blog\", }, } tokenClaims:=jwt.NewWithClaims(jwt.SigningMethodHS256,claims) //该方法内部生成签名字符串，再用于获取完整、已签名的token token,err:=tokenClaims.SignedString(jwtSecret) return token,err } // 根据传入的token值获取到Claims对象信息，（进而获取其中的用户名和密码） func ParseToken(token string)(*Claims,error){ //用于解析鉴权的声明，方法内部主要是具体的解码和校验的过程，最终返回*Token tokenClaims, err := jwt.ParseWithClaims(token, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) { return jwtSecret, nil }) if tokenClaims!=nil{ // 从tokenClaims中获取到Claims对象，并使用断言，将该对象转换为我们自己定义的Claims // 要传入指针，项目中结构体都是用指针传递，节省空间。 if claims,ok:=tokenClaims.Claims.(*Claims);ok\u0026\u0026tokenClaims.Valid{ return claims,nil } } return nil,err } ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:5:0","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"参考 https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html ","date":"2021-12-20","objectID":"/posts/jwt%E8%AE%A4%E8%AF%81/:5:1","tags":[],"title":"Jwt认证","uri":"/posts/jwt%E8%AE%A4%E8%AF%81/"},{"categories":["Golang"],"content":"Createitv","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"概念 什么是占位符？你就从表面意思理解，就是占位置，只不过有很多不同种类的位置，而且这个位置不是谁都能坐，是有要求的，在程序层面用于格式化数据。 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:1:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"哪些函数支持 在 Go 语言中，标准包 fmt 有好多格式化的工具函数，函数名末尾通常以 f 结尾，列举如下： fmt.Printf 格式化字符串并打印到终端（标准输出）。 fmt.Sprintf 格式化字符串并返回。 fmt.Sscanf 从字符串中解析占位符的对应位置数据。 fmt.Fscanf 从 io.Reader 类型中读取数据并解析占位符的对应位置数据，用于读取文件、终端（标准输入）。 fmt.Fprintf 将格式化的字符串数据输出到 io.Writer 类型中，用于输出到文件。 fmt.Errorf 格式化方式创建一个错误类型消息。 type Website struct { Name string } // 打印结构体时 var site = Website{Name:\"studygolang\"} 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(\"%v\", site)，Printf(\"%+v\", site) {studygolang}，{Name:studygolang} %#v 相应值的Go语法表示 Printf(\"#v\", site) main.Website{Name:“studygolang”} %T 相应值的类型的Go语法表示 Printf(\"%T\", site) main.Website %t 单词 true 或 false。 Printf(\"%t\", true) true %d 十进制表示 Printf(\"%d\", 0x12) 18 %f 有小数点而无指数， 例如 123.456 %s 输出字符串表示（string类型或[]byte) Printf(\"%s\", []byte(“Go语言学习园地”)) Go语言学习园地 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(\"%q\", “Go语言学习园地”) “Go语言学习园地” %p 十六进制表示，前缀 0x 作者：潇洒哥老苗 链接：https://www.zhihu.com/question/489996619/answer/2148418575 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:2:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"普通占位符 先创建一个数据，作为打印的对象。 type Example struct { Content string } var data = Example{Content: \"例子\"} ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:2:1","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"1. %v、%+v、%#v %v：获取数据的值，如果实现了error 接口，仅表示错误消息。 fmt.Printf(\"%v\", data) // 输出 {例子} fmt.Printf(\"%v\", errors.New(\"我错了\")) // 输出 我错了 %+v：获取数据的值，如果结构体，会携带字段名。 fmt.Printf(\"%+v\", data) // 输出 {Content:例子} %#v：获取数据的值，如果是结构体，会携带结构体名和字段名。 fmt.Printf(\"%#v\", data) // 输出 main.Example{Content:\"例子\"} ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:2:2","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"2. %T 获取数据类型。 fmt.Printf(\"%T\", data) // 输出 main.Example ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:2:3","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"3. %% 字面上的一个百分号。 fmt.Printf(\"%%\") // 输出 % ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:2:4","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"布尔占位符 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:3:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"%t true 或 false。 fmt.Printf(\"%t\", true) // 输出 true ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:3:1","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"整数占位符 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"1. %b 二进制。 fmt.Printf(\"%b\", 4) // 输出 100 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:1","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"2. %c Unicode 码转字符。 fmt.Printf(\"%c\", 0x82d7) // 输出 苗 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:2","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"3. %d、%5d、%-5d、%05d 十进制整数表示。 fmt.Printf(\"%d,%d,%d\", 10, 010, 0x10) // 输出 10,8,16 三个数据： 10 十进制，010 八进制，0x10 十六进制 占位符还可以指定最小宽度，格式如下： %5d：最小宽度为 5，右对齐，左边留白。 %-5d：左对齐，右边留白。 %05d：数字位数不足 5 位时，左边补零。 例： fmt.Printf(\"|%5d|%-5d|%05d|\", 1, 1, 1) // 输出 | 1|1 |00001| ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:3","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"4. %o、%#o 八进制表示。 fmt.Printf(\"%o,%o,%o\", 10, 010, 0x10) // 输出 12,10,20 在很多开发语言中，0 打头的数字都表示八进制。通过 %#o 输出带 0 开头。 fmt.Printf(\"\\n%#o\\n\", 10) // 输出 012 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:4","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"5. %q 同 %c 类似，都是Unicode 码转字符，只是结果多了单引号。 fmt.Printf(\"%q\", 0x82d7) // 输出 '苗' 汉字对应表：http://www.chi2ko.com/tool/CJK.htm ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:5","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"6. %x、%#x 十六进制表示，字母形式为小写 a-f，%#x 输出带 0x 开头。 fmt.Printf(\"%x, %#x\", 13, 13) // 输出 d, 0xd ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:6","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"7. %X、%#X 十六进制表示，字母形式为小写 A-F，%#X 输出带 0X 开头。 fmt.Printf(\"%X, %#X\", 13, 13) // 输出 D, 0XD ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:7","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"8. %U、%#U %U：转化为 Unicode 格式规范。 fmt.Printf(\"%U\", 0x82d7) // 输出 U+82D7 %#U：转化为 Unicode 格式并带上对应的字符。 fmt.Printf(\"%#U\", 0x82d7) // 输出 U+82D7 '苗' ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:4:8","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"浮点数与复数 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:5:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"1. %b 浮点数转化为 2 的幂的科学计数法。 fmt.Printf(\"%b\", 0.1) // 输出 7205759403792794p-56 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:5:1","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"2. %e、%E 10 的幂的科学计数法。 fmt.Printf(\"%e\", 10.2) // 输出 1.020000e+01 fmt.Printf(\"%E\", 10.2) // 输出 1.020000E+01 区别：%e 与 %E 输出时的大小写之分。 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:5:2","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"3. %f、%.2f 等等 浮点数，%.2f 表示保留 2 位小数，%f 默认保留 6 位，%f 与 %F 等价。 保留的规则我现在还没有搞清楚，有时候符合四舍五入，有时候不符合，容我下来研究下，再告诉大家。 fmt.Printf(\"%f\", 10.2) // 输出 10.200000 fmt.Printf(\"%.2f|%.2f\", 10.232, 10.235) // 输出 10.23|10.23 也可以加入最小宽度，如下： %9.2f 宽度最小为 9，包含小数位再内，精度为 2。 %9.f 或 %9f 宽度最小为 9。 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:5:3","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"4. %g、%.3g 根据情况选择 %e 或 %f ，但末尾去除 0。 %f 情况如下： fmt.Printf(\"%g|%g\", 10.20, 1.200000+3.400000i) // 输出 10.2|(1.2+3.4i) %e 情况如下： fmt.Printf(\"%g|%g\", 2e2, 2E2) // 输出 200|200 %.3g 表示的不是小数保留 3 位，而是只保留 3 个数字。 fmt.Printf(\"%.3g\", 12.34) // 输出 12.3 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:5:4","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"字符串与字节切片 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:6:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"1. %s 字符串或字节切片。 fmt.Printf(\"%s|%s\", \"老苗\", []byte(\"嘿嘿嘿\")) // 输出 老苗|嘿嘿嘿 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:6:1","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"2. %q 有 Go 语言安全转义，双引号包裹。 fmt.Printf(\"%q\", \"老苗\") // 输出 \"老苗\" ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:6:2","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"3. %x、%X 十六进制，%x 小写字母 a - f，%X 大写字母 A - F。 fmt.Printf(\"%x|%X\", \"苗\", \"苗\") // 输出 e88b97|E88B97 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:6:3","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"指针 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:7:0","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"%p、%#p 地址，使用十六进制表示，%p 带 0x，%#p 不带。 num := 2 s := []int{1, 2} fmt.Printf(\"%p|%p\", \u0026num, s) // 输出 0xc00000a1d0|0xc00000a1e0 ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:7:1","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["Golang"],"content":"参考： https://pkg.go.dev/fmt https://www.zhihu.com/question/489996619 https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter01/01.3.html ","date":"2021-12-13","objectID":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/:7:2","tags":[],"title":"Golang占位符","uri":"/posts/golang%E5%8D%A0%E4%BD%8D%E7%AC%A6/"},{"categories":["javascript"],"content":"Createitv","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":" 今天我们将通过建立并运行一个冰淇淋店来学习异步 JavaScript。在此过程中，你将学习如何使用： Callbacks Promises Async / Await 我们将在本文中介绍以下内容： 什么是异步 JavaScript JavaScript 中的同步与异步 Callbacks 如何在 JavaScript 中运行 Promises 如何在 JavaScript 中运行 Async/Await 如何在 JavaScript 中运行 让我们开始吧! ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:0:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"如果你喜欢，也可以在 YouTube 上观看本教程。 什么是异步 JavaScript？ 如果你想高效地构建项目，那么这个概念很适合你。 异步 JavaScript 理论可以帮助你将大型复杂的项目分解为较小的任务。 然后你可以使用 callbacks、promises 或 Async/await 中的任何一种来运行这些小任务，获得最好的结果。 让我们开始吧!🎖️ JavaScript 中的同步和异步 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:0:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"什么是同步系统？ 在同步系统中，任务一个接一个地完成。 想象一下，如果你只有一只手去完成十项任务，那么在同一个时间你只能做一个任务。 看看这个动图 – 这里会发生一件事： 你将看到，直到第一个图像完全加载，第二个图像才开始加载。 JavaScript 默认是同步的 [单线程]。你可以这样想 ——— 单线程意味着一次只能做一件事。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:1:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"什么是异步系统? 在这个系统中，任务是独立完成的。 假设你有十个任务以及十只手，那么在同一时间，每只手都可以同时独立完成每一项任务。 看看这张动图 - 你可以看到每个图像都是同时加载的。 同样，所有的图像都以自己的速度加载，它们都不会等待其他任务先完成。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:2:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"总结一下同步 JS 和异步 JS 想象三张图片在跑马拉松，在一个： 同步 系统，三张图片在同一条跑道上，一个不能超过另外一个，比赛得一个接一个地完成，如果 2 号图像停止，后续的图片也会停止。 异步 系统，这三张图片在不同的跑道上，它们会在自己的跑道上完成比赛，不会受其他图片的影响： ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:3:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"同步和异步代码示例 在开始我们的项目之前，让我们看一些例子来消除一些疑问。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:4:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"同步的代码示例 为了测试同步系统，用 JavaScript 写以下代码： console.log(\" I \"); console.log(\" eat \"); console.log(\" Ice Cream \"); 控制台的结果如下： ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:4:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"异步代码示例 我们假设吃冰淇淋需要两秒钟。现在，让我们测试一个异步系统。用JavaScript编写下面的代码。 注意： 不用担心，我们将在本文后面讨论 setTimeout() 函数。 console.log(\"I\"); // This will be shown after 2 seconds setTimeout(()=\u003e{ console.log(\"eat\"); },2000) console.log(\"Ice Cream\") 控制台的结果如下： 既然我们已经了解了同步操作和异步操作之间的区别，那么让我们来创建一个冰淇淋商店。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:4:2","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"如何设置我们的项目 对于这个项目，你只需要打开 Codepen.io直接开始编码。或者，你可以用 VS Code 编辑器来做。 打开 JavaScript 部分，然后打开开发人员控制台，我们将编写代码并在控制台中查看结果。 什么是 JavaScript 中的回调函数？ 当你将一个函数作为参数嵌套到另一个函数中时，这叫作回调。 下面是一个回调的说明: 一个回调的例子 别担心，我们马上就会看到一些回调的例子。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:5:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"为什么要使用回调? 在做一个复杂的任务时，我们把它分解成更小的步骤。为了根据时间（可选）和顺序在这些步骤之间建立关系，我们会使用回调。 看看这个例子： 图表包含制作冰淇淋的步骤 这些是制作冰淇淋需要的小步骤。还要注意，在本例中，步骤的顺序和计时是至关重要的，你不能只把水果切了就端上冰淇淋。 同时，如果前一个步骤没有完成，我们就不能进入下一个步骤。 为了更详细地解释这一点，让我们开始做冰淇淋店的生意。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:5:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"等等… 该店将分为两部分: 储藏室里有所有的配料 - 后台 我们将在厨房里制作冰淇淋 - 前端 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:6:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"让我们存储数据 现在，我们要把配料存储在一个对象中。 你可以像这样在对象中存储成分： let stocks = { Fruits : [\"strawberry\", \"grapes\", \"banana\", \"apple\"] } 我们的其他食材在这里： 你可以像这样将这些其他成分存储在 JavaScript 对象中： let stocks = { Fruits : [\"strawberry\", \"grapes\", \"banana\", \"apple\"], liquid : [\"water\", \"ice\"], holder : [\"cone\", \"cup\", \"stick\"], toppings : [\"chocolate\", \"peanuts\"], }; 整个业务取决于客户的 订单。一接到订单，我们就开始生产，然后供应冰淇淋。因此我们将创建两个函数 -\u003e order production 这就是它的工作原理： 从客户那里获取订单，取得食材，开始生产，然后上桌。 我们来写一下函数。在这里我们使用箭头函数: let order = () =\u003e{}; let production = () =\u003e{}; 现在，让我们使用回调建立这两个函数之间的关系，如下所示： let order = (call_production) =\u003e{ call_production(); }; let production = () =\u003e{}; ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:7:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"让我们做个小测试 我们将使用 console.log() 函数进行测试，以消除关于如何建立这两个函数之间的关系的疑问。 let order = (call_production) =\u003e{ console.log(\"Order placed. Please call production\") // function 👇 is being called call_production(); }; let production = () =\u003e{ console.log(\"Production has started\") }; 为了运行测试，我们将调用 order 函数。我们将添加第二个函数名为 production 作为它的参数。 // name 👇 of our second function // 将第二个函数命名为 👇 order(production); 下面是控制台中的结果： ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:7:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"休息一下 到目前为止一切都很好，休息一下吧! ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:8:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"清除 console.log 日志 保留这段代码并删除所有的东西，不要删除我们的 stocks 变量。在我们的第一个函数中，传递另一个参数，以便我们可以接收订单，即水果名： // 函数 1 let order = (fruit_name, call_production) =\u003e{ call_production(); }; // 函数 2 let production = () =\u003e{}; // 触发 👇 order(\"\", production); 下面是我们的步骤，以及执行每个步骤所需的时间。 图表包含制作冰淇淋的步骤 在这个图表中，你可以看到第一步是下订单，这需要 2 秒。第二步是切水果（2秒），第三步是加水和冰（1秒），第四步启动机器（1秒），第五步是选择容器（2秒），第六步是选择配料（3秒），以及第七步，也就是最后一步，端上冰淇淋，这需要 2 秒。 要建立计时，函数 setTimeout() 非常好，因为它也使用一个回调函数作为参数。 setTimeout() 函数的语法 现在，让我们使用这个函数来选择水果： // 功能1 let order = (fruit_name, call_production) =\u003e{ setTimeout(function(){ console.log(`${stocks.Fruits[fruit_name]}was selected`) // Order placed. Call production to start call_production(); },2000) }; // 功能2 let production = () =\u003e{ // blank for now }; // 触发 👇 order(0, production); 下面是控制台中的结果： 注意 2秒后才会显示结果。 如果你想知道我们是如何从 stock 变量中采摘草莓的，下面是代码： 不删除任何代码。现在，我们将使用以下代码开始编写生产函数。我们将使用箭头函数。 let production = () =\u003e{ setTimeout(()=\u003e{ console.log(\"production has started\") },0000) }; 结果如下： 我们将在现有的 setTimeout 函数中嵌套另一个 setTimeout 函数来切水果： let production = () =\u003e{ setTimeout(()=\u003e{ console.log(\"production has started\") setTimeout(()=\u003e{ console.log(\"The fruit has been chopped\") },2000) },0000) }; 结果如下： 如果你还记得，这是我们的步骤： 图表包含制作冰淇淋的步骤 让我们通过在另一个函数中嵌套一个函数来完成我们的冰淇淋生产 - 这也叫作回调，还记得吗？ let production = () =\u003e{ setTimeout(()=\u003e{ console.log(\"production has started\") setTimeout(()=\u003e{ console.log(\"The fruit has been chopped\") setTimeout(()=\u003e{ console.log(`${stocks.liquid[0]}and ${stocks.liquid[1]}Added`) setTimeout(()=\u003e{ console.log(\"start the machine\") setTimeout(()=\u003e{ console.log(`Ice cream placed on ${stocks.holder[1]}`) setTimeout(()=\u003e{ console.log(`${stocks.toppings[0]}as toppings`) setTimeout(()=\u003e{ console.log(\"serve Ice cream\") },2000) },3000) },2000) },1000) },1000) },2000) },0000) }; 控制台结果如下： 感到疑惑吗？ 这叫作回调地狱，它看起来像这样（还记得上面的代码吗）： 回调地狱图解 解决方案是什么? 如何使用 Promise 来避免回调地狱 Promises 的发明是为了解决回调地狱的问题和更好地处理我们的任务。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:9:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"休息一下 先休息一下! 这就是 promise 的样子 promise 的格式说明 让我们一起来剖析 promise。 promise 周期的图解 如上图所示，一个 promise 有三种状态： Pending： 这是初始阶段，这里什么也没有发生。你可以这样想，你的客户正在慢慢地给你下订单，但是他们还没有点任何东西。 Resolved： 这意味着你的顾客已经收到了他们的食物并且很高兴 Rejected： 这意味着你的顾客没有收到他们点的单并离开了冰激凌店 让我们将 promise 应用到我们的冰淇淋生产案例研究中。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:10:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"等等 首先，我们需要了解另外四件事 -\u003e 时间和工作的关系 Promise 链 错误处理 .finally 函数 让我们开始我们的冰淇淋店，一步一步地理解这些概念。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:11:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"时间和工作的关系 如果你还记得，这就是我们制作冰淇淋的步骤和时间 图表包含制作冰淇淋的步骤 为了实现这一点，让我们在 JavaScript 中创建一个变量： let is_shop_open = true; 现在创建一个名叫 order 的函数，然后传两个名叫 time, work的参数： let order = ( time, work ) =\u003e{ } 现在，我们要向客户发起 promise，“我们将给献上冰淇淋”，如下 -\u003e let order = ( time, work ) =\u003e{ return new Promise( ( resolve, reject )=\u003e{ } ) } 我们的 promise 有两个部分： Resolved - 用户拿到了冰激凌 Rejected - 用户没有拿到冰激凌 let order = ( time, work ) =\u003e { return new Promise( ( resolve, reject )=\u003e{ if( is_shop_open ){ resolve( ) } else{ reject( console.log(\"Our shop is closed\") ) } }) } 让我们在 if 语句中使用 setTimeout() 函数在 promise 中添加时间和工作因素。 注意: 在现实生活中，你也可以避免时间因素，这完全取决于你的工作性质。 let order = ( time, work ) =\u003e { return new Promise( ( resolve, reject )=\u003e{ if( is_shop_open ){ setTimeout(()=\u003e{ // work is 👇 getting done here resolve( work() ) // Setting 👇 time here for 1 work }, time) } else{ reject( console.log(\"Our shop is closed\") ) } }) } 现在，我们要用新创建的函数开始制作冰淇淋。 // Set 👇 time here order( 2000, ()=\u003econsole.log(`${stocks.Fruits[0]}was selected`)) // pass a ☝️ function here to start working 2 秒后的结果是： 很棒！ ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:12:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"Promise 链 在这个方法中，我们使用 .then 处理后续的程序： 使用 .then 处理函数的 promise 链说明 当我们的 promise 被 resolve 时, .then 处理函数返回一个 promise。 例子如下: 让我说得简单点：这类似于给某人指示，你告诉别人“先做这个，然后做那个，然后做其他的事情，然后…”，然后……，然后……”等。 他的首要任务是我们原始 promise 一旦完成了一小部分工作，剩下的任务就返回了新的 promise 让我们在项目中实现这一点。在代码的底部编写以下代码行。 注意: 不要忘记在 .then 函数中写 return 。否则，它将不能正常工作。如果你很好奇，试着在我们完成这些步骤后去掉返回值： order(2000,()=\u003econsole.log(`${stocks.Fruits[0]}was selected`)) .then(()=\u003e{ return order(0000,()=\u003econsole.log('production has started')) }) 结果如下： 使用相同的系统，让我们完成我们的项目： // step 1 order(2000,()=\u003econsole.log(`${stocks.Fruits[0]}was selected`)) // step 2 .then(()=\u003e{ return order(0000,()=\u003econsole.log('production has started')) }) // step 3 .then(()=\u003e{ return order(2000, ()=\u003econsole.log(\"Fruit has been chopped\")) }) // step 4 .then(()=\u003e{ return order(1000, ()=\u003econsole.log(`${stocks.liquid[0]}and ${stocks.liquid[1]}added`)) }) // step 5 .then(()=\u003e{ return order(1000, ()=\u003econsole.log(\"start the machine\")) }) // step 6 .then(()=\u003e{ return order(2000, ()=\u003econsole.log(`ice cream placed on ${stocks.holder[1]}`)) }) // step 7 .then(()=\u003e{ return order(3000, ()=\u003econsole.log(`${stocks.toppings[0]}as toppings`)) }) // Step 8 .then(()=\u003e{ return order(2000, ()=\u003econsole.log(\"Serve Ice Cream\")) }) 结果如下： ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:13:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"错误处理 当出现错误时，我们需要一种处理错误的方法。但首先，我们需要了解 promise 周期。 promise 周期说明 为了捕获错误，让我们将变量改为 false。 let is_shop_open = false; 也就是说我们的店关门了，我们不再卖冰淇淋给顾客了。 为了处理这种情况我们使用 .catch 函数，类似 .then，它也返回一个promise，但只有当我们最初的 promise 被 reject 时才会执行。 这里有一个小提示： .then 在 promise resolved 时候被执行 .catch 在 promise rejected 时候被执行 到代码最底部，编写以下代码： 记住在.then 和 .catch之间不能有任何东西。 .catch(()=\u003e{ console.log(\"Customer left\") }) 结果如下： 关于这段代码，有两点需要注意： 第一个信息是从 reject() 部分来的 第二个信息是从 catch() 部分来的 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:14:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"如何使用 .finally() 函数 有一个叫作 “finally” 的函数，不管我们的 promise 是被 resolve 了还是被 reject 了，它都会被执行。 例如: 不管我们是没有顾客还是有 100 个顾客，我们的店都会在一天结束的时候关门。 如果您想对此进行测试，请在最下面编写以下代码： .finally(()=\u003e{ console.log(\"end of day\") }) 结果如下： 请大家欢迎 Async/Await~ Async/Await 如何在 JavaScript 中运行 这应该是编写 promise 的更好方式，它可以帮助我们保持代码的简单和干净。 你所要做的就是在任何常规函数之前写 async 关键字，它就变成了一个 promise。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:15:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"先休息一下 让我们来看一看： ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:16:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"JavaScript 中 Promises vs Async/Await 在 async/await 之前，为了写一个 promise，我们这样写: function order(){ return new Promise( (resolve, reject) =\u003e{ // Write code here } ) } 现在使用 async/await，我们可以这么写： //👇 神奇的关键字 async function order() { // Write code here } ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:17:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"等等… 你必须理解-\u003e 如何使用 try 和 catch 关键字 如何使用 await 关键字 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:18:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"如何使用 Try 和 Catch 关键字 我们使用 try 关键字来运行代码，同时使用 catch 来捕获错误。这和我们看 promise 时看到的概念是一样的。 让我们来比较一下。我们来看一个小 demo，然后开始编码。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:19:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"JS 中的 Promise -\u003e resolve 和 reject 我们在 resolve 中这样使用 resolve 和 reject： function kitchen(){ return new Promise ((resolve, reject)=\u003e{ if(true){ resolve(\"promise is fulfilled\") } else{ reject(\"error caught here\") } }) } kitchen() // run the code .then() // next step .then() // next step .catch() // error caught here .finally() // end of the promise [optional] ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:19:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"JS 中的 Async/Await -\u003e try, catch 当我们使用 async/await 时，可以这么写: //👇 神奇的关键字 async function kitchen(){ try{ // 我们来制造一个假问题 await abc; } catch(error){ console.log(\"abc does not exist\", error) } finally{ console.log(\"Runs code anyways\") } } kitchen() // 调用 不要慌，我们接下来将讨论 await 关键字。 现在希望你理解了 promise 和 async/await 之间的区别了。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:19:2","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"如何使用 JavaScript 的 Await 关键字 关键字 await 使 JavaScript 等待，直到一个 promise reslove 时才会返回它的结果。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:20:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"如何在 JavaScript 中使用 await 关键字 我们回冰淇淋店去吧。我们不知道顾客更喜欢哪种配料，巧克力还是花生，所以我们需要停止机器，然后去问顾客他们想在冰淇淋上加什么。 注意这里只有我们的厨房被停止了，但是我们在厨房外的员工仍然会做这样的事情: 洗餐具 清洁桌子 点单，等等 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:20:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"一个 Await 关键字代码示例 让我们创建一个小 promise 来询问要使用那种配料，这个过程需要 3 秒。 function toppings_choice (){ return new Promise((resolve,reject)=\u003e{ setTimeout(()=\u003e{ resolve( console.log(\"which topping would you love?\") ) },3000) }) } 现在，让我们首先使用 async 关键字来创建 kitchen 函数。 async function kitchen(){ console.log(\"A\") console.log(\"B\") console.log(\"C\") await toppings_choice() console.log(\"D\") console.log(\"E\") } // 触发函数 kitchen(); 让我们在 kitchen() 调用下面添加其他任务。 console.log(\"doing the dishes\") console.log(\"cleaning the tables\") console.log(\"taking orders\") 结果如下： 我们走出厨房问我们的顾客，“你想要哪种配料？”，与此同时，还有其他事情要做。 一旦他们选好了配料，我们就进入厨房，完成任务。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:21:0","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"注意 当使用 Async/Await 时，你也可以使用 promise 的核心部分 .then、.catch 和 .finally函数。 ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:21:1","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["javascript"],"content":"我们再开一家冰淇淋店吧 我们要创建两个函数 -\u003e kitchen: 制作冰激凌 time: 分配好每一项小任务所需要的时间 让我们开始吧！先创建时间函数: let is_shop_open = true; function time(ms) { return new Promise( (resolve, reject) =\u003e { if(is_shop_open){ setTimeout(resolve,ms); } else{ reject(console.log(\"Shop is closed\")) } }); } 现在，让我们创建我们的厨房： async function kitchen(){ try{ // instruction here } catch(error){ // error management here } } // Trigger kitchen(); 让我们来做个小说明，看看我们的厨房功能是否正常： async function kitchen(){ try{ // 执行这 1 个任务所花费的时间 await time(2000) console.log(`${stocks.Fruits[0]}was selected`) } catch(error){ console.log(\"Customer left\", error) } finally{ console.log(\"Day ended, shop closed\") } } // 触发 kitchen(); 当商店开门时，结果是这样的： 当商店关门时，结果是这样的： 到目前为止一切顺利。 让我们完成我们的项目。 下面是我们的任务列表： 图表包含制作冰淇淋的步骤 首先，开张： let is_shop_open = true; 现在在 kitchen() 函数中编写步骤： async function kitchen(){ try{ await time(2000) console.log(`${stocks.Fruits[0]}was selected`) await time(0000) console.log(\"production has started\") await time(2000) console.log(\"fruit has been chopped\") await time(1000) console.log(`${stocks.liquid[0]}and ${stocks.liquid[1]}added`) await time(1000) console.log(\"start the machine\") await time(2000) console.log(`ice cream placed on ${stocks.holder[1]}`) await time(3000) console.log(`${stocks.toppings[0]}as toppings`) await time(2000) console.log(\"Serve Ice Cream\") } catch(error){ console.log(\"customer left\") } } 结果如下： 总结 恭喜你读完了本文！在本文中，你可以了解到： 同步和异步系统之间的区别 异步 JavaScript 使用 3 种机制（callbacks、promises 和 Async/Await） 这是你阅读到最后的奖励。❤️ ","date":"2021-12-01","objectID":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/:21:2","tags":["异步编程"],"title":"JS异步制作冰淇淋必看","uri":"/posts/js%E5%BC%82%E6%AD%A5%E5%88%B6%E4%BD%9C%E5%86%B0%E6%B7%87%E6%B7%8B%E5%BF%85%E7%9C%8B/"},{"categories":["机器学习","数学"],"content":"Createitv","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"什么是向量 向量 （英语：euclidean vector，物理、工程等也称作矢量 、欧几里得向量）是数学、物理学和工程科学等多个自然科学中的基本概念。指一个同时具有大小和方向，且满足平行四边形法则的几何对象。理论数学中向量的定义为任何在向量空间中的元素。一般地，同时满足具有大小和方向两个性质的几何对象即可认为是向量（特别地，电流属既有大小、又有正负方向的量，但由于其运算不满足平行四边形法则，公认为其不属于向量）。向量常常在以符号加箭头标示以区别于其它量。与向量相对的概念称**标量**或**数量**，即只有大小、绝大多数情况下没有方向（电流是特例）、不满足平行四边形法则的量。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:1:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"不同学科中的向量 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:2:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"数学 在线性代数中，向量常常采用更为抽象的向量空间（也称为线性空间）来定义。向量是所谓向量空间中的基本构成元素。 向量空间是基于物理学或几何学中的空间概念而形成的一个抽象概念，是满足一系列法则的元素的集合，而欧几里得空间便是线性空间的一种。向量空间中的元素就可以被称为向量，而欧几里得向量则是特指欧几里得空间中的向量。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:2:1","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"物理学与工程学 在物理学和诸多工程学科中，向量更多地被称作矢量。许多常见的物理量都是用矢量描述，如运动学中的位移、速度、加速度，力学中的力、力矩，电磁学中的电流密度、磁矩、电磁波等等。 物理学和一般的几何学中涉及的向量概念严格意义上应当被称为欧几里得向量或几何向量。定义具有物理意义上的大小和方向的向量概念则需要引进了定义了范数和内积的欧几里得空间。按照定义，欧几里得向量由大小和方向构成。 固定向量 在一些上下文中，尤其在物理学领域，有些向量会与起点有关（如一个力与其的作用点有关，质点运动速度与该质点的位置有关），因而假设向量有确定的起点和终点，当起点和终点改变后，构成的向量就不再是原来的向量。这样的向量也被称为固定向量。例子之一是运动学中常见的物理量位置矢量。 自由向量 位置可自由移动 在另一些时候，由于向量的共性都具有大小和方向，会认为向量的起点和终点并不那么重要。两个起点不一样的向量，只要大小相等，方向相同，就可以称为是同一个向量。这样的向量被称为自由向量。在数学中，一般只研究自由向量，并且数学中所指的向量就是指自由向量。也就是只要大小以及方向一样，即可视为同一向量，与向量的起始点并无关系。一些文献中会提到向量空间带有一个特定的原点，这时可能会默认向量的起点是原点。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:2:2","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量的发展历史 向量，最初被应用于物理学。很多物理量如力、速度、位移以及电场强度、磁感应强度等都是向量。大约公元前350年前，古希腊著名学者亚里士多德就知道了力可以表示成向量，两个力的组合作用可用著名的平行四边形法则来得到。“向量”一词来自力学、解析几何中的有向线段。最先使用有向线段表示向量的是英国大科学家牛顿。 从数学发展史来看，历史上很长一段时间，空间的向量结构并未被数学家们所认识，直到19世纪末20世纪初，人们才把空间的性质与向量运算联系起来，使向量成为具有一套优良运算通性的数学体系。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:3:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量的表达方式 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:4:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"代数表示 一般印刷用黑体的小写英文字母（a、b、c等）来表示，手写用在a、b、c等字母上加一箭头（→）表示，如 ，也可以用大写字母AB、CD上加一箭头（→）等表示。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:4:1","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"几何表示 向量表示 向量可以用有向线段来表示。有向线段的长度表示向量的大小，向量的大小，也就是向量的长度。长度为0的向量叫做零向量，记作长度等于1个单位的向量，叫做单位向量。箭头所指的方向表示向量的方向。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:4:2","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"矩阵表示 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:4:3","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"特殊向量 类似于数字中的1（单位元）、相反数（加法逆元）、0（加法单位元），向量中有单位向量（单位元）、反向量（加法逆元）、零向量（加法单位元）、等概念量。此外，还有方向向量、相等向量等概念。 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:5:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量的性质 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:6:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"有向线段 一个以点A为起点，B为终点的有向线段。 有向线段的概念建构于向量的方向与长度，差别在于多定义了始点与终点。在文字描述时，如果已知某有向线段的起点和终点分别是A和B ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:6:1","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"大小 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:6:2","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"夹角 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:6:3","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"线性相关性 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:6:4","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量运算 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:7:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"加法和减法 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:7:1","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量与积 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:7:2","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"标量乘法 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:7:3","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"数量积、内积 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:7:4","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量积、叉积、外积 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:7:5","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"向量计算的python代码表示 import math from ._globals import EPSILON # EPSILON = 1e-8 解决计算机计算精度的问题 class Vector: def __init__(self, lst): self._values = list(lst) @classmethod def zero(cls, dim): \"\"\"返回一个dim维的零向量\"\"\" return cls([0] * dim) def __add__(self, another): \"\"\"向量加法，返回结果向量\"\"\" assert len(self) == len(another), \\ \"Error in adding. Length of vectors must be same.\" return Vector([a + b for a, b in zip(self, another)]) def __sub__(self, another): \"\"\"向量减法，返回结果向量\"\"\" assert len(self) == len(another), \\ \"Error in subtracting. Length of vectors must be same.\" return Vector([a - b for a, b in zip(self, another)]) def norm(self): \"\"\"返回向量的模\"\"\" return math.sqrt(sum(e**2 for e in self)) def normalize(self): \"\"\"返回向量的单位向量\"\"\" if self.norm() \u003c EPSILON: raise ZeroDivisionError(\"Normalize error! norm is zero.\") return Vector(self._values) / self.norm() def dot(self, another): \"\"\"向量点乘，返回结果标量\"\"\" assert len(self) == len(another), \\ \"Error in dot product. Length of vectors must be same.\" return sum(a * b for a, b in zip(self, another)) def __mul__(self, k): \"\"\"返回数量乘法的结果向量：self * k\"\"\" return Vector([k * e for e in self]) def __rmul__(self, k): \"\"\"返回数量乘法的结果向量：k * self\"\"\" return self * k def __truediv__(self, k): \"\"\"返回数量除法的结果向量：self / k\"\"\" return (1 / k) * self def __pos__(self): \"\"\"返回向量取正的结果向量\"\"\" return 1 * self def __neg__(self): \"\"\"返回向量取负的结果向量\"\"\" return -1 * self def __iter__(self): \"\"\"返回向量的迭代器\"\"\" return self._values.__iter__() def __getitem__(self, index): \"\"\"取向量的第index个元素\"\"\" return self._values[index] def __len__(self): \"\"\"返回向量长度（有多少个元素）\"\"\" return len(self._values) def __repr__(self): return \"Vector({})\".format(self._values) def __str__(self): return \"({})\".format(\", \".join(str(e) for e in self._values)) ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:8:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"代码运算 from playLA.Vector import Vector if __name__ == \"__main__\": vec = Vector([5, 2]) print(vec) print(\"len(vec) = {}\".format(len(vec))) print(\"vec[0] = {}, vec[1] = {}\".format(vec[0], vec[1])) vec2 = Vector([3, 1]) print(\"{} + {} = {}\".format(vec, vec2, vec + vec2)) print(\"{} - {} = {}\".format(vec, vec2, vec - vec2)) print(\"{} * {} = {}\".format(vec, 3, vec * 3)) print(\"{} * {} = {}\".format(3, vec, 3 * vec)) print(\"+{} = {}\".format(vec, +vec)) print(\"-{} = {}\".format(vec, -vec)) zero2 = Vector.zero(2) print(zero2) print(\"{} + {} = {}\".format(vec, zero2, vec + zero2)) print(\"norm({}) = {}\".format(vec, vec.norm())) print(\"norm({}) = {}\".format(vec2, vec2.norm())) print(\"norm({}) = {}\".format(zero2, zero2.norm())) print(\"normalize {} is {}\".format(vec, vec.normalize())) print(vec.normalize().norm()) print(\"normalize {} is {}\".format(vec2, vec2.normalize())) print(vec2.normalize().norm()) try: zero2.normalize() except ZeroDivisionError: print(\"Cannot normalize zero vector {}.\".format(zero2)) print(vec.dot(vec2)) ### ----------------output--------------- ### (5, 2) len(vec) = 2 vec[0] = 5, vec[1] = 2 (5, 2) + (3, 1) = (8, 3) (5, 2) - (3, 1) = (2, 1) (5, 2) * 3 = (15, 6) 3 * (5, 2) = (15, 6) +(5, 2) = (5, 2) -(5, 2) = (-5, -2) (0, 0) (5, 2) + (0, 0) = (5, 2) norm((5, 2)) = 5.385164807134504 norm((3, 1)) = 3.1622776601683795 norm((0, 0)) = 0.0 normalize (5, 2) is (0.9284766908852593, 0.3713906763541037) 1.0 normalize (3, 1) is (0.9486832980505138, 0.31622776601683794) 0.9999999999999999 Cannot normalize zero vector (0, 0). 17 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:8:1","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"numpy内置模块的向量计算 import numpy as np if __name__ == \"__main__\": print(np.__version__) # np.array 基础 lst = [1, 2, 3] lst[0] = \"Linear Algebra\" print(lst) vec = np.array([1, 2, 3]) print(vec) # vec[0] = \"Linear Algebra\" # vec[0] = 666 # print(vec) # np.array的创建 print(np.zeros(5)) print(np.ones(5)) print(np.full(5, 666)) # np.array的基本属性 print(vec) print(\"size =\", vec.size) print(\"size =\", len(vec)) print(vec[0]) print(vec[-1]) print(vec[0: 2]) print(type(vec[0: 2])) # np.array的基本运算 vec2 = np.array([4, 5, 6]) print(\"{} + {} = {}\".format(vec, vec2, vec + vec2)) print(\"{} - {} = {}\".format(vec, vec2, vec - vec2)) print(\"{} * {} = {}\".format(2, vec, 2 * vec)) print(\"{} * {} = {}\".format(vec, vec2, vec * vec2)) print(\"{}.dot({}) = {}\".format(vec, vec2, vec.dot(vec2))) print(np.linalg.norm(vec)) print(vec / np.linalg.norm(vec)) print(np.linalg.norm(vec / np.linalg.norm(vec))) # zero3 = np.zeros(3) # print(zero3 / np.linalg.norm(zero3)) ### ------------------output-------------------------### 1.20.2 ['Linear Algebra', 2, 3] [1 2 3] [0. 0. 0. 0. 0.] [1. 1. 1. 1. 1.] [666 666 666 666 666] [1 2 3] size = 3 size = 3 1 3 [1 2] \u003cclass 'numpy.ndarray'\u003e [1 2 3] + [4 5 6] = [5 7 9] [1 2 3] - [4 5 6] = [-3 -3 -3] 2 * [1 2 3] = [2 4 6] [1 2 3] * [4 5 6] = [ 4 10 18] [1 2 3].dot([4 5 6]) = 32 3.7416573867739413 [0.26726124 0.53452248 0.80178373] 1.0 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:9:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["机器学习","数学"],"content":"参考： 1.https://zh.wikipedia.org/wiki/向量 2.Mooc网给程序员的线性代数 ","date":"2021-10-30","objectID":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/:10:0","tags":["线性代数"],"title":"线性代数之向量","uri":"/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/"},{"categories":["数学"],"content":"Createitv","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"数学的发展过程 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:0:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"1. 数学的起源和早期发展 6 BC 埃及、美索不达米亚地区 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:0:1","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"2. 初等数学时期 BC6 — AD16 古希腊数学(公理化) 中世纪的中国数学(计算和代数) 印度和阿拉伯数学(计算和代数) ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:0:2","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"3. 近代数学时期 近代数学兴起(笛卡尔坐标思想、菲尔马解析几何，将代数方程和几何曲线统一了起来) 微积分的创立和发展(牛顿、莱布尼兹) 代数学的新生(抽象方程的求解转移到代数结构的研究。阿贝尔、伽罗瓦) 几何学的变革 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:0:3","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"4. 20世界的现代数学 AD18 — Now 应用数学 数的概念的产生 参考： 数字的由来 原始社会，人类用在绳子上打结的方法来记数，并以绳结的大小来表示野兽的大小，数的概念就在这样的过程中逐渐发展起来。在距今约五六千年前，古埃及人较早地开始了农业生产，当时古埃及的农业制度，是国王分配同样大小的正方形土地给每一个人，耕种的人每年拿出一部分的收获交租。如果洪水冲毁了他们的土地，他们可以报告给统治者，再由统治者调查和测量受损土地的大小，并减免相应部分的租金。出于对土地的测量需求，几何学应运而生。 埃及、美索不达米亚地区 埃及：土地测量 美索不达米亚： 印度： 宗教 中国： 天体测量 乘法、分数产生 60分钟计数法 数表 几何方法解二次方程 希腊 河谷文明过渡到海洋文明，应用数学也过渡到理论数学 古希腊在数学史中占有不可分割的地位。古希腊人十分重视数学和逻辑。希腊数学的发展历史可以分为三个时期。第一期从伊奥尼亚学派到柏拉图学派为止，约为公元前七世纪中叶到公元前三世纪；第二期是亚历山大前期，从欧几里得起到公元前146年，希腊陷于罗马为止；第三期是亚历山大后期，是罗马人统治下的时期，结束于641年亚历山大被阿拉伯人占领。 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:0:4","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"发展初期 600BC - 300BC ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:1:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"泰勒斯 历史上第一位数学家 论证几何 泰勒斯 圆的直径将圆分为二等分 等腰三角形底角相等 柏拉图评价他： 他只想知道天上的事情，却看不到脚边的东西 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:1:1","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"毕达哥拉斯 毕达哥拉斯定理 == 勾股定理 形数 无理数的发现(第一次数学危机) 一开始认为：任意度量可以表示为两个整数之比，只有有理数的概念而没有无理数的概念 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:1:2","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"雅典时期的数学 尺规作图、三大几何问题 化圆为方 倍立方体，发现了圆锥曲线 三等分角 无限性概念 芝诺悖论 阿基里斯追龟说 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:2:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"希腊时期(鼎盛时期) ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:3:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"亚里士多德 科学必须从公式和定理开始 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:3:1","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"欧几里得 欧式吸取毕氏学派失败的经验，重新「分析」与「整理」既有的几何知识，另辟路径，改几何本身来建立几何（不用毕式经验式的原子论，即使优多诸斯已补全了毕氏学派的漏洞）并且采用公理化的手法，逐本探源，最后终於找到五条几何公理与五条一般公理是欧氏的创造与发现过程。接著是「综合」，利用10条公理配合优多诸斯检定法则、反证法（归谬法）与尺规作图，推导出所有的几何定理，这是逻辑的证明过程。 五条几何公理 1.过相异两点，能作且只能作一直线（直线公理）。 2.线段(有限直线)可以任意地延长。 3.以任一点为圆心、任意长为半径，可作一圆(圆公理)。 4.凡是直角都相等(角公理)。 5.两直线被第三条直线所截，如果同侧两内角和小于两个直角， 则两直线则会在该侧相交。 五条一般公理 （a,b,c,d 皆为正数） 1.跟同一个量相等的两个量相等；即若 a=c 且 b=c，则 a = b（等量代换公理）。 2.等量加等量，其和相等；即若 a=b 且 c=d，则 a+c = b+d（等量加法公理）。 3.等量减等量，其差相等；即若 a=b 且 c=d，则 a-c = b-d（等量减法公理）。 4.完全叠合的两个图形是全等的（移形叠合公理）。 5.全量大于分量，即 a+b\u003ea（全量大于分量公理）。 点、线、面 平面几何 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:3:2","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"阿基米德 浮力定律 杠杆原理 圆周率计算 球的体积计算 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:3:3","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"阿波罗尼斯 《圆锥曲线论》 和浴缸里的阿基米德、金字塔前的欧几里德相比，阿波罗尼斯的名气可能稍微小一些，但他毕生致力于圆锥曲线或二次曲线的研究，他的纯几何方法在圆锥曲线上的研究成果直到17世纪才被笛卡尔和帕斯卡所超越 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:3:4","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"衰退期 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:4:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"海伦公式 海伦公式 - 维基百科，自由的百科全书 海伦鯠臫公式又頭译作希伦公式條、海伦－秦九韶公式。它是利用三角形的三条边的边长直接求三角形面积的公式。表达式为：S=√p(p-a)(p-b)(p-c)，它的特点是形式漂亮，便于记忆。 两汉时期的数学 周髀算经、九章算术—-实用和算法发展，而不想希腊注重推理和公式化 《九章算术》共收有246个数学问题，分为九大类，在一个或几个问题之后，列出这个问题的解法。 方田章：主要是田亩**面积**的计算和**分数**的计算，是世界上最早对分数进行系统叙述的著作。 粟米章：主要是粮食交易的计算方法，其中涉及许多比例问题。 衰分章：主要内容为分配比例的算法。 少广章：主要讲开平方和开立方的方法。 商功章：主要是土石方和用工量等**工程数学**问题，以**体积**的计算为主。 均输章：计算税收等更加复杂的比例问题。 盈不足章：**双设法**的问题。 方程章：主要是**联立一次方程组**的解法和**正负数的加减法**，在世界数学史上是第一次出现。 勾股章：**勾股定理**的应用。 魏晋南北朝时期 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:5:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["数学"],"content":"刘徽和祖冲之 《九章算术注》、割圆法、球体积理论，pi 文艺复兴欧洲 代数学、三角学、对数 斐波拉契 解析几何诞生 解析几何（英语：Analytic geometry），又称为坐标几何（英语：Coordinate geometry）或卡氏几何（英语：Cartesian geometry），早先被叫作笛卡尔几何，是一种借助于解析式进行图形研究的几何学分支。解析几何通常使用二维的平面直角坐标系研究直线、圆、圆锥曲线、摆线、星形线等各种一般平面曲线，使用三维的空间直角坐标系来研究平面、球等各种一般空间曲面，同时研究它们的方程，并定义一些图形的概念和参数。 解析几何中的重要问题： 向量空间 平面的定义 距离问题 点积求两个向量的角度 外积求一向量垂直于两个已知向量（以及它们的空间体积） 交点问题 现代应用数学 应用数学，是利用数学方法解决实际问题的一门学科，在经济金融、工程科技等领域都有应用。 [1] 应用数学专业培养掌握数学科学的基本理论与基本方法，具备运用数学知识、使用计算机解决实际问题的能力，受到科学研究的初步训练，能在科技、教育和经济部门从事研究、教学工作或在生产经营及管理部门从事实际应用、开发研究和管理工作的高级专门人才。 概率论与数理统计 数理经济 ","date":"2021-10-19","objectID":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/:6:0","tags":[],"title":"数学简史","uri":"/posts/%E6%95%B0%E5%AD%A6%E7%AE%80%E5%8F%B2/"},{"categories":["深度学习"],"content":"Createitv","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"本文以CNN算法的的领域之一图像识别为基础介绍CNN相关原理。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:0:0","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"1. 人是如何识别物体 人眼识别物体涉及脑神经，视觉神经。属于我的知识盲区，大致是从光照射到物体反射到眼球，第一层视网神经到各中电信号生物信号器官部位传导们最后统一到视觉皮层处理形成影像。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:0","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"2. 计算机是如何识别图片 图片的构成的基础单位像素，像素越大像素点越多。我们通常说的『图片分辨率』其实是指『像素数』（pixel count），通常表达为横向多少个像素x纵向多少个像素这样。像 480x800 这样的表述其实本来应该叫做尺寸（dimensions）的，但是因为数字图片并没有物理的长宽的概念，叫做尺寸反而可能会引起误解。数字图片的『宽』(width) 和『高』(height) 并非物理意义的长度单位，而是在两个维度上图片包含的像素个数。比如 480x800 这样的图片是由横向 480 个像素、纵向 800 个像素（合计 384 000 个像素点）构成的。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:0","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"最简单的图像–二值图像 只有黑白。黑色代表前景色，白色代表背景色。Pytorch中MNIST手写数据集就是二值图像通道数为1。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:1","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"二值图像在计算机中的表示 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:2","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"灰度图形在计算机中的表示 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:3","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"彩色图像在计算机中的表示 颜色是我们对到达视网膜的各种频率的光的感觉。我们的视网膜有三种颜色感光视锥细胞，负责接收不同频率的光。这些感光器分类分别对应于红、绿和蓝三种颜色。人眼可以觉察的其他颜色都能由这三种颜色混合而成。这也是日常中最常见的颜色图。RGB三原色共同组成了任意色值像素。 以下为一些RGB像素值组成的颜色，也就是一个像素代表三个值（R， G， B） 彩色图像在pytorch也就是所谓的三通道Chanel就等于3。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:4","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"利用numpy读取图片矩阵 图片样例： from PIL import Image import numpy as np def read_img(img_name): img = Image.open(img_name) # 将读取的图像变为numpy矩阵 np_img = np.array(img) # (224, 224, 3) \"\"\" 将3维变为4维矩阵，可以用reshape去做变换， 因为只有一张图片，可以加一个数组，然后让它封装在一个列表中， 它就会把列表的这一维也加上去，列表的这一维就是1. \"\"\" np_img = np.asarray([np_img], dtype=np.uint8) # (1, 224, 224, 3) return np_img im = read_img('1.jpg') print(type(im)) # \u003cclass 'numpy.ndarray'\u003e print(im.dtype) # uint8 print(im.shape) # (1, 499, 500, 3) print(im) # 得到图片在计算机中表示的三维数组 -----------代表一个三维数组，中间省略大部分----------- [[[[245 82 37] [245 82 37] [245 82 37] ... [129 169 39] [168 201 99] [230 255 170]] [[245 82 37] [245 82 37] [245 82 37] ... [129 169 39] [168 201 99] [230 255 170]] [[245 82 37] [245 82 37] [245 82 37] ... [129 169 39] [168 201 99] [230 255 170]] ... [[ 3 166 239] [ 3 166 239] [ 3 166 239] ... [231 189 55] [242 211 98] [255 238 135]] [[ 3 166 239] [ 3 166 239] [ 3 166 239] ... [231 189 55] [242 211 98] [255 238 135]] [[ 3 166 239] [ 3 166 239] [ 3 166 239] ... [231 189 55] [242 211 98] [255 238 135]]]] # 输出第一排前5个像素点 print(im[0][0][0:5]) [[245 82 37] [245 82 37] [245 82 37] [245 82 37] [245 82 37]] ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:5","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"3. CNN卷积网络 CNN：Convolutional Neural Network（卷积神经网络） ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:0","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"发展史 卷积神经网络 (Convolutional Neural Network, CNN) 是一种目前广泛用于图像，自然语言处理等领域的深度神经网络模型。1998 年，Lecun 等人 1 提出了一种基于梯度的反向传播算法用于文档的识别。在这个神经网络中，卷积层 (Convolutional Layer) 扮演着至关重要的角色。 随着运算能力的不断增强，一些大型的 CNN 网络开始在图像领域中展现出巨大的优势，2012 年，Krizhevsky 等人 2 提出了 AlexNet 网络结构，并在 ImageNet 图像分类竞赛 3 中以超过之前 11% 的优势取得了冠军。随后不同的学者提出了一系列的网络结构并不断刷新 ImageNet 的成绩，其中比较经典的网络包括：VGG (Visual Geometry Group) 4，GoogLeNet 5 和 ResNet 6。 CNN 在图像分类问题上取得了不凡的成绩，同时一些学者也尝试将其应用在图像的其他领域，例如：物体检测 789，语义分割 10，图像摘要 11，行为识别 12 等。除此之外，在非图像领域 CNN 也取得了一定的成绩 13。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:1","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"模型原理 下图为 Lecun 等人提出的 LeNet-5 的网络架构： 下面我们针对 CNN 网络中的不同类型的网络层逐一进行介绍。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:2","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"输入层 LeNet-5 解决的手写数字分类问题的输入为一张 32x32 像素的灰度图像 (Gray Scale)。日常生活中计算机常用的图像的表示方式为 RGB，即将一张图片分为红色通道 (Red Channel)，绿色通道 (Green Channel) 和蓝色通道 (Blue Channel)，其中每个通道的每个像素点的数值范围为 [0,255]。灰度图像表示该图片仅包含一个通道，也就是不具备彩色信息，每个像素点的数值范围同 RGB 图像的取值范围相同。 因此，一张图片在计算机的眼里就是一个如下图所示的数字矩阵 (示例图片来自于 MNIST 数据集： 在将图像输入到 CNN 网络之前，通常我们会对其进行预处理，因为每个像素点的最大取值为 255，因此将每个像素点的值除以 255 则可以将其归一化到 [0,1] 的范围。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:3","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"卷积层 第一次卷积计算之后的结果 在了解卷积层之前，让我们先来了解一下什么是卷积？ 下图形象的刻画了利用一个 3x3 大小的卷积核的整个卷积计算过程： 一些预设的卷积核对于图片可以起到不同的滤波器效果，例如下面 4 个卷积核分别会对图像产生不同的效果：不改变，边缘检测，锐化和高斯模糊。 对 lena 图片应用这 4 个卷积核，变换后的效果如下 (从左到右，从上到下)： 在上面整个计算卷积的动图中，我们不难发现，利用 3x3 大小 (我们一般将这个参数称之为 kernel_size，即卷积核的大小，其可以为一个整数表示长宽大小相同，也可以为两个不同的整数) 的卷积核对 5x5 大小的原始矩阵进行卷积操作后，结果矩阵并没有保持原来的大小，而是变为了 (5-(3-1))x(5-(3-1)) (即 3x3) 大小的矩阵。这就需要引入 CNN 网络中卷积层的两个常用参数 padding 和 strides。 padding 是指是否对图像的外侧进行补零操作，其取值一般为 VALID 和 SAME 两种。VALID 表示不进行补零操作，对于输入形状为 (x,y) 的矩阵，利用形状为 (m,n) 的卷积核进行卷积，得到的结果矩阵的形状则为 (x−m+1,y−n+1)。 strides 是指进行卷积操作时，每次卷积核移动的步长。示例中，卷积核在横轴和纵轴方向上的移动步长均为 1，除此之外用于也可以指定不同的步长。移动的步长同样会对卷积后的结果的形状产生影响。 除此之外，还有另一个重要的参数 filters，其表示在一个卷积层中使用的卷积核的个数。在一个卷积层中，一个卷积核可以学习并提取图像的一种特征，但往往图片中包含多种不同的特征信息，因此我们需要多个不同的卷积核提取不同的特征。下图 15 是一个利用 4 个不同的卷积核对一张图像进行卷积操作的示意图： 上面我们都是以一个灰度图像 (仅包含 1 个通道) 为示例进行的讨论，那么对于一个 RGB 图像 (包含 3 个通道)，相应的，卷积核也是一个 3 维的形状，如所示： ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:4","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"池化层 池化层 是一个利用 池化函数 (pooling function) 对网络输出进行进一步调整的网络层。池化函数使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。常用的池化函数包括最大池化 (max pooling) 函数 (即给出邻域内的最大值) 和平均池化 (average pooling) 函数 (即给出邻域内的平均值) 等。但无论选择何种池化函数，当对输入做出少量平移时，池化对输入的表示都近似 不变 (invariant)。局部平移不变性 是一个很重要的性质，尤其是当我们关心某个特征是否出现而不关心它出现的位置时。 池化层同卷积层类似，具有三个比较重要的参数：pool_size，strides 和 padding，分别表示池化窗口的大小，步长以及是否对图像的外侧进行补零操作。下图 是一个 pool_size=3，strides=3，padding='valid' 的最大池化过程示例： 池化层同时也能够提高网络的计算效率，例如上图中在横轴和纵轴的步长均为 3，经过池化后，下一层网络节点的个数降低至前一层的 13×3=19。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:5","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"激活函数(修正线性单元) ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:6","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"全连接层 全链接层 (Fully-connected or Dense Layer) 的目的就是将我们最后一个池化层的输出连接到最终的输出节点上。例如，最后一个池化层的输出大小为 [5×5×16]，也就是有 5×5×16=400 个节点，对于手写数字识别的问题，我们的输出为 0 至 9 共 10 个数字，采用 one-hot 编码的话，输出层共 10 个节点。例如在 LeNet 中有 2 个全连接层，每层的节点数分别为 120 和 84，在实际应用中，通常全连接层的节点数会逐层递减。需要注意的是，在进行编码的时候，第一个全连接层并不是直接与最后一个池化层相连，而是先对池化层进行 flatten 操作，使其变成一个一维向量后再与全连接层相连。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:7","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"输出层 输出层根据具体问题的不同会略有不同，例如对于手写数字识别问题，采用 one-hot 编码的话，输出层则包含 10 个节点。对于回归或二分类问题，输出层则仅包含 1 个节点。当然对于二分类问题，我们也可以像多分类问题一样将其利用 one-hot 进行编码，例如 [1,0] 表示类型 0，[0,1] 表示类型 1。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:8","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"卷积算力 一长800x600的彩色图片共1440000个像素点，好三个3x3的卷机核取计算大概需要1300万次乘法和1200次加法。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:9","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"通用步骤 卷积 -» 非线性激活 -» 池化 == 降维 多层神经网络 重复卷积、非线性激活、池化，运算量也不断增大 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:10","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"超参数 训练之前定义的参数：卷积核尺寸，卷积核数目。池化步长，全连接数量。 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:11","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"4 MNIST数据集PytorchCNN训练 # mnist 训练集 # 1.导入训练包 import numpy as np import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms from torch.utils.data import DataLoader import cv2 # 2. 定义超参数 BATCH_SIZE = 16 # 每次批处理的数据 DEVICE = torch.device(\"cuda\" if torch.cuda.is_available() else 'cpu') # 是否使用GPU EPOCHS = 10 # 训练轮次 # 3 构建pipleline，对图形做处理 pipleline = transforms.Compose([ transforms.ToTensor(), # 图片转化维张量 transforms.Normalize((0.1307,), (0.3081,)) # 正则化，过拟合时候降低复制度 ]) # 4 下载加载数据 # 下载数据集 train_set = datasets.MNIST(\"./data\", train=True, download=True, transform=pipleline) test_set = datasets.MNIST(\"./data\", train=False, download=False, transform=pipleline) # 加载数据集 train_loader = DataLoader(train_set, batch_size=BATCH_SIZE, shuffle=True) test_loader = DataLoader(test_set, batch_size=BATCH_SIZE, shuffle=True) # 5 构建神经网络 class Network(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(1, 10, 5) # 1图片通道，10：输出通道， 5 卷积核大小 self.conv2 = nn.Conv2d(10, 20, 3) # 10输入通道，20：输出通道， 3 卷积核大小 self.fce1 = nn.Linear(20 * 10 * 10, 500) # 20 * 10 * 10 输入通道， 500：输出通道 self.fce2 = nn.Linear(500, 10) # 500 输入通道， 10：输出通道 def forward(self, x): \"\"\"前向传播\"\"\" input_size = x.size(0) x = self.conv1(x) # 输入：batch*1*28*28 输出batch*10*24*24 24等于图片像素-卷积核大小+1 # 非线性激活 x = F.relu(x) # shape不变 输出 batch*10*24*24 # 池化 x = F.max_pool2d(x, 2, 2) # 2步长，2池化核心大小 输入batch*10*24*24 输出batch*10*12*12 x = self.conv2(x) # 输入batch*10*12*12 输出batch*20*10*10 10等于图片像素-卷积核大小+1 # 非线性激活 x = F.relu(x) # 拉伸 x = x.view(input_size, -1) # -1 自动计算维度 20*10*10 = 2000 # 全连接 x = self.fce1(x) # 输入：batch*2000 输出batch*500 x = F.relu(x) x = self.fce2(x) # 输入：batch*500 输出batch*10 # 损失函数 output = F.log_softmax(x, dim=1) # 计算分类后， 每个数字的概率值, 得到损失函数 return output # 6 定义优化器 model = Network().to(DEVICE) optimizer = optim.Adam(model.parameters()) # Adam 优化器 # 7 定义训练方法 def train_model(model, device, train_loader, optimizer, epoch): # 模型训练 model.train() for batch_index, (data, target) in enumerate(train_loader): # 部署到devices data, target = data.to(device), target.to(device) # 初始化梯度 optimizer.zero_grad() # 训练后的结果 output = model(data) # 交叉墒， 计算损失 loss = F.cross_entropy(output, target) # 真是值和目标值 # 找到概率值最大的下标 pred = output.argmax(dim=1) # 反向传播 loss.backward() # 参数优化 optimizer.step() if batch_index % 3000 == 0: print(\"Train Epoch : {} \\tLoss : {:.6f}loss\".format(epoch, loss.item())) # 8 定义测试方法 def test_model(model, device, test_loader): # 模型验证 model.eval() # 正确率 correct = 0.0 # 测试损失 test_loss = 0.0 with torch.no_grad(): # 不会计算梯度和反向传播 for data, target in test_loader: # 部署到DEVICE data, target = data.to(device), target.to(device) # 测试数据 output = model(data) # 计算测试损失 test_loss += F.cross_entropy(output, target).item() # 找到概率值最大的下标 pred = output.argmax(dim=1) # 累计正确的值 correct += pred.eq(target.view_as(pred)).sum().item() # 平均损失值 test_loss /= len(test_loader.dataset) print( \"Test Average loss : {:.4f} Accuracy : {:.3f}\".format(test_loss, 100.0 * correct / len(test_loader.dataset))) # 9 定义调用方法 for epoch in range(1, EPOCHS + 1): train_model(model, DEVICE, train_loader, optimizer, epoch) test_model(model, DEVICE,test_loader) ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:4:0","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"训练结果 准确率98% Train Epoch : 1 Loss : 2.311116loss Train Epoch : 1 Loss : 0.004861loss Test Average loss : 0.0031 Accuracy : 98.450 Train Epoch : 2 Loss : 0.122852loss Train Epoch : 2 Loss : 0.485804loss Test Average loss : 0.0026 Accuracy : 98.900 Train Epoch : 3 Loss : 0.004043loss Train Epoch : 3 Loss : 0.000185loss Test Average loss : 0.0031 Accuracy : 98.460 Train Epoch : 4 Loss : 0.000044loss Train Epoch : 4 Loss : 0.001558loss Test Average loss : 0.0029 Accuracy : 98.800 Train Epoch : 5 Loss : 0.000024loss Train Epoch : 5 Loss : 0.005477loss Test Average loss : 0.0028 Accuracy : 98.860 Train Epoch : 6 Loss : 0.000048loss Train Epoch : 6 Loss : 0.000001loss Test Average loss : 0.0029 Accuracy : 98.940 Train Epoch : 7 Loss : 0.000998loss Train Epoch : 7 Loss : 0.000263loss Test Average loss : 0.0037 Accuracy : 98.940 Train Epoch : 8 Loss : 0.040684loss Train Epoch : 8 Loss : 0.007434loss Test Average loss : 0.0039 Accuracy : 98.700 Train Epoch : 9 Loss : 0.000308loss Train Epoch : 9 Loss : 0.000000loss Test Average loss : 0.0026 Accuracy : 99.040 Train Epoch : 10 Loss : 0.000000loss Train Epoch : 10 Loss : 0.000000loss Test Average loss : 0.0059 Accuracy : 98.710 ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:4:1","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"参考 人脸识别啥原理？人工智能（二）卷积神经网络 计算机视觉——图像的表示 卷积神经网络 (Convolutional Neural Network, CNN) How Convolutional Neural Networks work ","date":"2021-10-14","objectID":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:5:0","tags":["CNN"],"title":"CNN卷积神经网络","uri":"/posts/cnn%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["深度学习"],"content":"Createitv","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"什么是 Pytorch ？ 可以把 Pytorch 当做 Numpy 的替代方案使用，做科学计算，而且更强大。 做 AI 任务的模型建模、训练、部署等。这方面唯一能与其比肩的是 Google 家的 Tensorflow。 本文是对 Pytorch 非常简短的一个介绍，目录如下： Tensor 的创建与操作，cuda 加速计算。 Pytorch 的自动微分功能。 Tensor 创建与操作 ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:0:0","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"Tensor 的创建 创建一个未初始化的、形状为 (5,3) 的空 tensor。 x = torch.empty(5, 3) print(x) tensor([[1.0102e-38, 9.0919e-39, 1.0102e-38], [8.9082e-39, 8.4489e-39, 9.6429e-39], [8.4490e-39, 9.6429e-39, 9.2755e-39], [1.0286e-38, 9.0919e-39, 8.9082e-39], [9.2755e-39, 8.4490e-39, 1.0194e-38]]) 创建一个随机初始化，形状为 (5,3) 的 tensor。 x = torch.rand(5, 3) print(x) tensor([[0.4133, 0.0885, 0.0503], [0.6771, 0.5543, 0.8236], [0.3047, 0.1217, 0.4441], [0.6269, 0.6820, 0.4217], [0.5631, 0.8517, 0.8708]]) 创建一个0填充的、形状为 (5,3) 的 tensor。 x = torch.zeros(5, 3, dtype=torch.long) print(x) tensor([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]) 直接从列表创建一个 tensor： x = torch.tensor([5.5, 3]) print(x) tensor([5.5000, 3.0000]) 在现有 tensor 的基础上新建一个全1 tensor，默认情况下新的 tensor 会继承已有 tensor 的属性，比如形状、数据类型等，当然也可以手动指定。： x = x.new_ones(5, 3, dtype=torch.double) print(x) tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) 生成一个与现有 tensor 一样形状的随机 tensor，且数据类型覆盖为 torch.float： x = torch.randn_like(x, dtype=torch.float) print(x) tensor([[ 0.9629, 0.0349, 0.5597], [-2.1172, 1.1874, -0.1596], [ 0.6841, -0.6172, -0.4732], [ 0.0468, -0.3634, 1.1014], [ 0.6064, 0.1740, 0.2344]]) 查看 tensor 的形状 ： print(x.size()) torch.Size([5, 3]) tensor.size方法返回的是一个tuple对象，可以执行tuple的各种操作。 ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:1:0","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"tensor 的基本操作 详细内容可参考官方文档 ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:0","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"1. 创建 torch.rand* 类随机生成 tensor 方法。 torch.rand() torch.rand_like() torch.randn() torch.randn_like() torch.randint() torch.randint_like() torch.randperm() torch.empty() 从其他数据源创建 torch.tensor() torch.from_numpy() torch.full() torch.range() torch.linspace() torch.eye() ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:1","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"2. 索引、切片、合并等转换 # 按指定维度拼接 tensor torch.cat() # 按指定维度将一个 tensor 分割为几个小块 torch.chunk() # 按照深度方向（第三维）将多个 tensor 拼接，若tensor不足三维，则先转为3维 tensor 再行拼接。 torch.dstack() # 将多个 tensor 按第1维进行拼接 torch.hstack() # 按指定维度进行索引查询 torch.index_select() # 根据一个 BoolTensor 进行 mask 查询 torch.masked_select() # 调换 tensor 维度 torch.movedim() # 返回 tensor 中非0值的索引 torch.nonzero() # 改变 tensor 形状 torch.reshape() # 按照指定维度及指定大小将 tensor 分割为几块 torch.split() # 去除所有 tensor 中大小为1的维度，也可以指定哪个维度。 torch.squeeze() # 按照指定维度拼接多个 tensor torch.stack() # tensor 转置 torch.t() # 根据给定的索引从已有 tensor 中抽取出一个新的 tensor。 torch.take() # 将 tensor 的指定两个维度进行互换 torch.transpose() # 在指定地方增加 tensor 维度 torch.unsqueeze() # 类似 dstack，只是是在第二个维度进行拼接 torch.vstack() # 对 tensor 中每个元素根据条件判断如何返回 torch.where() ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:2","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"3. 随机采样机器参数设置 # 设置非确定性随机数的随机种子 torch.seed # 设置生成随机数的随机种子 torch.manual_seed # 查看初始化的随机种子，为 `long` 类型 torch.initial_seed # 查看随机数生成器状态 torch.get_rng_state # 设置随机数生成器状态 torch.set_rng_state ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:3","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"4. 序列化与反序列化 # 对 Pytorch 中的对象进行序列化保存和读取 torch.save() torch.load() ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:4","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"5. 并行计算 # 获取和设置 CPU 并行操作时的线程数 torch.get_num_threads torch.set_num_threads # 获取和设置 CPU 上的互操作并行的线程数 torch.get_num_interop_threads torch.set_num_interop_threads ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:5","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"6. 梯度控制 有多重方法可以控制 tensor 是否计算梯度 ： x = torch.zeros(1, requires_grad=True) with torch.no_grad(): y = x * 2 print(y.requires_grad) is_train = False with torch.set_grad_enabled(is_train): y = x * 2 print(y.requires_grad) torch.set_grad_enabled(True) y = x * 2 print(y.requires_grad) False False True ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:6","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["深度学习"],"content":"7. 数学操作 pytorch 支持大部分常见的数学操作，这里不详细列举，详见官方文档 # Pointwise 操作 torch.abs torch.clip torch.cos torch.sin torch.div torch.exp torch.pow torch.log torch.sigmoid # Reduction 操作 torch.argmax torch.argmin torch.max torch.dist torch.mean torch.norm torch.count_nonzero # 比较操作 torch.allclose torch.argsort torch.eq torch.equal torch.ge torch.gt torch.isinf torch.isfinite torch.isnan torch.isreal torch.isneginf torch.sort torch.topk # 光谱操作及其他操作 ...... Pytorch 的自动微分功能 Pytorch 具备自动微分功能。 requires_grad 这个参数表示这个 tensor是否需要计算梯度。 x = torch.ones(2, 2, requires_grad=True) print(x) tensor([[1., 1.], [1., 1.]], requires_grad=True) grad_fn 指当前这个 tensor 是通过哪个函数得来的，在链式求导时会按照此函数进行计算。一般来讲除了用户自己创建的 tensor 外，如果是 pytorch 内置函数所生成的 tensor 都会有 grad_fn。 ： y = x + 2 print(y) print(y.grad_fn) z = y * y * 3 out = z.mean() print(z, out) tensor([[3., 3.], [3., 3.]], grad_fn=\u003cAddBackward0\u003e) \u003cAddBackward0 object at 0x000001CEE32753C8\u003e tensor([[27., 27.], [27., 27.]], grad_fn=\u003cMulBackward0\u003e) tensor(27., grad_fn=\u003cMeanBackward0\u003e) backward \u0026 grad backward 方法用于计算梯度，通过链式求导法则计算好的梯度就存在 tensor 的 grad 属性中。 ： out.backward() print(x.grad) tensor([[4.5000, 4.5000], [4.5000, 4.5000]]) with torch.no_grad 通过这种方法，可以避免在计算中的梯度计算 ： print(x.requires_grad) print((x ** 2).requires_grad) with torch.no_grad(): print((x ** 2).requires_grad) True True False detach 通过 detach 方法避免梯度计算 ： print(x.requires_grad) y = x.detach() print(y.requires_grad) print(x.eq(y).all()) True False tensor(True) requires_grad_ 设置 requires_grad_ 属性可直接更改 tensor 梯度计算配置。 ： a = torch.randn(2, 2) a = ((a * 3) / (a - 1)) print(a.requires_grad) a.requires_grad_(True) print(a.requires_grad) b = (a * a).sum() print(b.grad_fn) False True \u003cSumBackward0 object at 0x000001CEE32753C8\u003e ","date":"2021-10-13","objectID":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/:2:7","tags":["pytorch"],"title":"10分钟了解pytorch","uri":"/posts/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3pytorch/"},{"categories":["罗永浩"],"content":"Createitv","date":"2021-10-05","objectID":"/posts/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/","tags":["我的奋斗"],"title":"我的奋斗","uri":"/posts/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/"},{"categories":["罗永浩"],"content":" 有些鸟来到世间，是为了做它该做的事情的，而不是为了躲子弹的。 时至今天，对我影响最大的作家有两位，其一是路遥，其二罗永浩。后者不能称为严格意义下的作家，不够也算勉强。他至今唯一在版且绝版刊物就是这一版《我的奋斗》。前者获得过矛盾文学奖，后者到前几年还是人人喊打，时过境迁名声竟然也转危为安。前几年舆论氛围喜欢老罗是一件不可思议的事情，现在不知道瞧不上是一件不可思议的事情。三十年河东，三十年河西。 说下这本书吧。这是一本名字很怪异的书，倒不是因为这四个字很怪异，而是希特勒曾经也写过一本书名一样的书，作为一个正常人肯定不会继续重名这样一本书的，很显然，这个丑陋的胖子的思维不是正常的。 正式提起这个人之前，我想先侃侃牛博网。和菜头、王小山、韩寒、柴静、梁文道、连岳等知名作家都是牛博网的写者，那是一个神奇的时代，榕树下、新浪城市聊天室、碧海银沙。这些都是暴露年龄的词，而不是今天的weibo，TikTok等卖奶嘴的贩子。那个时候的牛博网写文章、吵架、输出思想。颇有些百家争鸣的意味。当时，一颗叫“异见”、另一个叫“思考”的种子，由他们在牛博网用户的心里播下。如今ZZSC没有一件事可以脱口而出。对比今天今天的菜头，连岳所写的也不过是些奶头文，投喂嗷嗷待哺的读者。这些难道就真的是你们想写的？还是这个年代需要的？我也承认看起来很爽，这种文章每天只用花你们几分钟吧，然后高枕无忧。 谈谈这本书吧： ","date":"2021-10-05","objectID":"/posts/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/:0:0","tags":["我的奋斗"],"title":"我的奋斗","uri":"/posts/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/"},{"categories":["罗永浩"],"content":"摘录 因为在我们这个国家，由于某些特殊原因，大家从小就被剥夺了思考能力。 大部分读者的评论没有价值，但是大部分读者的存在有价值。 彪悍的人生不需要解释 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 这是一个最好的时代，也是一个最坏的时代； 这是一个智慧的年代，这是一个愚蠢的年代； 这是一个信任的时期，这是一个怀疑的时期。 这是一个光明的季节，这是一个黑暗的季节； 人们面前应有尽有，人们面前一无所有； 人们正踏上天堂之路，人们正走向地狱之门。 有些人喜欢老罗，也有不喜欢老罗。大部分成长环境所导致的，如果你不喜欢，那么你很幸运。 慢慢也没那么以前那么喜欢老罗了，因为我看到了自己。 ","date":"2021-10-05","objectID":"/posts/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/:0:1","tags":["我的奋斗"],"title":"我的奋斗","uri":"/posts/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/"},{"categories":["python"],"content":"Createitv","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"参考 http://www.ruanyifeng.com/blog/2016/07/yaml.html 菜鸟yaml教程 ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:1:0","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"什么是yaml？ YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。yaml也是主流Dockerfile和workflow的配置格式。 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲。 ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:0","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"基本语法 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#‘表示注释 ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:1","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"数据类型 YAML 支持以下几种数据类型： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:2","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"YAML 对象 对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。 也可以使用 key:{key1: value1, key2: value2, …}。 还可以使用缩进表示层级关系； key: child-key: value child-key2: value2 较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value： ? - complexkey1 - complexkey2 : - complexvalue1 - complexvalue2 意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2] ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:3","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"YAML 数组 以 - 开头的行表示构成一个数组： - A - B - C YAML 支持多维数组，可以使用行内表示： key: [value1, value2, ...] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 - - A - B - C 一个相对复杂的例子： companies: - id: 1 name: company1 price: 200W - id: 2 name: company2 price: 500W 意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。 数组也可以使用流式(flow)的方式表示： companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}] ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:4","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"复合结构 数组和对象可以构成复合结构，例： languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 转换为 json 为： { languages: [ 'Ruby', 'Perl', 'Python'], websites: { YAML: 'yaml.org', Ruby: 'ruby-lang.org', Python: 'python.org', Perl: 'use.perl.org' } } ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:5","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"纯量 纯量是最基本的，不可再分的值，包括： 字符串 布尔值 整数 浮点数 Null 时间 日期 使用一个例子来快速了解纯量的基本使用： boolean: - TRUE #true,True都可以 - FALSE #false，False都可以 float: - 3.14 - 6.8523015e+5 #可以使用科学计数法 int: - 123 - 0b1010_0111_0100_1010_1110 #二进制表示 null: nodeName: 'node' parent: ~ #使用~表示null string: - 哈哈 - 'Hello world' #可以使用双引号或者单引号包裹特殊字符 - newline newline2 #字符串可以拆成多行，每一行会被转化成一个空格 date: - 2018-02-17 #日期必须使用ISO 8601格式，即yyyy-MM-dd datetime: - 2018-02-17T15:02:31+08:00 #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:6","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"引用 \u0026 锚点和 ***** 别名，可以用来引用: defaults: \u0026defaults adapter: postgres host: localhost development: database: myapp_development \u003c\u003c: *defaults test: database: myapp_test \u003c\u003c: *defaults 相当于: defaults: adapter: postgres host: localhost development: database: myapp_development adapter: postgres host: localhost test: database: myapp_test adapter: postgres host: localhost \u0026 用来建立锚点（defaults），« 表示合并到当前数据，***** 用来引用锚点。 下面是另一个例子: - \u0026showell Steve - Clark - Brian - Oren - *showell 转为 JavaScript 代码如下: [ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ] 多行字符串可以使用|保留换行符，也可以使用\u003e折叠换行。 this:|Foo Barthat:\u003eFoo Bar 转为 JavaScript 代码如下。 { this: 'Foo\\nBar\\n', that: 'Foo Bar\\n' } +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 s1:|Foos2:|+Foos3:|-Foo 转为 JavaScript 代码如下。 { s1: 'Foo\\n', s2: 'Foo\\n\\n\\n', s3: 'Foo' } ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:2:7","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"文档举例 ---# document start# Comments in YAML look like this.################# SCALAR TYPES ################## Our root object (which continues for the entire document) will be a map,# which is equivalent to a dictionary, hash or object in other languages.key:valueanother_key:Another value goes here.a_number_value:100scientific_notation:1e+12# The number 1 will be interpreted as a number, not a boolean. if you want# it to be interpreted as a boolean, use trueboolean:truenull_value:nullkey with spaces:value# Notice that strings don't need to be quoted. However, they can be.however:'A string, enclosed in quotes.''Keys can be quoted too.':\"Useful if you want to put a ':' in your key.\"single quotes:'have ''one'' escape pattern'double quotes:\"have many: \\\", \\0, \\t, \\u263A, \\x0d\\x0a == \\r\\n, and more.\"# UTF-8/16/32 characters need to be encodedSuperscript two:\\u00B2# Multiple-line strings can be written either as a 'literal block' (using |),# or a 'folded block' (using '\u003e').literal_block:|This entire block of text will be the value of the 'literal_block' key, with line breaks being preserved. The literal continues until de-dented, and the leading indentation is stripped. Any lines that are 'more-indented' keep the rest of their indentation - these lines will be indented by 4 spaces.folded_style:\u003eThis entire block of text will be the value of 'folded_style', but this time, all newlines will be replaced with a single space. Blank lines, like above, are converted to a newline character. 'More-indented' lines keep their newlines, too - this text will appear over two lines.##################### COLLECTION TYPES ###################### Nesting uses indentation. 2 space indent is preferred (but not required).a_nested_map:key:valueanother_key:Another Valueanother_nested_map:hello:hello# Maps don't have to have string keys.0.25:a float key# Keys can also be complex, like multi-line objects# We use ? followed by a space to indicate the start of a complex key.?|This is a key that has multiple lines:and this is its value# YAML also allows mapping between sequences with the complex key syntax# Some language parsers might complain# An example? - Manchester United- Real Madrid:[2001-01-01,2002-02-02]# Sequences (equivalent to lists or arrays) look like this# (note that the '-' counts as indentation):a_sequence:- Item 1- Item 2- 0.5# sequences can contain disparate types.- Item 4- key:valueanother_key:another_value-- This is a sequence- inside another sequence- - - Nested sequence indicators- can be collapsed# Since YAML is a superset of JSON, you can also write JSON-style maps and# sequences:json_map:{\"key\": \"value\"}json_seq:[3,2,1,\"takeoff\"]and quotes are optional:{key:[3,2,1,takeoff]}######################## EXTRA YAML FEATURES ######################### YAML also has a handy feature called 'anchors', which let you easily duplicate# content across your document. Both of these keys will have the same value:anchored_content:\u0026anchor_nameThis string will appear as the value of two keys.other_anchor:*anchor_name# Anchors can be used to duplicate/inherit propertiesbase:\u0026basename:Everyone has same name# The regexp \u003c\u003c is called Merge Key Language-Independent Type. It is used to# indicate that all the keys of one or more specified maps should be inserted# into the current map.foo:\u003c\u003c:*baseage:10bar:\u003c\u003c:*baseage:20# foo and bar would also have name: Everyone has same name# YAML also has tags, which you can use to explicitly declare types.explicit_string:!!str0.5# Some parsers implement language specific tags, like this one for Python's# complex number type.python_complex_number:!!python/complex1+2j# We can also use yaml complex keys with language specific tags?!!python/tuple[5,7]:Fifty Seven# Would be {(5, 7): 'Fifty Seven'} in Python##################### EXTRA YAML TYPES ###################### Strings and numbers aren't the only scalars that YAML can understand.# ISO-formatted date and datetime literals are also parsed.datetime:2001-12-15T02:59:43.1Zdatetime_wi","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:3:0","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["python"],"content":"python操作yaml ","date":"2021-10-03","objectID":"/posts/yaml%E4%BB%8B%E7%BB%8D/:4:0","tags":["yaml"],"title":"Yaml介绍","uri":"/posts/yaml%E4%BB%8B%E7%BB%8D/"},{"categories":["云"],"content":"Createitv","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"Serverless 架构即“无服务器”架构，它是一种全新的架构方式，是云计算时代一种革命性的架构模式。与云计算、容器和人工智能一样，Serverless 是这两年IT行业的一个热门词汇，它在各种技术文章和论坛上都有很高的曝光度。 目前行业可能更多处在容器 Docker+Kubernetes, 利用 IaaS、PaaS和SaaS 来快速搭建部署应用 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"什么是Serverless Serverless 圈内俗称为“无服务器架构”，Serverless 不是具体的一个编程框架、类库或者工具。简单来说，Serverless 是一种软件系统架构思想和方法，它的核心思想是用户无须关注支撑应用服务运行的底层主机。这种架构的思想和方法将对未来软件应用的设计、开发和运营产生深远的影响。 所谓“无服务器”，并不是说基于 Serverless 架构的软件应用不需要服务器就可以运行，其指的是用户无须关心软件应用运行涉及的底层服务器的状态、资源（比如 CPU、内存、磁盘及网络）及数量。软件应用正常运行所需要的计算资源由底层的云计算平台动态提供。 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"Serverless的技术实现 Serverless 的核心思想是让作为计算资源的服务器不再成为用户所关注的一种资源。其目的是提高应用交付的效率，降低应用运营的工作量和成本。以 Serverless 的思想作为基础实现的各种框架、工具及平台，是各种 Serverless 的实现（Implementation）。Serverless不是一个简单的工具或框架。用户不可能简单地通过实施某个产品或工具就能实现 Serverless 的落地。但是，要实现 Serverless 架构的落地，需要一些实实在在的工具和框架作为有力的技术支撑和基础。 随着 Serverless 的日益流行，这几年业界已经出现了多种平台和工具帮助用户进行 Serverless 架构的转型和落地。目前市场上比较流行的 Serverless 工具、框架和平台 有： AWS Lambda，最早被大众所认可的 Serverless 实现。 Azure Functions，来自微软公有云的 Serverless 实现。 OpenWhisk，Apache 社区的开源 Serverless 框架。 Kubeless，基于 Kubernetes 架构实现的开源 Serverless 框架。 Fission，Platform9 推出的开源 Serverless 框架。 OpenFaaS，以容器技术为核心的开源 Serverless 框架。 Fn，来自 Oracle 的开源 Serverless 框架，由原 Iron Functions 团队开发。 列举的 Serverless 实现有的是公有云的服务，有的则是框架工具，可以被部署在私有数据中心的私有云中（私有云 Serverless 框架 OpenWhisk、Fission 及 OpenFaaS）。每个 Serverless 服务或框架的实现都不尽相同，都有各自的特点。 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"FaaS与BaaS IT是一个永远都不消停的行业，在这个行业里不断有各种各样新的名词和技术诞生，云计算（Cloud Computing）的出现是21世纪IT业界最重大的一次变革。云计算的发展从基础架构即服务（Infrastructure as a Service， IaaS），平台即服务（Platform as a Service，PaaS），软件即服务（Software as a Service，SaaS），慢慢开始演变到函数即服务（Function as a Service，FaaS）以及后台即服务（Backend as a Service，BaaS），Serverless 无服务化。 目前业界的各类 Serverless 实现按功能而言，主要为应用服务提供了两个方面的支持：函数即服务（Function as a Service，FaaS）以及后台即服务（Backend as a Service，BaaS）。 1.FaaS FaaS 提供了一个计算平台，在这个平台上，应用以一个或多个函数的形式开发、运行和管理。FaaS 平台提供了函数式应用的运行环境，一般支持多种主流的编程语言，如 Java、PHP 及 Python 等。FaaS 可以根据实际的访问量进行应用的自动化动态加载和资源的自动化动态分配。大多数 FaaS 平台基于事件驱动（Event Driven）的思想，可以根据预定义的事件触发指定的函数应用逻辑。 目前业界 FaaS 平台非常成功的一个代表就是 AWS Lambda 平台。AWS Lambda 是 AWS 公有云服务的函数式计算平台。通过 AWS Lambda，AWS 用户可以快速地在 AWS 公有云上构建基于函数的应用服务。 2.BaaS 为了实现应用后台服务的 Serverless 化，BaaS（后台即服务）也应该被纳入一个完整的 Serverless 实现的范畴内。通过 BaaS 平台将应用所依赖的第三方服务，如数据库、消息队列及存储等服务化并发布出来，用户通过向 BaaS 平台申请所需要的服务进行消费，而不需要关心这些服务的具体运维。 BaaS 涵盖的范围很广泛，包含任何应用所依赖的服务。一个比较典型的例子是数据库即服务（Database as a Service，DBaaS）。许多应用都有存储数据的需求，大部分应用会将数据存储在数据库中。传统情况下，数据库都是运行在数据中心里，由用户运维团队负责运维。在DBaaS的场景下，用户向 DBaaS 平台申请数据库资源，而不需要关心数据库的安装部署及运维。 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"Serverless的技术特点 为了实现解耦应用和服务器资源，实现服务器资源对用户透明，与传统架构相比，Serverless 架构在技术上有许多不同的特点。 1.按需加载 在 Serverless 架构下，应用的加载（load）和卸载（unload）由 Serverless 云计算平台控制。这意味着应用不总是一直在线的。只有当有请求到达或者有事件发生时才会被部署和启动。当应用空闲至一定时长时，应用会到达或者有事件发生时才会被部署和启动。当应用空闲至一定时长时，应用会被自动停止和卸载。因此应用并不会持续在线，不会持续占用计算资源。 2.事件驱动 Serverless 架构的应用并不总是一直在线，而是按需加载执行。应用的加载和执行由事件驱动，比如HTTP请求到达、消息队列接收到新的信息或存储服务的文件被修改了等。通过将不同事件来源（Event Source）的事件（Event）与特定的函数进行关联，实现对不同事件采取不同的反应动作，这样可以非常容易地实现事件驱动（Event Driven）架构。 3.状态非本地持久化 云计算平台自动控制应用实例的加载和卸载，且应用和服务器完全解耦，应用不再与特定的服务器关联。因此应用的状态不能，也不会保存在其运行的服务器之上，不能做到传统意义上的状态本地持久化。 4.非会话保持 应用不再与特定的服务器关联。每次处理请求的应用实例可能是相同服务器上的应用实例，也可能是新生成的服务器上的应用实例。因此，用户无法保证同一客户端的两次请求由同一个服务器上的同一个应用实例来处理。也就是说，无法做到传统意义上的会话保持（Sticky Session）。因此，Serverless架构更适合无状态的应用。 5.自动弹性伸缩 Serverless 应用原生可以支持高可用，可以应对突发的高访问量。应用实例数量根据实际的访问量由云计算平台进行弹性的自动扩展或收缩，云计算平台动态地保证有足够的计算资源和足够数量的应用实例对请求进行处理。 6.应用函数化 每一个调用完成一个业务动作，应用会被分解成多个细颗粒度的操作。由于状态无法本地持久化，这些细颗粒度的操作是无状态的，类似于传统编程里无状态的函数。Serverless 架构下的应用会被函数化，但不能说 Serverless 就是 Function as a Service（FaaS）。Serverless 涵盖了 FaaS 的一些特性，可以说 FaaS 是 Serverless 架构实现的一个重要手段。 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"Serverless的应用场景 通过将 Serverless 的理念与当前 Serverless 实现的技术特点相结合，Serverless 架构可以适用于各种业务场景。 1.Web应用 Serverless 架构可以很好地支持各类静态和动态Web应用。如 RESTful API 的各类请求动作（GET、POST、PUT及DELETE等）可以很好地映射成 FaaS 的一个个函数，功能和函数之间能建立良好的对应关系。通过 FaaS 的自动弹性扩展功能，Serverless Web 应用可以很快速地构建出能承载高访问量的站点。 2.移动互联网 Serverless 应用通过 BaaS 对接后端不同的服务而满足业务需求，提高应用开发的效率。前端通过FaaS提供的自动弹性扩展对接移动端的流量，开发者可以更轻松地应对突发的流量增长。在 FaaS 的架构下，应用以函数的形式存在。各个函数逻辑之间相对独立，应用更新变得更容易，使新功能的开发、测试和上线的时间更短。 3.物联网（Internet of Things，IoT） 物联网（Internet of Things，IoT）应用需要对接各种不同的数量庞大的设备。不同的设备需要持续采集并传送数据至服务端。Serverless 架构可以帮助物联网应用对接不同的数据输入源。 4.多媒体处理 视频和图片网站需要对用户上传的图片和视频信息进行加工和转换。但是这种多媒体转换的工作并不是无时无刻都在进行的，只有在一些特定事件发生时才需要被执行，比如用户上传或编辑图片和视频时。通过 Serverless 的事件驱动机制，用户可以在特定事件发生时触发处理逻辑，从而节省了空闲时段计算资源的开销，最终降低了运维的成本。 5.数据及事件流处理 Serverless 可以用于对一些持续不断的事件流和数据流进行实时分析和处理，对事件和数据进行实时的过滤、转换和分析，进而触发下一步的处理。比如，对各类系统的日志或社交媒体信息进行实时分析，针对符合特定特征的关键信息进行记录和告警。 6.系统集成 Serverless 应用的函数式架构非常适合用于实现系统集成。用户无须像过去一样为了某些简单的集成逻辑而开发和运维一个完整的应用，用户可以更专注于所需的集成逻辑，只编写和集成相关的代码逻辑，而不是一个完整的应用。函数应用的分散式的架构，使得集成逻辑的新增和变更更加灵活。 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["云"],"content":"Serverless的局限 世界上没有能解决所有问题的万能解决方案和架构理念。Serverless 有它的特点和优势，但是同时也有它的局限。有的局限是由其架构特点决定的，有的是目前技术的成熟度决定的，毕竟 Serverless 还是一个起步时间不长的新兴技术领域，在许多方面还需要逐步完善。 1.控制力 Serverless 的一个突出优点是用户无须关注底层的计算资源，但是这个优点的反面是用户对底层的计算资源没有控制力。对于一些希望掌控底层计算资源的应用场景，Serverless 架构并不是最合适的选择。 2.可移植性 Serverless 应用的实现在很大程度上依赖于 Serverless 平台及该平台上的 FaaS 和 BaaS 服务。不同IT厂商的 Serverless 平台和解决方案的具体实现并不相同。而且，目前 Serverless 领域尚没有形成有关的行业标准，这意味着用户将一个平台上的 Serverless 应用移植到另一个平台时所需要付出的成本会比较高。较低的可移植性将造成厂商锁定（Vendor Lock-in）。这对希望发展 Serverless 技术，但是又不希望过度依赖特定供应商的企业而言是一个挑战。 3.安全性 在 Serverless 架构下，用户不能直接控制应用实际所运行的主机。不同用户的应用，或者同一用户的不同应用在运行时可能共用底层的主机资源。对于一些安全性要求较高的应用，这将带来潜在的安全风险。 4.性能 当一个 Serverless 应用长时间空闲时将会被从主机上卸载。当请求再次到达时，平台需要重新加载应用。应用的首次加载及重新加载的过程将产生一定的延时。对于一些对延时敏感的应用，需要通过预先加载或延长空闲超时时间等手段进行处理。 5.执行时长 Serverless 的一个重要特点是应用按需加载执行，而不是长时间持续部署在主机上。目前，大部分 Serverless 平台对 FaaS 函数的执行时长存在限制。因此 Serverless 应用更适合一些执行时长较短的作业。 6.技术成熟度 虽然 Serverless 技术的发展很快，但是毕竟它还是一门起步时间不长的新兴技术。因此，目前 Serverless 相关平台、工具和框架还处在一个不断变化和演进的阶段，开发和调试的用户体验还需要进一步提升。Serverless 相关的文档和资料相对比较少，深入了解 Serverless 架构的架构师、开发人员和运维人员也相对较少。 ","date":"2021-10-02","objectID":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:6:0","tags":["Serverless"],"title":"Serverless基础知识","uri":"/posts/serverless%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["冷静"],"content":"Createitv","date":"2021-09-16","objectID":"/posts/%E4%B8%89%E5%8D%81%E5%B2%81%E7%9A%84%E7%94%B7%E4%BA%BA/","tags":[],"title":"三十岁的男人","uri":"/posts/%E4%B8%89%E5%8D%81%E5%B2%81%E7%9A%84%E7%94%B7%E4%BA%BA/"},{"categories":["冷静"],"content":" 一个女性，唯一要警惕的，就是三四十岁的中年大叔男人。仿佛泰坦尼克号要警惕冰山一般。很多像这艘华丽大船一样有远大前程的女生，就是在爱情的处女航上碰上“三十多岁的男人”冰山，成为海床上的寂寞残骸。 二十来岁的男人，一穷二白，在职场与社会上，都是小角色，即使混黑道，也还处于替老大挡子弹的马仔阶段。满嘴大话，身无分文，三餐不继，家徒四壁（还是租来的房子）；偏偏这样的人，脾气一般都还很大，动不动就冲你发飙，让你滚。什么都没有，什么都看不惯，唯一用不完的就是愤怒。他们爱憎分明，基本上还不会骗人，总觉得女朋友多得是，走了一个还有两个在等着，为什么要用骗？用抢就可以了…… 四十来岁的男人，如果不成功，依旧是配角，那么已经显出老态，眼神变得畏缩，说话吞吞吐吐，唯恐哪个字眼得罪人，借着酒劲说的成人笑话，要么就太黄，要么就一点不好笑。开始褪顶，衣着又老土，倾全身所有买件礼物，也超不过五十块钱。他们没有胆去骗女生了，自知之明还是有的，偶尔吃点豆腐，就像过节一样了。这个年龄层有一票自以为成功的男人，由于有钱有势，又有人奉承，精气神倒还都在，只不过再也不屑劳心劳力去骗女生，会直接拍出支票包养一个或若干个情人，相安无事，不吵不闹。 三十来岁的男人，有了一点钱，有了一点阅历，总结了一点情场经验，变得温和，却不失个性；一时失意，总认为来日方长，也不会丧失斗志，偶尔看起来还有落难才子的美感；懂得哄女生了，有耐心听她的唠叨，再不会暴躁咆哮了；又看不起包养这种肉体交易，不忘讲点情调，放长线恋爱个半年一载，也不觉得烦琐，骗不上床，也自认为是柏拉图，有了精神恋爱。若是男人三十多岁得志，那更可怕，皮肤紧绷，肌肉结实，熟悉好的餐馆与咖啡馆，衣着、美食、运动、学问都不露怯，谈吐有趣又不饶舌……他们起心思骗个女生，得手的概率很高。 你也许会说，这样的“三十多岁的男人”有何不好？好，全都好，他们只有两个缺点：一是有了老婆；二是不会和老婆离婚。你和他们不清不楚地纠缠几年以后，往往身心俱疲地退出，那时，你恐怕是个“三十多岁的女人”了，人生当然没有太多损失，还明白了两条道理：一是输给了别人的老婆；二是自己很难再找到合适的人当他的老婆了。 远离“三十多岁的男人”，就像要远离赌博一样，它会让你上瘾，先赢一点小钱，然后输光所有。 祝开心。 连岳 ","date":"2021-09-16","objectID":"/posts/%E4%B8%89%E5%8D%81%E5%B2%81%E7%9A%84%E7%94%B7%E4%BA%BA/:0:0","tags":[],"title":"三十岁的男人","uri":"/posts/%E4%B8%89%E5%8D%81%E5%B2%81%E7%9A%84%E7%94%B7%E4%BA%BA/"},{"categories":["python"],"content":"Createitv","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"为什么出现异步编程 通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕. Mac 用户有时会经历过这种旋转的彩虹光标（常称为沙滩球），操作系统通过这个光标告诉用户：“现在运行的程序正在等待其他的某一件事情完成，才能继续运行，都这么长的时间了，你一定在担心到底发生了什么事情”。 这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是异步编程的出发点。你正在使用的编程环境（就web开发而言，编程环境就是web浏览器）负责为你提供异步运行此类任务的API。 异步技术非常有用，特别是在web编程。当浏览器里面的一个web应用进行密集运算还没有把控制权返回给浏览器的时候，整个浏览器就像冻僵了一样，这叫做**阻塞；**这时候浏览器无法继续处理用户的输入并执行其他任务，直到web应用交回处理器的控制。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:1:0","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"CPU的时间观 我们将一个 2.6GHz 的 CPU 拟人化，假设它执行一条命令的时间，他它感觉上过了一秒钟。CPU是计算机的处理核心，也是最宝贵的资源，如果有浪费CPU的运行时间，导致其利用率不足，那程序效率必然低下（因为实际上有资源可以使效率更高）。 如上图所示，在千兆网上传输2KB数据，CPU感觉过了14个小时，如果是在10M的公网上呢？那效率会低百倍！如果在这么长的一段时间内，CPU只是傻等结果而不能去干其他事情，是不是在浪费CPU的青春？ 浪费“CPU”的时间等于谋财害命。而凶手就是程序猿。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:1:1","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"面临的问题 成本问题 如果一个程序不能有效利用一台计算机资源，那必然需要更多的计算机通过运行更多的程序实例来弥补需求缺口。例如我前不久主导重写的项目，使用Python异步编程，改版后由原来的7台服务器削减至3台，成本骤降57%。一台AWS m4.xlarge 型通用服务器按需付费实例一年价格约 1.2 万人民币。 效率问题 如果不在乎钱的消耗，那也会在意效率问题。当服务器数量堆叠到一定规模后，如果不改进软件架构和实现，加机器是徒劳，而且运维成本会骤然增加。比如别人家的电商平台支持6000单/秒支付，而自家在下单量才支撑2000单/秒，在双十一这种活动的时候，钱送上门也赚不到。 C10k/C10M挑战 C10k（concurrently handling 10k connections）是一个在1999年被提出来的技术挑战，如何在一颗1GHz CPU，2G内存，1gbps网络环境下，让单台服务器同时为1万个客户端提供FTP服务。而到了2010年后，随着硬件技术的发展，这个问题被延伸为C10M，即如何利用8核心CPU，64G内存，在10gbps的网络上保持1000万并发连接，或是每秒钟处理100万的连接。（两种类型的计算机资源在各自的时代都约为1200美元） 成本和效率问题是从企业经营角度讲，C10k/C10M问题则是从技术角度出发挑战软硬件极限。C10k/C10M 问题得解，成本问题和效率问题迎刃而解。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:1:2","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"什么是异步编程 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:0","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"阻塞 程序未得到所需计算资源时被挂起的状态。 程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。 常见的阻塞形式有：网络I/O阻塞、磁盘I/O阻塞、用户输入阻塞等。 阻塞是无处不在的，包括CPU切换上下文时，所有的进程都无法真正干事情，它们也会被阻塞。（如果是多核CPU则正在执行上下文切换操作的核不可被利用。） ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:1","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"非阻塞 程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的。 非阻塞并不是在任何程序级别、任何情况下都可以存在的。 仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。 非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:2","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"同步 不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。 例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。 简言之，同步意味着有序 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:3","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"异步 为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式。 不相关的程序单元之间可以是异步的。 例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。 简言之，异步意味着无序。 上文提到的“通信方式”通常是指异步和并发编程提供的同步原语，如信号量、锁、同步队列等等。我们需知道，虽然这些通信方式是为了让多个程序在一定条件下同步执行，但正因为是异步的存在，才需要这些通信方式。如果所有程序都是按序执行，其本身就是同步的，又何需这些同步信号呢？ ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:4","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"并发 并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。 以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:5","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"并行 并行描述的是程序的执行状态。指多个任务同时被执行。 以利用富余计算资源（多核CPU）加速完成多个任务为目的 并发提供了一种程序组织结构方式，让问题的解决方案可以并行执行，但并行执行不是必须的 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:6","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"概念总结 并行是为了利用多核加速多任务完成的进度 并发是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度 非阻塞是为了提高程序整体执行效率 异步是高效地组织非阻塞任务的方式 要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:7","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"异步编程 以进程、线程、协程、函数/方法作为执行任务程序的基本单位，结合回调、事件循环、信号量等机制，以提高程序整体执行效率和并发能力的编程方式 如果在某程序的运行时，能根据已经执行的指令准确判断它接下来要进行哪个具体操作，那它是同步程序，反之则为异步程序。（无序与有序的区别） 同步/异步、阻塞/非阻塞并非水火不容，要看讨论的程序所处的封装级别。例如购物程序在处理多个用户的浏览请求可以是异步的，而更新库存时必须是同步的 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:8","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"GIL 全局解释器锁 如何解决线程安全问题？CPython 解释器使用了加锁的方法。每个进程有一把锁，启动线程先加锁，结束线程释放锁。打个比方，进程是一个厂房，厂房大门是开着的，门内有锁，工人进入大门后可以在内部上锁。厂房里面有 10 个车间对应 10 个线程，每个 CPU 就是一个工人。GIL（Global Interpreter Lock）全局锁就相当于厂房规定：工人要到车间工作，从厂房大门进去后要在里面反锁，完成工作后开锁出门，下一个工人再进门上锁。也就是说，任意时刻厂房里只能有一个工人，但这样就保证了工作的安全性，这就是 GIL 的原理。当然了，GIL 的存在有很多其它益处，包括简化 CPython 解释器和大量扩展的实现 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:2:9","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"python异步编程历史 历史上，Python 并不支持专门的异步编程语法，因为不需要。 有了多线程（threading）和多进程（multiprocessing），就没必要一定支持异步了。如果一个线程（或进程）阻塞，新建其他线程（或进程）就可以了，程序不会卡死。 但是，多线程有\"线程竞争\"的问题，处理起来很复杂，还涉及加锁。对于简单的异步任务来说，写起来很麻烦。 Python 3.4 引入了 asyncio 模块，增加了异步编程，跟 JavaScript 的async/await 极为类似，大大方便了异步任务的处理。它受到了开发者的欢迎，成为从 Python 2 升级到 Python 3 的主要理由之一。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:3:0","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"python协程发展过程 多线程-\u003e多进程-\u003e 非阻塞回调-\u003e事件循环-\u003e(Co-routine)协程-\u003eyield from 协程函数[python3.4]\u003easyncio语法async await -\u003ePython 3.6 中asyncio库“转正” ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:3:1","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"asyncio和原生协程初体验 import asyncio async def fun1(): print(1) await asyncio.sleep(2) # 模拟IO操作 print(2) async def fun2(): print(3) await asyncio.sleep(2) # 模拟IO操作 print(4) 运行结果 可以看到遇到IO阻塞自动切换线程,两步各需要2s的IO阻塞也一起执行。 asyncio 模块在单线程上启动一个事件循环（event loop），时刻监听新进入循环的事件，加以处理，并不断重复这个过程，直到异步任务结束。事件循环的内部机制 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:3:2","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"asyncio API asyncio 模块最主要的几个API。注意，必须使用 Python 3.7 或更高版本，早期的语法已经变了。 第一步，import 加载 asyncio 模块。 import asyncio 第二步，函数前面加上 async 关键字，就变成了 async 函数。这种函数最大特点是执行可以暂停，交出执行权。 async def main(): 第三步，在 async 函数内部的异步任务前面，加上await命令。 await asyncio.sleep(1) 上面代码中，asyncio.sleep(1) 方法可以生成一个异步任务，休眠1秒钟然后结束。 执行引擎遇到await命令，就会在异步任务开始执行之后，暂停当前 async 函数的执行，把执行权交给其他任务。等到异步任务结束，再把执行权交回 async 函数，继续往下执行。 第四步，async.run() 方法加载 async 函数，启动事件循环。 asyncio.run(main()) 上面代码中，asyncio.run() 在事件循环上监听 async 函数main的执行。等到 main 执行完了，事件循环才会终止。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:4:0","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"asyncio实例 先用flask开启一个模拟环境，代码如下 # -*- coding: utf-8 -*- from flask import Flask import time app = Flask(__name__) @app.route('/') def index(): # 控制响应时间10s之后才响应 time.sleep(4) return \"\u003ch3\u003e慢慢倒数4s\u003ch3\u003e\" if __name__ == '__main__': app.run(debug=True) ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:0","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"单线程版 # -*- coding: utf-8 -*- import requests import time start = time.time() URL = 'http://127.0.0.1:5000' def get(URL): r = requests.get(URL) print(r.status_code, r.url, r.text) if __name__ == '__main__': for _ in range(10): get(URL) end = time.time() print(\"duration time:\", end - start) 运行结果 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e 200 http://127.0.0.1:5000/ \u003ch3\u003e慢慢倒数1s\u003ch3\u003e duration time: 40.12979030609131 单线程耗时40.1s ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:1","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"多线程版 # -*- coding: utf-8 -*- import requests import time import concurrent.futures start = time.time() URL = 'http://127.0.0.1:5000' def get(URL): r = requests.get(URL) print(r.status_code, r.url, r.text) if __name__ == '__main__': pool = concurrent.futures.ThreadPoolExecutor(max_workers=6) for result in pool.map(get, [URL for _ in range(10)]): print(result) end = time.time() print(\"duration time:\", end - start) 运行结果 (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') duration time: 8.07605242729187 多线程耗时8.07S ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:2","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"多进程版 # -*- coding: utf-8 -*- import requests import time import concurrent.futures start = time.time() URL = 'http://127.0.0.1:5000' def get(URL): r = requests.get(URL) return r.status_code, r.url, r.text if __name__ == '__main__': pool = concurrent.futures.ProcessPoolExecutor(max_workers=6) for result in pool.map(get, [URL for _ in range(10)]): # do something with result print(result) end = time.time() print(\"duration time:\", end - start) # 运行结果 (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') (200, 'http://127.0.0.1:5000/', '\u003ch3\u003e慢慢倒数1s\u003ch3\u003e') duration time: 8.361502647399902 max_workers=6，没有资源竞争，用window10跑竟然比多线程还要快，多进程整个用时8.4s ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:3","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"异步IO版 import aiohttp import asyncio import time start = time.time() URL = \"http://127.0.0.1:5000/\" session = None async def fetch(): async with session.get(URL) as response: print(await response.text(), response.url, response.status) async def main(): global session session = aiohttp.ClientSession() scrape_index_tasks = [asyncio.ensure_future(fetch()) for _ in range(10)] await asyncio.gather(*scrape_index_tasks) if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) print(\"End time\", time.time()-start) # 运行结果 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 \u003ch3\u003e慢慢倒数1s\u003ch3\u003e http://127.0.0.1:5000/ 200 End time 4.025025129318237 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:4","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"整个用时对比 代码如下 # -*- coding: utf-8 -*- import requests import time import concurrent.futures import matplotlib.pyplot as plt import aiohttp import asyncio start = time.time() URL = 'http://127.0.0.1:5000' # 5S之后返回结果 def time_wrapper(func): # 装饰器函数，func为被装饰函数 def inner(*args, **kwargs): \"\"\"被装饰函数前需要添加的内容\"\"\" start = time.time() name = func.__name__ ret = func(*args, **kwargs) # 被装饰函数 \"\"\"被装饰函数后需要添加的内容\"\"\" end = time.time() duration = round((end - start), 2) print(f\"{name} 请求次数{i} 所需用时: {duration} s\") return ret return inner def get(URL): r = requests.get(URL) return r.status_code, r.url, r.text @time_wrapper def single_thread(i): for _ in range(i): get(URL) @time_wrapper def multithrad(i): pool = concurrent.futures.ThreadPoolExecutor(max_workers=20) for result in pool.map(get, [URL for _ in range(i)]): # print(result) time.sleep(0) @time_wrapper def multiprocess(i): pool = concurrent.futures.ProcessPoolExecutor(max_workers=20) for result in pool.map(get, [URL for _ in range(i)]): # print(result) time.sleep(0) async def fetch(): async with session.get(URL) as response: await response.text(), response.url, response.status async def main(i): global session session = aiohttp.ClientSession() scrape_index_tasks = [asyncio.ensure_future(fetch()) for _ in range(i)] await asyncio.gather(*scrape_index_tasks) @time_wrapper def async_get(i): loop = asyncio.get_event_loop() loop.run_until_complete(main(i)) if __name__ == '__main__': process_pool = concurrent.futures.ProcessPoolExecutor(max_workers=20) axis = [10, 20, 30, 40, 50,] # yxis = [] for i in axis: single_thread(i) async_get(i) multithrad(i) multiprocess(i) # 运行结果 single_thread 请求次数10 所需用时: 50.13 s async_get 请求次数10 所需用时: 5.02 s multithrad 请求次数10 所需用时: 5.03 s multiprocess 请求次数10 所需用时: 6.68 s single_thread 请求次数20 所需用时: 100.32 s async_get 请求次数20 所需用时: 5.06 s multithrad 请求次数20 所需用时: 5.06 s multiprocess 请求次数20 所需用时: 7.97 s single_thread 请求次数30 所需用时: 150.6 s async_get 请求次数30 所需用时: 5.04 s multithrad 请求次数30 所需用时: 10.12 s multiprocess 请求次数30 所需用时: 11.95 s single_thread 请求次数40 所需用时: 200.57 s async_get 请求次数40 所需用时: 5.07 s multithrad 请求次数40 所需用时: 10.07 s multiprocess 请求次数40 所需用时: 13.0 s single_thread 请求次数50 所需用时: 250.74 s async_get 请求次数50 所需用时: 5.09 s multithrad 请求次数50 所需用时: 15.1 s multiprocess 请求次数50 所需用时: 17.32 s 可以看到异步请求基本数都是5s之内获取,对比单线程多线程多进程效果还是不错的。 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:5","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"如何使用asyncio 基于asyncio的事件循环 #!/usr/bin/env python3 # countasync.py import asyncio async def count(): print(\"One\") await asyncio.sleep(1) print(\"Two\") async def main(): await asyncio.gather(count(), count(), count()) if __name__ == \"__main__\": import time s = time.perf_counter() asyncio.run(main()) elapsed = time.perf_counter() - s print(f\"{__file__} executed in {elapsed:0.2f} seconds.\") # 结果 One One One Two Two Two 基于for loop的过程循环 #!/usr/bin/env python3 # countsync.py import time def count(): print(\"One\") time.sleep(1) print(\"Two\") def main(): for _ in range(3): count() if __name__ == \"__main__\": s = time.perf_counter() main() elapsed = time.perf_counter() - s print(f\"{__file__} executed in {elapsed:0.2f} seconds.\") # 运行结果 One Two One Two One Two countsync.py executed in 3.01 seconds. 未完待续 ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:6","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"参考 深入理解 Python 异步编程 https://gist.github.com/baymaxium/53af1bca2123dbd0cb82154455e7d48e Python 异步编程入门 https://www.ruanyifeng.com/blog/2019/11/python-asyncio.html python高性能编程 https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter4/03_Event_loop_management_with_Asyncio.html https://realpython.com/async-io-python/ python异步历史 https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/ ","date":"2021-09-04","objectID":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/:5:7","tags":["异步编程"],"title":"Python异步性能对比","uri":"/posts/python%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"categories":["python"],"content":"Createitv","date":"2021-09-02","objectID":"/posts/environs/","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"系统环境变量配置 ","date":"2021-09-02","objectID":"/posts/environs/:1:0","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"设置Windows PowerShell环境变量 $env:Path +=\";C:\\Program Files\\GnuWin32\\bin\" $env:string=\"a string\" ","date":"2021-09-02","objectID":"/posts/environs/:1:1","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"查看Windows PowerShell环境变量 $env:NUMBER_OF_PROCESSORS. # 查看系统CPU数量 ","date":"2021-09-02","objectID":"/posts/environs/:1:2","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"设置Windows CMD环境变量 set string=\"string\" ","date":"2021-09-02","objectID":"/posts/environs/:1:3","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"查看Windows CMD环境变量 set ","date":"2021-09-02","objectID":"/posts/environs/:1:4","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"设置MacOS,Linux环境变量 export PATH=\"/usr/local/sbin:$PATH\" export NODE_ENV=development ","date":"2021-09-02","objectID":"/posts/environs/:1:5","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"查看MacOS,Linux环境变量 echo $PATH echo ","date":"2021-09-02","objectID":"/posts/environs/:1:6","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"OS内置模块 # Python program to explain os.environ object # importing os module import os import pprint # Get the list of user's # environment variables env_var = os.environ # Print the list of user's # environment variables print(\"User's Environment variable:\") pprint.pprint(dict(env_var), width = 1) ","date":"2021-09-02","objectID":"/posts/environs/:2:0","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"添加环境变量 # Python program to explain os.environ object # importing os module import os # Add a new environment variable os.environ['GeeksForGeeks'] = 'www.geeksforgeeks.org' # Get the value of # Added environment variable print(\"GeeksForGeeks:\", os.environ['GeeksForGeeks']) # Print the value of # 'MY_HOME' environment variable print(\"MY_HOME:\", os.environ['MY_HOME'] # If the key does not exists # it will produce an error ","date":"2021-09-02","objectID":"/posts/environs/:2:1","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"environs库特点 类型检查 直接读取本地.env 配置文件 自定义解析，闭os.environs更易用 ","date":"2021-09-02","objectID":"/posts/environs/:3:0","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"安装 pip install environs ","date":"2021-09-02","objectID":"/posts/environs/:4:0","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"基本使用官方用例 # export GITHUB_USER=sloria # export API_KEY=123abc # export SHIP_DATE='1984-06-25' # export ENABLE_LOGIN=true # export GITHUB_REPOS=webargs,konch,ped # export COORDINATES=23.3,50.0 from environs import Env env = Env() # reading an environment variable gh_user = env('GITHUB_USER') # =\u003e 'sloria' secret = env('SECRET') # =\u003e raises error if not set # cast ingapi_key = env.str('API_KEY') # =\u003e '123abc' date = env.date('SHIP_DATE') # =\u003e datetime.date(1984, 6, 25) # providing a default value enable_login = env.bool('ENABLE_LOGIN', False) # =\u003e True enable_feature_x = env.bool('ENABLE_FEATURE_X', False) # =\u003e False # parsing lists gh_repos = env.list('GITHUB_REPOS') # =\u003e ['webargs', 'konch', 'ped'] coords = env.list('COORDINATES', subcast=float) # =\u003e [23.3, 50.0] ","date":"2021-09-02","objectID":"/posts/environs/:5:0","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"支持类型 总的来说，environs 支持的转化类型有这么多： env.str env.bool env.int env.float env.decimal env.list (accepts optional subcast keyword argument) env.dict (accepts optional subcast keyword argument) env.json env.datetime env.date env.timedelta (assumes value is an integer in seconds) env.url env.uuid env.log_level env.path (casts to a pathlib.Path) ","date":"2021-09-02","objectID":"/posts/environs/:5:1","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"读取本地.env文件 # .env file DEBUG=true PORT=4567 from environs import Env env = Env() # Read .env into os.environ env.read_env() env.bool(\"DEBUG\") # =\u003e True env.int(\"PORT\") # =\u003e 4567 ","date":"2021-09-02","objectID":"/posts/environs/:5:2","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"前缀处理 environs 还支持前缀处理，一般来说我们定义一些环境变量，如数据库的连接，可能有 host、port、password 等，但在定义环境变量的时候往往会加上对应的前缀，如 MYSQL_HOST、MYSQL_PORT、MYSQL_PASSWORD 等，但在解析时，我们可以根据前缀进行分组处理，见下面的示例： # export MYAPP_HOST=localhost # export MYAPP_PORT=3000 with env.prefixed(\"MYAPP_\"): host = env(\"HOST\", \"localhost\") # =\u003e 'lolcathost' port = env.int(\"PORT\", 5000) # =\u003e 3000 # nested prefixes are also supported: # export MYAPP_DB_HOST=localhost # export MYAPP_DB_PORT=10101 with env.prefixed(\"MYAPP_\"): with env.prefixed(\"DB_\"): db_host = env(\"HOST\", \"lolcathost\") db_port = env.int(\"PORT\", 10101) ","date":"2021-09-02","objectID":"/posts/environs/:5:3","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"参考 https://cuiqingcai.com/8947.html https://www.geeksforgeeks.org/python-os-environ-object/ ","date":"2021-09-02","objectID":"/posts/environs/:5:4","tags":[],"title":"Environs库","uri":"/posts/environs/"},{"categories":["python"],"content":"Createitv","date":"2021-09-02","objectID":"/posts/__del__%E5%92%8C__delete__/","tags":["魔法函数"],"title":"__Del__和__delete__","uri":"/posts/__del__%E5%92%8C__delete__/"},{"categories":["python"],"content":"Both __delete__ and __del__ are dunder or magic methods in Python. Dunder or magic methods in Python are the methods having two prefix and suffix underscores in the method name. Dunder here means “Double Under (Underscores)”. These are commonly used for operator overloading. del __del__ is a destructor method which is called as soon as all references of the object are deleted i.e when an object is garbage collected. import time class Animal(object): # 创建完对象后会自动被调用 def __init__(self, name): print('__init__方法被调用') self.__name = name # 当对象被删除时，会自动被调用 def __del__(self): print(\"__del__方法被调用\") print(\"%s对象马上被干掉了...\" % self.__name) # 创建对象 dog = Animal(\"哈皮狗\") -----------Output------------ \u003e\u003e\u003e __init__方法被调用 \u003e\u003e\u003e __del__方法被调用 \u003e\u003e\u003e 哈皮狗对象马上被干掉了... Note : The destructor was called after the program ended or when all the references to object are deleted i.e when the reference count becomes zero, not when object went out of scope. delete __delete__ is used to delete the attribute of an instance i.e removing the value of attribute present in the owner class for an instance. Note: This method only deletes the attribute which is a descriptor. class Example(object): # Initializing def __init__(self): print(\"Example Instance.\") # Calling __delete__ def __delete__(self, instance): print (\"Deleted in Example object.\") # Creating object of Example # class as an descriptor attribute # of this class class Foo(object): exp = Example() # Driver's code f = Foo() del f.exp ----output---- \u003e\u003e\u003e Example Instance. \u003e\u003e\u003e Deleted in Example object. ","date":"2021-09-02","objectID":"/posts/__del__%E5%92%8C__delete__/:0:0","tags":["魔法函数"],"title":"__Del__和__delete__","uri":"/posts/__del__%E5%92%8C__delete__/"},{"categories":["JS逆向"],"content":"Createitv","date":"2021-08-28","objectID":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/","tags":["夜幕"],"title":"第9课练习颜文字混淆","uri":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/"},{"categories":["JS逆向"],"content":" 网页地址：http://js-crack-course-9-1.crawler-lab.com/ ","date":"2021-08-28","objectID":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/:0:0","tags":["夜幕"],"title":"第9课练习颜文字混淆","uri":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/"},{"categories":["JS逆向"],"content":"加密分析流程 查看请求包，查看加密参数 搜索参数，找到js加密参数的位置。 Tip1: 参数名= 或者直接搜索参数名 Tip2：查看网络面板的Initiator(本请求的发起者，是哪一个js文件，进一步看看请求堆栈) Tip3: xhr断点调试 Tip4：Hook相关参数逻辑 分析加密逻辑 补全加密流程 ","date":"2021-08-28","objectID":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/:1:0","tags":["夜幕"],"title":"第9课练习颜文字混淆","uri":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/"},{"categories":["JS逆向"],"content":"解题流程 Toggle Javascript插件看看数据是不是由js渲染，果然是。直接在network选项卡中在XHR网络请求，找到对应的请求链接。 找到渲染数据的js代码，选择加密部分。 (function anonymous( ) { function Base64() { // private property _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; // public method for encoding this.encode = function (input) { var output = \"\"; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = _utf8_encode(input); while (i \u003c input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u003e\u003e 2; enc2 = ((chr1 \u0026 3) \u003c\u003c 4) | (chr2 \u003e\u003e 4); enc3 = ((chr2 \u0026 15) \u003c\u003c 2) | (chr3 \u003e\u003e 6); enc4 = chr3 \u0026 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4); } return output; }; // public method for decoding this.decode = function (input) { var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i \u003c input.length) { enc1 = _keyStr.indexOf(input.charAt(i++)); enc2 = _keyStr.indexOf(input.charAt(i++)); enc3 = _keyStr.indexOf(input.charAt(i++)); enc4 = _keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u003c\u003c 2) | (enc2 \u003e\u003e 4); chr2 = ((enc2 \u0026 15) \u003c\u003c 4) | (enc3 \u003e\u003e 2); chr3 = ((enc3 \u0026 3) \u003c\u003c 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = _utf8_decode(output); return output; }; // private method for UTF-8 encoding _utf8_encode = function (string) { string = string.replace(/\\r\\n/g,\"\\n\"); var utftext = \"\"; for (var n = 0; n \u003c string.length; n++) { var c = string.charCodeAt(n); if (c \u003c 128) { utftext += String.fromCharCode(c); } else if((c \u003e 127) \u0026\u0026 (c \u003c 2048)) { utftext += String.fromCharCode((c \u003e\u003e 6) | 192); utftext += String.fromCharCode((c \u0026 63) | 128); } else { utftext += String.fromCharCode((c \u003e\u003e 12) | 224); utftext += String.fromCharCode(((c \u003e\u003e 6) \u0026 63) | 128); utftext += String.fromCharCode((c \u0026 63) | 128); } } return utftext; }; // private method for UTF-8 decoding _utf8_decode = function (utftext) { var string = \"\"; var i = 0; var c = c1 = c2 = 0; while ( i \u003c utftext.length ) { c = utftext.charCodeAt(i); if (c \u003c 128) { string += String.fromCharCode(c); i++; } else if((c \u003e 191) \u0026\u0026 (c \u003c 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026 31) \u003c\u003c 6) | (c2 \u0026 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026 15) \u003c\u003c 12) | ((c2 \u0026 63) \u003c\u003c 6) | (c3 \u0026 63)); i += 3; } } return string; }; }; function uuid() { var s = []; var hexDigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"; for (var i = 0; i \u003c 36; i++) { s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1); } s[14] = \"4\"; s[19] = hexDigits.substr((s[19] \u0026 0x3) | 0x8, 1); s[8] = s[13] = s[18] = s[23] = \"-\"; var uuid = s.join(\"\"); return uuid; } function getparam() { \"use strict\"; let base64 = new Base64(); let key = uuid(); let time= (Math.floor(( new Date().getTime() + 10010) / 99)).toString(); let sign = md5(key + base64.encode(time)); let param = { \"key\": key, \"time\": time, \"sign\": sign }; return param }; render(getparam()); }) 无混淆，逐步nodejs运行补充环境，md5发现缺这个函数，逐步尝试发现是sha1加密。直接用nodejscrypto库构造md5函数 let crypro = require(\"crypto\") function md5(password) { var sha1 = crypto.createHash('sha1'); return sha1.updata(password).digest('hex'); } 再用request发起请求解析求答案 ","date":"2021-08-28","objectID":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/:2:0","tags":["夜幕"],"title":"第9课练习颜文字混淆","uri":"/posts/%E7%AC%AC9%E8%AF%BE%E7%BB%83%E4%B9%A0%E9%A2%9C%E6%96%87%E5%AD%97%E6%B7%B7%E6%B7%86/"},{"categories":["加密算法"],"content":"Createitv","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"常见的加密算法可以分成三类 MD5、hash256、hash1、hash128 对称加密算法：AES、DES 非对称加密算法：RSA、… ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"Hash MD5算法： Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。一般为32位 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"特点 优点：不可逆、易计算、特征化 缺点：可能存在散列冲突 使用场景：文件或字符串一致性校验、数字签名、鉴权协议 对于 MD5 而言，有两个特性是很重要的，第一：明文数据经过散列以后的值是定长的；第二：是任意一段明文数据，经过散列以后，其结果必须永远是不变的。 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:1","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"python版本 import hashlib password = \"w3213xcas0\" print(hashlib.md5(password.encode(\"utf-8\")).hexdigest()) print(len(\"3e356fc9115d18c86e445ce2475a0961\")) # output \u003e\u003e 3e356fc9115d18c86e445ce2475a0961 \u003e\u003e 32 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:2","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"JS版本 const crypto = require(\"crypto\"); //引入crypto加密模块 // update()方法默认字符串编码为UTF-8，也可以传入Buffer。 // 如果要计算SHA1，只需要把'md5'改成'sha1'，就可以得到SHA1的结果 const hash = crypto.createHash(\"md5\"); //规定使用哈希算法中的MD5算法 password = \"w3213xcas0\"; // 可任意多次调用update(),效果相当于多个字符串相加 hash.update(password); //最终加密的字符串为'w3213xcas0',hash.digest('hex')表示输出的格式为16进制 console.log(hash.digest(\"hex\")); console.log(hash.digest(\"hex\").length); # output \u003e\u003e 3e356fc9115d18c86e445ce2475a0961 \u003e\u003e 32 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:3","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"MD5结合密钥加密 const crypto = require(\"crypto\"); function md5(text) { return crypto.createHash(\"md5\").update(text).digest(\"hex\"); } var str = \"123\"; var md5_suffix = \"9d0f0dakdllwlelldda,x,,axx2\"; //md5_suffix作为秘钥,越复杂越好 var FinalPass = md5(str + md5_suffix); console.log(FinalPass); ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:4","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"sha256 import hashlib password = \"w3213xcas0\" + \"dasdasd\" print(hashlib.sha256(password.encode(\"utf-8\")).hexdigest()) print(len(\"998b2d30d19311f48758bc5601913edf66db6932eb14d39ab8a6b114f96973f4\")) # output \u003e\u003e 998b2d30d19311f48758bc5601913edf66db6932eb14d39ab8a6b114f96973f4 \u003e\u003e 64 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:5","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"BASE64 Base64 编码只是一种编码格式并不是加密算法，它可用于在 HTTP 环境下传递较长的标识信息。 特点 可以将任意的二进制数据进行 Base64 编码 数据加密之后，数据量会变大，变大 1/3 左右 编码后有个非常显著的特点，末尾有个=号 可进行反向解码 Base64 编码具有不可读性 import base64 print(base64.b64encode(b\"binary\\x00string\")) print(base64.b64decode(b\"YmluYXJ5AHN0cmluZw==\")) # output \u003e\u003e b'YmluYXJ5AHN0cmluZw==' \u003e\u003e b'binary\\x00string' ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:6","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"对称加密 1、什么是对称加密？ 对称加密就是指，加密和解密使用同一个密钥的加密方式。 2、对称加密的工作过程 发送方使用密钥将明文数据加密成密文，然后发送出去，接收方收到密文后，使用同一个密钥将密文解密成明文读取。 3、对称加密的优点 加密计算量小、速度块，适合对大量数据进行加密的场景。（记住这个特点，实际使用是会用到的） 4、对称加密的两大不足 密钥传输问题：如上所说，由于对称加密的加密和解密使用的是同一个密钥，所以对称加密的安全性就不仅仅取决于加密算法本身的强度，更取决于密钥是否被安全的保管，因此加密者如何把密钥安全的传递到解密者手里，就成了对称加密面临的关键问题。（比如，我们客户端肯定不能直接存储对称加密的密钥，因为被反编译之后，密钥就泄露了，数据安全性就得不到保障，所以实际中我们一般都是客户端向服务端请求对称加密的密钥，而且密钥还得用非对称加密加密后再传输。） ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"什么是AES加密算法 针对对称加密的话，是有很多的对称加密算法的，如DES加密算法、3DES加密算法等，但是因为AES加密算法的安全性要高于DES和3DES，所以AES已经成为了主要的对称加密算法，因此本篇主要学习一下AES加密算法。 AES加密算法就是众多对称加密算法中的一种，它的英文全称是Advanced Encryption Standard，翻译过来是高级加密标准，它是用来替代之前的DES加密算法的。 AES加密算法采用分组密码体制，每个分组数据的长度为128位16个字节，密钥长度可以是128位16个字节、192位或256位，一共有四种加密模式，我们通常采用需要初始向量IV的CBC模式，初始向量的长度也是128位16个字节。 from Crypto.Cipher import AES import base64 BLOCK_SIZE = 16 # Bytes def pad(s): return s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \\ chr(BLOCK_SIZE - len(s) % BLOCK_SIZE) def unpad(s): return s[:-ord(s[len(s) - 1:])] def aesEncrypt(key, data): ''' AES的ECB模式加密方法 :param key: 密钥 :param data:被加密字符串（明文） :return:密文 ''' key = key.encode('utf8') # 字符串补位 data = pad(data) cipher = AES.new(key, AES.MODE_ECB) # 加密后得到的是bytes类型的数据，使用Base64进行编码,返回byte字符串 result = cipher.encrypt(data.encode()) encodestrs = base64.b64encode(result) enctext = encodestrs.decode('utf8') print(enctext) return enctext def aesDecrypt(key, data): ''' :param key: 密钥 :param data: 加密后的数据（密文） :return:明文 ''' key = key.encode('utf8') data = base64.b64decode(data) cipher = AES.new(key, AES.MODE_ECB) # 去补位 text_decrypted = unpad(cipher.decrypt(data)) text_decrypted = text_decrypted.decode('utf8') print(text_decrypted) return text_decrypted if __name__ == '__main__': key = '5c44c819appsapi0' data = 'herish acorn' ecdata = aesEncrypt(key, data) aesDecrypt(key, ecdata) ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:1","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"非对称加密 一、非对称加密算法 1、乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 2、甲方获取乙方的公钥，然后用它对信息加密。 3、乙方得到加密后的信息，用私钥解密。 二、RSA算法 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的\"非对称加密算法\"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。 这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:0","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"使用openssl 工具生成RSA 私钥和秘钥 生成私钥 openssl genrsa -out rsa_private_key.pem 1024 生成公钥 openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:1","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"python版本 import base64 from Crypto.PublicKey import RSA from Crypto.Hash import SHA from Crypto.Signature import PKCS1_v1_5 as PKCS1_signature from Crypto.Cipher import PKCS1_v1_5 as PKCS1_cipher def get_key(key_file): with open(key_file) as f: data = f.read() key = RSA.importKey(data) return key def encrypt_data(msg): public_key = get_key('rsa_public_key.pem') cipher = PKCS1_cipher.new(public_key) encrypt_text = base64.b64encode(cipher.encrypt(bytes(msg.encode(\"utf8\")))) return encrypt_text.decode('utf-8') def decrypt_data(encrypt_msg): private_key = get_key('rsa_private_key.pem') cipher = PKCS1_cipher.new(private_key) back_text = cipher.decrypt(base64.b64decode(encrypt_msg), 0) return back_text.decode('utf-8') def test_encrypt_decrypt(): msg = \"coolpython.net\" encrypt_text = encrypt_data(msg) decrypt_text = decrypt_data(encrypt_text) print(msg == decrypt_text) if __name__ == '__main__': msg = \"coolpython.net\" encrypt_text = encrypt_data(msg) print(encrypt_text) print(decrypt_data(encrypt_text)) test_encrypt_decrypt() # output \u003e\u003e\u003e eR5fRxkvKZA5sPCw1MEwjiqjkdI6/aQtGqbdwauaCIaM1WISSBmKMXZ7EflZXmR3a21wEWZ3rVCZzTYSypPjofPIAmZFH2sN20pTJ2iY9bnp+m5klWaHSa/2FcNurAzy7NcL1r+3tfGnMh5bHN81BYwtTOaVuYlD7Z3IBAf7RpY= \u003e\u003e\u003e coolpython.net \u003e\u003e\u003e True ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:2","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["加密算法"],"content":"javascript版本 const fs = require(\"fs\"); const NodeRSA = require(\"node-rsa\"); const a_public_key_data = fs.readFileSync(\"./rsa_public_key.pem\", \"utf8\"); const a_private_key_data = fs.readFileSync(\"./rsa_private_key.pem\", \"utf8\"); // console.log(a_public_key_data); // console.log(a_private_key_data); const a_public_key = new NodeRSA(a_public_key_data); const a_private_key = new NodeRSA(a_private_key_data); const text = \"coolpython.net\"; const sign = a_private_key.sign(text, \"base64\", \"utf8\"); console.log(\"A 私钥加签:\", sign); const encrypted = a_public_key.encrypt(sign, \"base64\"); console.log(\"A 公钥加密:\", encrypted); // 解密并验签 const decrypted = a_private_key.decrypt(encrypted, \"utf8\"); console.log(\"A 私钥解密:\", decrypted); const verify = a_public_key.verify(text, decrypted, \"utf8\", \"base64\"); console.log(\"A 公钥验签:\", verify); // output \u003e\u003e\u003e A 私钥加密: PoYV1td/yKT8YgcP5R6RlHRQmmBv4cWO8p7nuEH8YpZ1Q0KvrwQ/r3vY+/b3Gjf7Ubr4xbApADzXtjASekey+dc1io85OCZ4Rodf2+k2/hrUbbExUDoc9arBgY5QBAgqd88xfjR5U+hovnSwhUVvALlXONJpqjeLLcH9grWwAhs= \u003e\u003e\u003e A 公钥加密: UBAONDQY1ZGHVTT3BzKEYIFGgJcYCLZEanLbdWDYsiZ3xXqWX7zTpiX35F30lob/fgXCRoOnNLTxLwzN82BOW6OIEm9C4AOM4V72KTEP/6PUzEESCelpqc2tOJXpiBM/mlAhEodCjQV8qU7+k5wHm7uMc5uH2Eov2SkjEiqlUC2gkr04KBd1a6U5T3cWyme9qv65aFVAAOhuq+Cf30C8hM4g3NZml/QcMn4PJZettkOMo8KRSG+vxJpyR/q0pxIC5AuZl9IoMotWGGgfEC6GRbvDL95FDA3CacZopJWktGuNLAHzanMGn2wfQBHmn22yGeTUcDgfvV459UlON9UAeg== \u003e\u003e\u003e A 私钥解密: PoYV1td/yKT8YgcP5R6RlHRQmmBv4cWO8p7nuEH8YpZ1Q0KvrwQ/r3vY+/b3Gjf7Ubr4xbApADzXtjASekey+dc1io85OCZ4Rodf2+k2/hrUbbExUDoc9arBgY5QBAgqd88xfjR5U+hovnSwhUVvALlXONJpqjeLLcH9grWwAhs= \u003e\u003e\u003e A 公钥验密: true RSA加密，私钥都是一样的，公钥每次加密的结果不一样跟对数据的padding（填充）有关。 1、Padding (填充)属性定义元素边框与元素内容之间的空间。 2、padding 简写属性在一个声明中设置所有内边距属性。设置所有当前或者指定元素内边距属性。该属性可以有1到4个值。 3、当元素的 Padding(填充)(内边距)被清除时，所\"释放\"的区域将会受到元素背景颜色的填充。 4、单独使用填充属性是在一个声明中设置元素的所内边距属性。缩写填充属性也可以使用，一旦改变一个数值，则padding对应的距离都会改变。 ","date":"2021-08-26","objectID":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:3","tags":[],"title":"加密算法","uri":"/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Vim"],"content":"Createitv","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim文件编辑 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:1:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"插入 e 编辑文件 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件 i 光标前插入 I 行首插入 o 下一行插入 O 上一行插入 a 光标后插入 A 行尾插入 s 删除当前字符并进入插入模式 S 删除当前行并进入插入模式 r 替换当前字符 R 替换当前光标的字符直到退出插入模式 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:1:1","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"复制粘贴 yw 拷贝当前的一个单词 y0 拷贝的范围是当前光标处到行首 y^ 同上 y$ 拷贝的范围是当前光标处到行尾 yy 拷贝当前行 Y 同上 Nyy 从当前行开始拷贝 N 行 yf + 字符 复制从当前字符到指定字符 yG 拷贝当前行到文件尾 ygg 拷贝当前行到文件头 ggyG 复制整个文件 \"+y 复制到系统剪切板 \"+p 粘贴剪切板中的内容 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:1:2","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim移动 单位级 h 向左一字符 j 下一行 k 上一行 l 向右一字符 单词级 w or W 向右移动到下一单词开头 e or E 向右移动到单词结尾 b or B 向左移动到单词开头 * 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 注：所有小写单词都是以分词符作为单词界限，大写字母以空格作为界限。 块级 ( 移动到当前句子开头 ) 移动到下一句子开头 { 移动到当前段落开头 } 移动到下一段落开头 + 移动到下一行开头 - 移动到上一行开头 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 gg 到文档第一行 G 到文档最后一行 0, | 到行首（第 1 列） ^ 到第一个非空白字符 $ 到行尾 0nl, n| 到当前行的第n 列 g_ 到当前行的最后一个非空格字符处 H 到屏幕的首行 L 到屏幕尾行 M 到屏幕中间 % 到匹配的括号（包括小括号、中括号、大括号） zt 将当前行移到屏幕顶部 zz 将当前行移到屏幕中部 zb 将当前行移到屏幕底部 Ctrl-d 向下移动半页 Ctrl-u 向上移动半页 Ctrl-f 向下移动一页 Ctrl-b 向上移动一页 :\u003cN\u003e or \u003cN\u003egg 跳转到第 N 行 :+\u003cN\u003e or \u003cN\u003ej 向下跳 N 行 :-\u003cN\u003e or \u003cN\u003ek 向上跳 N 行 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:2:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim修改 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:3:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"c字符 c 修改命令 change,复合命令,修改后进入插入模式 cw修改一个单词 cb向后修改一个单词 ct)修改知道碰到符号） ci) 修改)内的内容 ca)修改)内的内容包括） cc删除整行保持缩进并进入编辑模式 diw删除光标所在的单词=\u003e d inside word ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:3:1","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"d字符 只删除还是在普通模式 dw删除一个单词 db向后伤处一个单词 d4l向右删除4个字符 dd删除一正行 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:3:2","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["Vim"],"content":"Vim回退 u撤销 ","date":"2021-08-14","objectID":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/:4:0","tags":[],"title":"Vim使用","uri":"/posts/vscode-vim%E4%BD%BF%E7%94%A8/"},{"categories":["git"],"content":"Createitv","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 的故事 十年前的这一周，Linux 内核开发社区正面临严峻的挑战：他们不能继续使用 BitKeeper 了（注：原因是当时BitKeeper 著作权所有者决定收回授权，内核开发团队与其协商无果），而又没有其他的 SCM （Software Configuration Management）可满足他们的分布式系统的需求。Linux 之父 Linus Torvalds 接受了这个挑战，决定开发一个新的版本控制系统。周末他消失了，新的一周，Git 问世了。今天，Git 已经成为上万个项目的版本控制系统，并且在程序员中引发了开源热潮。 git /gɪt/ 是一个开源的分布式版本控制系统 最初是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:1:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"有关版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。可以对任何类型的文件进行版本控制，便于不同的开发者协同工作 集中式版本控制 集中化的版本控制系统是为了让不同系统上的开发者协同工作。例如 SVN，它会有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人通过客户端连接到这台服务器，拉取最新的文件或者是提交更新 在这个系统中，每个人可以看到项目中其他人的工作，管理员也能很好的掌握和分配每个开发者的权限。但由于版本库是集中在服务器上的，如果出现了中央服务器的单点故障，在这个时间内，谁都无法提交更新，而且整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险 分布式版本控制 分布式的版本控制解决了集中化版本控制的一些问题，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:2:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 介绍 直接记录快照，而非差异比较 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照 Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它会对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成， Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用 Git 一般只添加数据 执行的 Git 操作，几乎只往 Git 数据库中增加数据 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:3:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 使用参考 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:4:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"1. 安装 brew install git ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:4:1","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"2. 配置 --global电脑全局配置，该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。你也可以在项目内配置项目的 git，配置完后可以使用 git config --list 查看配置信息 $ git config --global user.name \"zou\" $ git config --global user.email zouxq412@foxmail.com ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:4:2","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"Git 基本使用 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"1. Git 工作区、暂存区和版本库 在了解 Git 的基本操作之前，我们先来了解 Git 工作区、暂存区和版本库的概念 在 Git 中的文件有三种状态：已提交(committed)： 表示数据已经安全的保存在本地数据库中；已修改(modified)： 表示修改了文件，但还没保存到数据库中；已暂存(staged)： 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此也引入了 Git 项目的三个工作区域的概念： 工作区： 就是项目文件所在的目录 暂存区： stage 或 index。一般存放在 .git/index 文件中，所以我们把暂存区有时也叫作索引 版本库： 工作区下隐藏目录 .git，这里记录着仓库的版本信息和历史记录 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:1","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"2.命令介绍 git init # 初始化git仓库，创建git配置文件 git add . # 添加所有文件到暂存区 git commit -m \"\u003cmsg\u003e\" # 提交文件更新 git commit -a \"\u003cmsg\u003e\" # 等于第上两步，直接跳过git add 步骤 git reset HEAD \u003cfile\u003e... # 用来取消已暂存的内容 git status # 参看git工作区状态 git rm \u003cfile\u003e # 记录此次移除文件的操作 git rm -f \u003cfile\u003e # 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可 git mv # 命令用于移动或重命名一个文件、目录、软连接 git checkout \u003cfile\u003e # 文件回退 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:2","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"3. 上传 github git remote add origin \u003curl\u003e # 添加一个新的远程 Git 仓库 git push -u origin master # 本地仓库或把已存在的仓库推到 github仓库上 git fetch # 命令会将数据拉取到你的本地仓库 git merge # 合并分支 git pull \u003cremote\u003e \u003cbranch\u003e # 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支 git remote rename # 去修改一个远程仓库的简写名 git remote rm [name] # 可以去移除一个远程仓库 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:3","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"4.标签管理 git tag #查看所有的标签 git tag \u003cname\u003e #创建标签 git tag -v \u003cname\u003e -m \u003cmessage\u003e # 创建附注标签 git push origin [tagname] #推送标签到远程仓库 git tag -d \u003ctagname\u003e #删除本地仓库标签 git push \u003cremote\u003e :refs/tags/\u003ctagname\u003e #更新远程仓库标签 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:4","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"5.分支管理 git branch #列出分支，当前分支前面会标一个*号 git branch \u003cbranchname\u003e #创建分支 git checkout \u003cbranchname\u003e #切换分支 git checkout -b \u003cbranchname\u003e #创建并切换分支 git merge #合并分支 git branch -d \u003cbranchname\u003e #删除分支 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:5:5","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["git"],"content":"参考 Git 10 周年访谈：Linus Torvalds 讲述背后故事 常用 Git 命令清单 ","date":"2021-08-08","objectID":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/:6:0","tags":[],"title":"美妙的git","uri":"/posts/%E7%BE%8E%E5%A6%99%E7%9A%84git/"},{"categories":["JAVA"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/javase/","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"1.Java 概述 Java 编程语言是一种通用的、并行的、基于类的、面向对象的语言。它被设计得非常简单，这样程序员可以在该语言上流畅的交流。Java 编程语言与 C 和 C++ 有关联，但组织却截然不同，其中也省略了其他语言的一些用法，比如指针。它的目的是作为一个生产性语言，而不是一个研究性语言，因此，在设计上避免了包括新的和未经考验的功能。 Java 编程语言是强类型和静态类型，可以在编译时检测到编译时错误。编译时间通常由翻译程序到与机器无关的字节码表示的。运行时的活动包括加载和执行程序，可选机器代码生成和程序的动态优化所需的类的交联，和实际执行程序。 Java 编程语言是一个比较高层次的语言，在机器表示的细节是无法通过该语言的。它包括自动存储管理，通常使用垃圾收集器，以避免明确释放的安全问题（就像 C 语言的 free 或 C++ 的 delete）。高性能垃圾回收的实现可具有有界的停顿，以支持系统的编程和实时应用。语言不包括任何不安全的结构，如没有索引检查的数组访问，因为这种不安全的结构会导致不可预知的程序行为。 ","date":"2021-07-27","objectID":"/posts/javase/:1:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"语言起源 　Java平台和语言最开始只是SUN公司在1990年12月开始研究的一个内部项目。SUN公司的一个叫做帕特里克·诺顿的工程师被自己开发的C和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth计划”的项目的机会。 “Stealth计划”后来改名为“Green计划”，JGosling（詹姆斯·高斯林）和麦克·舍林丹也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，SUN公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C语言，但是很多成员包括SUN的首席科学家比尔·乔伊，发现C和可用的API在某些方面存在很大问题。 工作小组使用的是内嵌类型平台，可以用的资源极其有限。很多成员发现C太复杂以至很多开发者经常错误使用。他们发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。 根据可用的资金，比尔·乔伊决定开发一种集C语言和Mesa语言搭成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议SUN公司的工程师应该在C的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C的功能，他自己称这种新语言为C–，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的树而命名。 就像很多开发新技术的秘密的工程一样，工作小组没日没夜地工作到了1992年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库，和其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。 同年11月，Green计划被转化成了“FirstPerson有限公司”，一个SUN公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度互动的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Requestforproposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多地控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司再并回SUN公司。 1994年6、7月间，在经历了一场历时三天的头脑风暴的讨论之后，约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·斯库米，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。同年，Oak改名为Java。商标搜索显示，Oak已被一家显卡制造商注册，因此团队找到了一个新名字。这个名字是在很多成员常去的本地咖啡馆中杜撰出来的。名字是不是首字母缩写还不清楚，很大程度上来说不是。虽然有人声称是开发人员名字的组合：JamesGosling（詹姆斯·高斯林）ArthurVanHoff（阿瑟·凡·霍夫）AndyBechtolsheim（安迪·贝克托克姆），或“JustAnotherVagueAcronym”（只是另外一个含糊的缩写）。还有一种比较可信的说法是这个名字是出于对咖啡的喜爱，所以以Java咖啡来命名。类文件的前四个字节如果用十六进制阅读的话，分别为“CAFEBABE”，就会拼出两个单词“CAFEBABE”（咖啡宝贝）。 　1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年5月23日SunWorld大会上进行的。SUN公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，Sun公司成立了Java业务集团，专门开发Java技术。 ","date":"2021-07-27","objectID":"/posts/javase/:1:1","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"发展简史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为JavaSE5.0 2005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME 2006年12月，SUN公司发布JRE6.0 2009年4月7日GoogleAppEngine开始支持Java 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。 2011年7月28日，甲骨文发布java7.0的正式版。 2014年3月19日，甲骨文公司发布java8.0的正式版。 ","date":"2021-07-27","objectID":"/posts/javase/:1:2","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"Java 语言与 Java 虚拟机的关系 什么是 Java 虚拟机 Java 虚拟机(Java Virtual Machine,简称 JVM) 是整个 Java 平台的基石，实现硬件与操作系统无关，编译代码后生成出极小体积，保障用户机器免于恶意代码损害。 JVM 可以看作是一台抽象的计算机。跟真实的计算机一样，它有自己的指令集以及各种运行时内存区域。使用虚拟机来实现一门程序设计语言有许多合理的理由，业界中流传最为久远的虚拟机可能是 UCSD Pascal 的 P-Code 虚拟机。 第一个 JVM 的原型机是由 Sun 公司实现的，它被用在一种类似 PDA（Personal Digital Assistant，俗称掌上电脑）的手持设备上仿真实现 JVM 指令集。时至今日，Oracle 已有许多 JVM 实现应用于移动设备、桌面电脑、服务器等领域。JVM 并不局限于特定的实现技术、主机硬件和操作系统。它不强求使用解释器来执行程序，也可以通过把自己的指令集编译为实际 CPU 的指令来实现，它可以通过微代码来实现，或者甚至直接实现在 CPU 中。 Java 语言与 JVM 的关系 JVM 与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 class 文件格式所关联。class 文件中包含了 JVM 指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。 基于安全方面的考虑，JVM 要求在 class 文件中使用了许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 JVM 接收的有效的 class 文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将 JVM 作为他们语言的产品交付媒介。 如上图所示，在 Java 编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把 Java 的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。当你写好一个 Java 程序后，源语言的语句将由Java 编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel 的 Pentium 微处理器或 IBM 的 System/390 处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。 ","date":"2021-07-27","objectID":"/posts/javase/:1:3","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"2.变量、数据类型和运算符 定义格式 // 数据类型 变量名 = 初始化值; （声明、赋值）int num1 = 123; 使用注意 同一作用域内同一变量不可重复声明 变量必须初始化后才能使用（即必须有值才能使用），否则编译报错 变量的值可在同一类型不断变化 变量命名符合标识符规范，使用驼峰命名法，首字母小写 就近原则 ","date":"2021-07-27","objectID":"/posts/javase/:2:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"变量的分类及作用域 图 1 变量分类 图 2 不同数据类型的成员变量的初始值 成员变量/全局变量/字段：直接定义在类中，方法外的变量 类变量 使用 static 修饰的字段 方法区 实例变量 没有使用 static 修饰的字段 堆 默认是有初始值的，可以先在方法中使用后定义 作用域是整个类 局部变量 方法的形参；2. 方法内中的变量；3.代码块中的变量 没有初始值，必须显式初始化后才能使用 定义局部变量后，系统并未分配内存空间，直到程序为这个变量赋值时，系统才会在所在方法的的栈内存中为局部变量分配内存，并将初始值（基本类型的值或者对象的引用）保存在该内存中 从 定义的位置 开始到所在结束的花括号 ","date":"2021-07-27","objectID":"/posts/javase/:2:1","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"数据类型的分类 图 3 数据类型分类 图 4 基本数据类型范围 图 5 基本类型 ","date":"2021-07-27","objectID":"/posts/javase/:2:2","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"boolean 类型 常量值只能是 true 或 false boolean isMan = true; ","date":"2021-07-27","objectID":"/posts/javase/:2:3","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"字符类型 char 16 位 Unicode 字符集，编码方式为 UTF-16BE UTF-16 使用 2 或者 4 字节表示一个字符，在 65536 以内的占两个字节，而基本上所有汉字的 Unicode 编码在 19968 到 40869 之间，所以一个 char 类型可以存储一个汉字 使用' ' 括起来 49'1'; 65 ‘A’; 97 ‘a’ // 表示形式 char c1 = 'A'; // 使用单个字符 char c2 = 65; // 使用十进制的整数（Unicode 值），[0, 65535] char c3 = '\\u0061'; // 使用十六进制的整数，格式'\\uXXXX'，('\\u0000'~'\\u00FF') ","date":"2021-07-27","objectID":"/posts/javase/:2:4","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"运算符 // 算数运算符 + - * / % ++ -- // 比较运算符 == != \u003c \u003e \u003c= \u003e= instanceof // 三目运算符 String ret = number % 2 == 0 ? \"偶数\" : \"奇数\"; // 逻辑运算符 \u0026\u0026 || ^ ! // 位运算符 \u0026 | ~ \u003c\u003c \u003e\u003e \u003e\u003e\u003e 自增 ++ 自减 — 自增、自减操作都是直接修改变量的值（读、改、写），不经过操作数栈 前置 ( ++i )：局部变量表中的 i 先自增，再把 i 的值压入操作数栈 后置 ( i++ )：先把局部变量表中的 i 压入操作数栈，再自增 int i = 1;i = ++i;System.out.println(i); // 2int j = 1;j = j++;System.out.println(j); // 1 ","date":"2021-07-27","objectID":"/posts/javase/:2:5","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"3.流程控制 if-else 语句 if (boolean 表达式 或 boolean 变量) { 条件执行体 1 // 为 true 时执行 } else { 条件执行体 2 // 为 false 时执行 } while 语句 while (boolean 表达式) { 循环体; 迭代语句; // 自增或自减，用于对循环次数的控制 } for循环 for (初始化语句; boolean 表达式; 迭代语句) { 循环体; } 循环控制 break：结束当前 break 所在的整个循环 continue：跳过 continue 所在的本次循环剩下语句，开始下一次循环 ","date":"2021-07-27","objectID":"/posts/javase/:3:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"4.方法 格式 [修饰符] 返回值类型 方法名([参数类型 形参 1, 参数类型 形参 2, ...]) { // 方法体; [return 返回值]; // 当方法需要给调用者返回值时 } 当方法无返回值时，必须给出返回类型 void 参数列表 / 参数清单，包含参数的个数、参数类型、 参数顺序 方法签名：方法名 + 方法参数列表，判断是否是同一个方法的标准 在同一个类中，方法签名是唯一的，否则编译报错 考虑当调用者传入数据的范围不合理时，该如何处理（进行参数校验） ","date":"2021-07-27","objectID":"/posts/javase/:4:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"5.数组 声明 int[] arr; // 数组元素类型[] 数组名; int arr[]; // 数组元素类型 数组名[]; // 不推荐 初始化 // 静态初始化 // 数组名 = new 数组元素类型[] {元素 1, 元素 2, ...}; // 在堆空间开辟一块内存区域来存储数组的元素（new） // 将 该内存区域的地址值 赋值给 该数组的引用变量 arr（引用） int[] arr = new int[] {1, 2, 3}; // 简单写法，必须声明的同时作初始化 // 数组元素类型[] 数组名 = {元素 1, 元素 2, ...}; int[] arr = {1, 2, 3}; // 动态初始化，系统自动为数组元素分配初始值 // 数组名 = new 数组元素类型[length]; int[] arr = new int[3]; // [0, 0, 0] 变量必须初始化后才能使用 数组是定长的：数组一旦初始化完成，数组的长度就固定了，不能更改，除非重新做初始化 数组是引用数据类型，可以赋值为 null，表示没有引用任何内存空间 new 关键字：在堆空间开辟一块内存区域，用来存储数据 操作数组常见异常：NullPointerException：空指针异常（没有引用地址值）ArrayIndexOutOfBoundsException：数组的索引越界异常 基本操作 int[] arr = new int[] {1, 2, 3}; // 访问数组元素 数组变量[索引值] int len = arr.length; // 数组长度，length 是属性，索引范围 [0, arr.length - 1] int num = arr[0]; arr[0] = 11; // 遍历 // 普通 for 循环 for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } // 增强 for 循环（for-each） // 只能访问数组元素，不能赋值，不关心数组的索引时使用 // 当数组元素是引用类型时，不建议使用（需要先知道值不为 null 的元素个数） for (int ele : arr) { System.out.println(ele); } // 反编译后 int ai[] = arr; int k = ai.length; for (int j = 0; j \u003c k; j++) { int i = ai[j]; // 使用循环迭代出数组中的每一个元素并赋值给 i System.out.println(i); // 操作 i } // 打印数组元素 // 直接打印数组名时，打印出来是数组对应的 hashCode 值，如 [I@15db9742, [D@15db9742, [Ljava.lang.String;@15db9742 static String toString(int[] arr) { // 判断数组是否为空 if (arr == null) { return \"null\"; // 结束方法 } if (arr.length == 0) { return \"[]\"; } String ret = \"[\"; // 先拼接\"[\" for (int index = 0; index \u003c arr.length; index++) { // 如果不是最后一个元素，拼接 元素 + \", \"，否则拼接 元素 + \"]\" ret = (index != arr.length - 1) ? ret + arr[index] + \", \" : ret + arr[index] + \"]\"; } return ret; } 二分查找 // 从有序数组中查找 key 第一次出现的位置 // 二分搜索法/二分查找法/折半查找 // 前提：数组的元素是有序排列的 // 区间位置：如果 arr[mid] != key，下一次是以 mid + 1 作为下一个起始位置，或者 mid - 1 作为下一个结束位置 // 退出循环的条件：low \u003e high static int binarySearch(int[] arr, int key) { int low = 0; int high = arr.length - 1; while (low \u003c= high) { int mid = (low + high) \u003e\u003e 1; if (arr[mid] \u003c key) { low = mid + 1; } else if (arr[mid] \u003e key) { high = mid - 1; } else { while (mid - 1 \u003e= 0 \u0026\u0026 arr[mid -1] == key) { mid--; } return mid; } } return -1; } Arrays java.util.Arrays 中的类方法： String toString(Object[] arr)：将 a 数组转换成一个字符串，括在方括号（\"[]\"）中，相邻元素用字符 “, “（逗号加空格）分隔 void sort(Object[] a)：根据元素的自然顺序对指定对象数组按升序进行排序，数组中的所有元素都必须实现 Comparable 接口（对于原始数据类型，使用所谓双轴快速排序（Dual-Pivot QuickSort），对于对象数据类型，使用 TimSort） void sort(T[] a, Comparator\u003c? super T\u003e c)：根据指定比较器产生的顺序对指定对象数组进行排序 void parallelSort(Object[] a)：以并发的方式对 a 数组的数组元素进行排序 void setAll(T[] array, IntFunction\u003cT\u003e generator)：使用提供的函数计算每一个元素的值，对指定数组中的所有元素进行设置 void parallelSetAll(T[] array, IntFunction\u003cT\u003e generator)：以并发的方式，使用提供的函数计算每一个元素的值，对指定数组中的所有元素进行设置 type binarySearch(Object[] a, type key)：使用二分法査询 key 元素值在 a 数组中出现的索引，如果 a 数组不包含 key 元素值，则返回 -(low + 1)（调用该方法时要求数组中元素已经按升序排列） boolean equals(Object[] a, Object[] a2)：如果 a 数组和 a2 数组的长度相等，且 a 数组和 a2 数组的数组元素也一一相同，该方法将返回 true Object[] copyOf(Object[] original, int newLength)：复制 original 数组，截取或用 0（数值类型）、false（布尔类型）或者 null（引用类型）填充，以使新数组的长度为 newLength List\u003cT\u003e asList(T… a)：把一个引用类型的数组或指定个数的对象转换成固定长度的 List（Arrays.ArrayList），只能遍历访问该集合里的元素，不可增加、删除该集合里的元素，否则会引发 UnsupportedOperationException ","date":"2021-07-27","objectID":"/posts/javase/:5:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"6.java修饰符 图 1 修饰符适用范围 访问权限修饰符 用于控制一个类的成员是否可以在其它类中访问，不能修饰局部变量 图 2 访问权限修饰符 private（当前类访问权限）：在同一类内可见，只能被所属类访问 （包访问权限）：不使用任何修饰符时，在同一包内可见 protected（子类访问权限）：对同一包内的任何其它类和不同包中的子类可见，不能修饰接口中的成员变量和成员方法（注意：在不同包中的子类只能通过该子类访问父类中 protected 成员，通过其它子类或父类都无法访问） public（公共访问权限）：对所有类可见 非访问修饰符 static 用来创建类方法和类变量，类方法不能访问的实例变量 final 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不可修改 abstract 用来创建抽象类、抽象方法 synchronized 修饰的方法、代码块在同一时间只能被一个线程访问，不能修饰构造器、成员变量等 volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值；并且，当成员变量发生变化时，强迫线程将变化值回写到共享内存（保证了线程操作时变量的可见性，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的）（只能保证内存可见性，无法保证操作的原子性） transient 序列化的对象包含被 transient 修饰的实例变量时，JVM 跳过该特定的变量 native 修饰的方法通常采用 C/C++ 语言来实现 volatile 的实现原理 如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到内存，这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效 缓存一致性协议（如 Intel 的 MESI 协议）：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里 final 修饰符 表示最终的类，不可被继承的类 java 里 final 修饰的类有很多，比如八大基本数据类型包装类和 String 类，也是不可变类（当创建它们的实例后，其实例的实例变量不可改变） final 修饰的方法 最终的方法，该方法子类可以调用，但不允许被子类覆盖 构造方法不能使用 final 修饰 final 修饰的变量 最终的变量，常量，该变量只能被赋值一次 final 修饰的成员变量必须显式指定初始值（定义时、初始化块或构造器中指定），系统不会为 final 字段初始化；静态常量的单词全部大写，单词间使用下划线隔开 final int MAX_VALUE = …; final 是唯一可以修饰局部变量的修饰符 final 修饰基本类型的变量，表示该变量不能被重新赋值 final 修饰引用类型的变量，表示该变量所引用的地址不能变，而所引用对象的内容可以改变 可执行“宏替换”的 final 变量：当定义 final 变量时就为该变量指定了初始值，编译器会把程序中所有用到该变量的地方直接替换成该变量的值（在编译阶段能确定的内容只能来自于常量池中） ","date":"2021-07-27","objectID":"/posts/javase/:6:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["JAVA"],"content":"7.类与对象 定义 对象是类的实例，类是对象的抽象 类可被认为是一种自定义的数据类型，可以使用类来定义变量 类中的成员：字段（成员变量）、构造器、方法、初始化块、内部类（包括接口、枚举） 外部类只能有两种访问控制级别：public 和 缺省 定义类的语法格式 [修饰符] class 类名 { 0-N 成员变量（字段） // 描述类具有的特性，对象的状态 0-N 构造器定义 0-N 方法 // 描述类具有的功能，对象的行为 } ","date":"2021-07-27","objectID":"/posts/javase/:7:0","tags":["JavaSE"],"title":"JavaSE","uri":"/posts/javase/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"1. 异步编程介绍 除了顺序执行和并行执行的模型之外，还有第三种模型，叫做异步模型，这是事件驱动模型的基础。异步活动的执行模型可以只有一个单一的主控制流，能在单核心系统和多核心系统中运行。 在并发执行的异步模型中，许多任务被穿插在同一时间线上，所有的任务都由一个控制流执行（单一线程）。任务的执行可能被暂停或恢复，中间的这段时间线程将会去执行其他任务。下面的这幅图可以清楚地表达这个概念。 如上图所示，任务（不同的颜色表示不同的任务）可能被其他任务插入，但是都处在同一个线程下。这表明，当某一个任务执行的时候，其他的任务都暂停了。与多线程编程模型很大的一点不同是， 多线程由操作系统决定在时间线上什么时候挂起某个活动或恢复某个活动，而在异步并发模型中，程序员必须假设线程可能在任何时间被挂起和替换。 程序员可以将任务编写成许多可以间隔执行的小步骤， 这样的话如果一个任务需要另一个任务的输出，那么被依赖的任务必须接收它的输入。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:1:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2. 使用Python的 concurrent.futures 模块 Python3.2带来了 concurrent.futures 模块，这个模块具有线程池和进程池、管理并行编程任务、处理非确定性的执行流程、进程/线程同步等功能。 此模块由以下部分组成： concurrent.futures.Executor: 这是一个虚拟基类，提供了异步执行的方法。 submit(function, argument): 调度函数（可调用的对象）的执行，将 argument 作为参数传入。 map(function, argument): 将 argument 作为参数执行函数，以 异步 的方式。 shutdown(Wait=True): 发出让执行者释放所有资源的信号。 concurrent.futures.Future: 其中包括函数的异步执行。Future对象是submit任务（即带有参数的functions）到executor的实例。 Executor是抽象类，可以通过子类访问，即线程或进程的 ExecutorPools 。因为，线程或进程的实例是依赖于资源的任务，所以最好以“池”的形式将他们组织在一起，作为可以重用的launcher或executor。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.1. 使用线程池和进程池 线程池或进程池是用于在程序中优化和简化线程/进程的使用。通过池，你可以提交任务给executor。池由两部分组成，一部分是内部的队列，存放着待执行的任务；另一部分是一系列的进程或线程，用于执行这些任务。池的概念主要目的是为了重用：让线程或进程在生命周期内可以多次使用。它减少了创建创建线程和进程的开销，提高了程序性能。重用不是必须的规则，但它是程序员在应用中使用池的主要原因。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:1","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.2. 准备工作 current.Futures 模块提供了两种 Executor 的子类，各自独立操作一个线程池和一个进程池。这两个子类分别是： concurrent.futures.ThreadPoolExecutor(max_workers) concurrent.futures.ProcessPoolExecutor(max_workers) max_workers 参数表示最多有多少个worker并行执行任务。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:2","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.3. 代码 下面的示例代码展示了线程池和进程池的功能。这里的任务是，给一个list number_list ，包含1到10。对list中的每一个数字，乘以1+2+3…+10000000的和（这个任务只是为了消耗时间）。 下面的代码分别测试了： 顺序执行 通过有5个worker的线程池执行 通过有5个worker的进程池执行 import concurrent.futures import time number_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def evaluate_item(x): # 计算总和，这里只是为了消耗时间 result_item = count(x) # 打印输入和输出结果 return result_item def count(number) : for i in range(0, 10000000): i=i+1 return i * number if __name__ == \"__main__\": # 顺序执行 start_time = time.time() for item in number_list: print(evaluate_item(item)) print(\"Sequential execution in \" + str(time.time() - start_time), \"seconds\") # 线程池执行 start_time_1 = time.time() with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor: futures = [executor.submit(evaluate_item, item) for item in number_list] for future in concurrent.futures.as_completed(futures): print(future.result()) print (\"Thread pool execution in \" + str(time.time() - start_time_1), \"seconds\") # 进程池 start_time_2 = time.time() with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor: futures = [executor.submit(evaluate_item, item) for item in number_list] for future in concurrent.futures.as_completed(futures): print(future.result()) print (\"Process pool execution in \" + str(time.time() - start_time_2), \"seconds\") 运行结果 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:3","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"2.4 代码解释 我们创建了一个list存放10个数字，然后使用一个循环计算从1加到10000000，打印出和与 number_list 的乘积。: def evaluate_item(x): # 计算总和，这里只是为了消耗时间 result_item = count(x) # 打印输入和输出结果 print (\"item \" + str(x) + \" result \" + str(result_item)) def count(number) : for i in range(0, 10000000): i=i+1 return i * number 在主要程序中，我们先使用顺序执行跑了一次程序：: if __name__ == \"__main__\": # 顺序执行 start_time = time.clock() for item in number_list: evaluate_item(item) print(\"Sequential execution in \" + str(time.clock() - start_time), \"seconds\") 然后，我们使用了 futures.ThreadPoolExecutor 模块的线程池跑了一次：: with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor: for item in number_list: executor.submit(evaluate_item, item) print (\"Thread pool execution in \" + str(time.clock() - start_time_1), \"seconds\") ThreadPoolExecutor 使用线程池中的一个线程执行给定的任务。池中一共有5个线程，每一个线程从池中取得一个任务然后执行它。当任务执行完成，再从池中拿到另一个任务。 当所有的任务执行完成后，打印出执行用的时间：: print (\"Thread pool execution in \" + str(time.clock() - start_time_1), \"seconds\") 最后，我们又用 ProcessPoolExecutor 跑了一次程序：: with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor: for item in number_list: executor.submit(evaluate_item, item) 如同 ThreadPoolExecutor 一样， ProcessPoolExecutor 是一个executor，使用一个线程池来并行执行任务。然而，和 ThreadPoolExecutor 不同的是， ProcessPoolExecutor 使用了多核处理的模块，让我们可以不受GIL的限制，大大缩短执行时间。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:2:4","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3. 使用Asyncio管理事件循环 Python的Asyncio模块提供了管理事件、协程、任务和线程的方法，以及编写并发代码的原语。此模块的主要组件和概念包括： 事件循环: 在Asyncio模块中，每一个进程都有一个事件循环。 协程: 这是子程序的泛化概念。协程可以在执行期间暂停，这样就可以等待外部的处理（例如IO）完成之后，从之前暂停的地方恢复执行。 Futures: 定义了 Future 对象，和 concurrent.futures 模块一样，表示尚未完成的计算。 Tasks: 这是Asyncio的子类，用于封装和管理并行模式下的协程。 本节中重点讨论事件，事实上，异步编程的上下文中，事件无比重要。因为事件的本质就是异步。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.1. 什么是事件循环 在计算系统中，可以产生事件的实体叫做事件源，能处理事件的实体叫做事件处理者。此外，还有一些第三方实体叫做事件循环。它的作用是管理所有的事件，在整个程序运行过程中不断循环执行，追踪事件发生的顺序将它们放到队列中，当主线程空闲的时候，调用相应的事件处理者处理事件。最后，我们可以通过下面的伪代码来理解事件循环：: while (1) { events = getEvents(); for (e in events) processEvent(e); } 所有的事件都在 while 循环中捕捉，然后经过事件处理者处理。事件处理的部分是系统唯一活跃的部分，当一个事件处理完成，流程继续处理下一个事件。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:1","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.2. 准备工作 Asyncio提供了一下方法来管理事件循环： loop = get_event_loop(): 得到当前上下文的事件循环。 loop.call_later(time_delay, callback, argument): 延后 time_delay 秒再执行 callback 方法。 loop.call_soon(callback, argument): 尽可能快调用 callback, call_soon() 函数结束，主线程回到事件循环之后就会马上调用 callback 。 loop.time(): 以float类型返回当前时间循环的内部时间。 asyncio.set_event_loop(): 为当前上下文设置事件循环。 asyncio.new_event_loop(): 根据此策略创建一个新的时间循环并返回。 loop.run_forever(): 在调用 stop() 之前将一直运行。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:2","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.3. 代码 下面的代码中，我们将展示如何使用Asyncio库提供的时间循环创建异步模式的应用。 import asyncio import datetime import time def function_1(end_time, loop): print (\"function_1 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_2, end_time, loop) else: loop.stop() def function_2(end_time, loop): print (\"function_2 called \") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_3, end_time, loop) else: loop.stop() def function_3(end_time, loop): print (\"function_3 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_1, end_time, loop) else: loop.stop() def function_4(end_time, loop): print (\"function_5 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_4, end_time, loop) else: loop.stop() loop = asyncio.get_event_loop() end_loop = loop.time() + 9.0 loop.call_soon(function_1, end_loop, loop) # loop.call_soon(function_4, end_loop, loop) loop.run_forever() loop.close() 运行结果如下：: python3 event.pyfunction_1 calledfunction_2 calledfunction_3 calledfunction_1 calledfunction_2 calledfunction_3 calledfunction_1 calledfunction_2 calledfunction_3 called ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:3:3","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3.4. 代码解释 在这个例子中，我们定义了三个异步的任务，相继执行，入下图所示的顺序。 首先，我们要得到这个事件循环：: loop = asyncio.get_event_loop() 然后我们通过 call_soon 方法调用了 function_1() 函数。 end_loop = loop.time() + 9.0loop.call_soon(function_1, end_loop, loop) 让我们来看一下 function_1() 的定义：: def function_1(end_time, loop): print (\"function_1 called\") if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_2, end_time, loop) else: loop.stop() 这个函数通过以下参数定义了应用的异步行为： end_time: 定义了 function_1() 可以运行的最长时间，并通过 call_later 方法传入到 function_2() 中作为参数 loop: 之前通过 get_event_loop() 方法得到的事件循环 function_1() 的任务非常简单，只是打印出函数名字。当然，里面也可以写非常复杂的操作。 print (\"function_1 called\") 任务执行结束之后，它将会比较 loop.time() +1s和设定的运行时间，如果没有超过，使用 call_later 在1秒之后执行 function_2() 。 if (loop.time() + 1.0) \u003c end_time: loop.call_later(1, function_2, end_time, loop)else: loop.stop() function_2() 和 function_3() 的作用类似。 如果运行的时间超过了设定，时间循环终止。 loop.run_forever()loop.close() ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:4:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4. 使用Asyncio控制任务 Asyncio是用来处理事件循环中的异步进程和并发任务执行的。它还提供了 asyncio.Task() 类，可以在任务中使用协程。它的作用是，在同一事件循环中,运行某一个任务的同时可以并发地运行多个任务。当协程被包在任务中，它会自动将任务和事件循环连接起来，当事件循环启动的时候，任务自动运行。这样就提供了一个可以自动驱动协程的机制。 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:0","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4.1. 准备工作 Asyncio模块为我们提供了 asyncio.Task(coroutine) 方法来处理计算任务，它可以调度协程的执行。任务对协程对象在事件循环的执行负责。如果被包裹的协程要从future yield，那么任务会被挂起，等待future的计算结果。 当future计算完成，被包裹的协程将会拿到future返回的结果或异常（exception）继续执行。另外，需要注意的是，事件循环一次只能运行一个任务，除非还有其它事件循环在不同的线程并行运行，此任务才有可能和其他任务并行。当一个任务在等待future执行的期间，事件循环会运行一个新的任务。 \"\"\"Asyncio using Asyncio.Task to execute three math function in parallel\"\"\"import asyncio@asyncio.coroutinedef factorial(number): f = 1 for i in range(2, number + 1): print(\"Asyncio.Task: Compute factorial(%s)\" % (i)) yield from asyncio.sleep(1) f *= i print(\"Asyncio.Task - factorial(%s) = %s\" % (number, f))@asyncio.coroutinedef fibonacci(number): a, b = 0, 1 for i in range(number): print(\"Asyncio.Task: Compute fibonacci (%s)\" % (i)) yield from asyncio.sleep(1) a, b = b, a + b print(\"Asyncio.Task - fibonacci(%s) = %s\" % (number, a))@asyncio.coroutinedef binomialCoeff(n, k): result = 1 for i in range(1, k+1): result = result * (n-i+1) / i print(\"Asyncio.Task: Compute binomialCoeff (%s)\" % (i)) yield from asyncio.sleep(1) print(\"Asyncio.Task - binomialCoeff(%s , %s) = %s\" % (n, k, result))if __name__ == \"__main__\": tasks = [asyncio.Task(factorial(10)), asyncio.Task(fibonacci(10)), asyncio.Task(binomialCoeff(20, 10))] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) loop.close() ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:1","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4.2. 如何做… 在下面的代码中，我们展示了三个可以被 Asyncio.Task() 并发执行的数学函数。 运行的结果如下： python3 task.pyAsyncio.Task: Compute factorial(2)Asyncio.Task: Compute fibonacci (0)Asyncio.Task: Compute binomialCoeff (1)Asyncio.Task: Compute factorial(3)Asyncio.Task: Compute fibonacci (1)Asyncio.Task: Compute binomialCoeff (2)Asyncio.Task: Compute factorial(4)Asyncio.Task: Compute fibonacci (2)Asyncio.Task: Compute binomialCoeff (3)Asyncio.Task: Compute factorial(5)Asyncio.Task: Compute fibonacci (3)Asyncio.Task: Compute binomialCoeff (4)Asyncio.Task: Compute factorial(6)Asyncio.Task: Compute fibonacci (4)Asyncio.Task: Compute binomialCoeff (5)Asyncio.Task: Compute factorial(7)Asyncio.Task: Compute fibonacci (5)Asyncio.Task: Compute binomialCoeff (6)Asyncio.Task: Compute factorial(8)Asyncio.Task: Compute fibonacci (6)Asyncio.Task: Compute binomialCoeff (7)Asyncio.Task: Compute factorial(9)Asyncio.Task: Compute fibonacci (7)Asyncio.Task: Compute binomialCoeff (8)Asyncio.Task: Compute factorial(10)Asyncio.Task: Compute fibonacci (8)Asyncio.Task: Compute binomialCoeff (9)Asyncio.Task - factorial(10) = 3628800Asyncio.Task: Compute fibonacci (9)Asyncio.Task: Compute binomialCoeff (10)Asyncio.Task - fibonacci(10) = 55Asyncio.Task - binomialCoeff(20 , 10) = 184756.0 ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:2","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"4.3. 代码解释 在这个例子中，我们定义了三个协程， factorial, fibonacci 和 binomialCoeff ，每一个都带有 asyncio.coroutine 装饰器： @asyncio.coroutinedef factorial(number): do Something@asyncio.coroutinedef fibonacci(number): do Something@asyncio.coroutinedef binomialCoeff(n, k): do Something 为了能并行执行这三个任务，我们将其放到一个task的list中： if __name__ == \"__main__\": tasks = [asyncio.Task(factorial(10)), asyncio.Task(fibonacci(10)), asyncio.Task(binomialCoeff(20, 10))] 得到事件循环： loop = asyncio.get_event_loop() 然后运行任务： loop.run_until_complete(asyncio.wait(tasks)) 这里， asyncio.wait(tasks) 表示运行直到所有给定的协程都完成。 最后，关闭事件循环： loop.close() ","date":"2021-07-27","objectID":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/:5:3","tags":["python高性能编程"],"title":"异步编程","uri":"/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"1. 介绍 multiprocessing 是Python标准库中的模块，实现了共享内存机制，也就是说，可以让运行在不同处理器核心的进程能读取共享内存。 mpi4py 库实现了消息传递的编程范例（设计模式）。简单来说，就是进程之间不靠任何共享信息来进行通讯（也叫做shared nothing），所有的交流都通过传递信息代替。 这方面与使用共享内存通讯，通过加锁或类似机制实现互斥的技术行成对比。在信息传递的代码中，进程通过 send() 和 receive 进行交流。 在Python多进程的官方文档中，明确指出 multiprocessing 模块要求，使用此模块的函数的main模块对子类来说必须是可导入的（ https://docs.python.org/3.3/library/multiprocessing.html ）。 __main__ 在IDLE中并不是可以导入的，即使你在IDLE中将文件当做一个脚本来运行。为了能正确使用此模块，本章我们将在命令行使用下面的命令运行脚本： python multiprocessing example.py ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:1:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2. 多进程基本使用 “产生”（spawn）的意思是，由父进程创建子进程。父进程既可以在产生子进程之后继续异步执行，也可以暂停等待子进程创建完成之后再继续执行。Python的multiprocessing库通过以下几步创建进程： 创建进程对象 调用 start() 方法，开启进程的活动 调用 join() 方法，在进程结束之前一直等待 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2.1. 代码 下面的例子创建了5个进程，每一个进程都分配了 foo(i) 函数， i 表示进程的id： # -*- coding: utf-8 -*- import multiprocessing def foo(i): print ('called function in process: %s' %i) return if __name__ == '__main__': Process_jobs = [] for i in range(5): p = multiprocessing.Process(target=foo, args=(i,)) Process_jobs.append(p) p.start() p.join() 执行本例需要打开命令行，到文件 spawn_a_process.py （脚本名字）所在的目录下，然后输入下面的命令执行： python spawn_a_process.py 我们会得到以下结果： $ python process_2.py called function in process: 0 called function in process: 1 called function in process: 2 called function in process: 3 called function in process: 4 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2.2. 解释 按照本节前面提到的步骤，创建进程对象首先需要引入multiprocessing模块： import multiprocessing 然后，我们在主程序中创建进程对象： p = multiprocessing.Process(target=foo, args=(i,)) 最后，我们调用 start() 方法启动： p.start() 进程对象的时候需要分配一个函数，作为进程的执行任务，本例中，这个函数是 foo() 。我们可以用元组的形式给函数传递一些参数。最后，使用进程对象调用 join() 方法。 如果没有 join() ，主进程退出之后子进程会留在idle中，你必须手动杀死它们。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2.3. 了解更多 这是因为，子进程创建的时候需要导入包含目标函数的脚本。通过在 __main__ 代码块中实例化进程对象，我们可以预防无限递归调用。最佳实践是在不同的脚本文件中定义目标函数，然后导入进来使用。所以上面的代码可以修改为： import multiprocessing import target_function if __name__ == '__main__': Process_jobs = [] for i in range(5): p = multiprocessing.Process(target=target_function.function,args=(i,)) Process_jobs.append(p) p.start() p.join() target_function.py 的内容如下： def function(i): print('called function in process: %s' %i) return 输出和上面一样。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:3","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3. 线程命名 命名进程的方法和前一章中介绍的命名线程差不多 下面的代码在主程序中创建了一个有名字的进程和一个没有名字的进程，目标函数都是 foo() 函数。 # 命名一个进程 import multiprocessing import time def foo(): name = multiprocessing.current_process().name print(\"Starting %s\\n\" % name) time.sleep(3) print(\"Exiting %s\\n\" % name) if __name__ == '__main__': process_with_name = multiprocessing.Process(name='foo_process', target=foo) process_with_name.daemon = True # 注意原代码有这一行，但是译者发现删掉这一行才能得到正确输出 process_with_default_name = multiprocessing.Process(target=foo) process_with_name.start() process_with_default_name.start() 运行上面的代码，打开终端输入: python naming_process.py 输出的结果如下： $ python naming_process.pyStarting foo_processStarting Process-2Exiting foo_processExiting Process-2 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3.2. 讨论 这个过程和命名线程很像。命名进程需要为进程对象提供 name 参数： process_with_name = multiprocessing.Process(name='foo_process', target=foo) 在本例子中，进程的名字就是 foo_function 。如果子进程需要知道父进程的名字，可以使用以下声明： name = multiprocessing.current_process().name 然后就能看见父进程的名字。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"4. 后台守护进程 如果需要处理比较巨大的任务，又不需要人为干预，将其作为后台进程执行是个非常常用的编程模型。此进程又可以和其他进程并发执行。通过Python的multiprocessing模块的后台进程选项，我们可以让进程在后台运行。 import multiprocessingimport timedef foo(): name = multiprocessing.current_process().name print(\"Starting %s\" % name) time.sleep(3) print(\"Exiting %s\" % name)if __name__ == '__main__': background_process = multiprocessing.Process(name='background_process', target=foo) background_process.daemon = True NO_background_process = multiprocessing.Process(name='NO_background_process', target=foo) NO_background_process.daemon = False background_process.start() NO_background_process.start() #注释掉这一句讲没有任何输出 运行结果： $ python background_process.pyStarting NO_background_processExiting NO_background_process 为了在后台运行进程，我们设置 daemon 参数为 True background_process.daemon = True 在非后台运行的进程会看到一个输出，后台运行的没有输出，后台运行进程在主进程结束之后会自动结束。 注意，后台进程不允许创建子进程。否则，当后台进程跟随父进程退出的时候，子进程会变成孤儿进程。另外，它们并不是Unix的守护进程或服务（daemons or services），所以当非后台进程退出，它们会被终结。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5.杀掉一个进程 我们可以使用 terminate() 方法立即杀死一个进程。另外，我们可以使用 is_alive() 方法来判断一个进程是否还存活。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5.1 代码 import multiprocessingimport timedef foo(): print('Starting function') time.sleep(0.1) print('Finished function')if __name__ == '__main__': p = multiprocessing.Process(target=foo) print('Process before execution:', p, p.is_alive()) p.start() print('Process running:', p, p.is_alive()) p.terminate() print('Process terminated:', p, p.is_alive()) p.join() print('Process joined:', p, p.is_alive()) print('Process exit code:', p.exitcode) 运行结果： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5.2 解释 我们创建了一个线程，然后用 is_alive() 方法监控它的声明周期。然后通过调用 terminate() 方法结束进程。 最后，我们通过读进程的 ExitCode 状态码（status code）验证进程已经结束， ExitCode 可能的值如下： == 0: 没有错误正常退出 \u003e 0: 进程有错误，并以此状态码退出 \u003c 0: 进程被 -1 * 的信号杀死并以此作为 ExitCode 退出 在我们的例子中，输出的 ExitCode 是 -15 。负数表示子进程被数字为15的信号杀死。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6. 自定义进程 实现一个自定义的进程子类，需要以下三步： 定义 Process 的子类 覆盖 __init__(self [,args]) 方法来添加额外的参数 覆盖 run(self, [.args]) 方法来实现 Process 启动的时候执行的任务 创建 Porcess 子类之后，你可以创建它的实例并通过 start() 方法启动它，启动之后会运行 run() 方法。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.1 代码 我们将使用子类的形式重写之前的例子： # -*- coding: utf-8 -*-# 自定义子类进程import multiprocessingclass MyProcess(multiprocessing.Process): def run(self): print(\"Called run method in process: %s\" % self.name) returnif __name__ == \"__main__\": jobs = [] for i in range(5): p = MyProcess() jobs.append(p) p.start() p.join() 输入以下命令运行脚本： python subclass_process.py ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.2 解释 每一个继承了 Process 并重写了 run() 方法的子类都代表一个进程。此方法是进程的入口： class MyProcess(multiprocessing.Process): def run(self): print ('called run method in process: %s' % self.name) return 在主程序中，我们创建了一些 MyProcess() 的子类。当 start() 方法被调用的时候进程开始执行： p = MyProcess()p.start() join() 命令可以让主进程等待其他进程结束最后退出 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7. 进程间对象交换 并行应用常常需要在进程之间交换数据。Multiprocessing库有两个Communication Channel可以交换对象：队列(queue)和管道（pipe）。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7.1 使用队列交换对象 我们可以通过队列数据结构来共享对象。 Queue 返回一个进程共享的队列，是线程安全的，也是进程安全的。任何可序列化的对象（Python通过 pickable 模块序列化对象）都可以通过它进行交换。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7.2 队列交换对象代码 我们将展示如何使用队列来实现生产者-消费者问题。 Producer 类生产item放到队列中，然后 Consumer 类从队列中移除它们。 import multiprocessingimport randomimport timeclass Producer(multiprocessing.Process): def __init__(self, queue): multiprocessing.Process.__init__(self) self.queue = queue def run(self): for i in range(10): item = random.randint(0, 256) self.queue.put(item) print(\"Process Producer : item %dappended to queue %s\" % (item, self.name)) time.sleep(1) print(\"The size of queue is %s\" % self.queue.qsize())class Consumer(multiprocessing.Process): def __init__(self, queue): multiprocessing.Process.__init__(self) self.queue = queue def run(self): while True: if self.queue.empty(): print(\"the queue is empty\") break else: time.sleep(2) item = self.queue.get() print('Process Consumer : item %dpopped from by %s\\n' % (item, self.name)) time.sleep(1)if __name__ == '__main__': queue = multiprocessing.Queue() process_producer = Producer(queue) process_consumer = Consumer(queue) process_producer.start() process_consumer.start() process_producer.join() process_consumer.join() 运行结果： Chapter 3\u003epython using_queue.pyProcess Producer : item 69 appended to queue producer-1The size of queue is 1Process Producer : item 168 appended to queue producer-1The size of queue is 2Process Consumer : item 69 popped from by consumer-2Process Producer : item 235 appended to queue producer-1The size of queue is 2Process Producer : item 152 appended to queue producer-1The size of queue is 3Process Producer : item 213 appended to queue producer-1Process Consumer : item 168 popped from by consumer-2The size of queue is 3Process Producer : item 35 appended to queue producer-1The size of queue is 4Process Producer : item 218 appended to queue producer-1The size of queue is 5Process Producer : item 175 appended to queue producer-1Process Consumer : item 235 popped from by consumer-2The size of queue is 5Process Producer : item 140 appended to queue producer-1The size of queue is 6Process Producer : item 241 appended to queue producer-1The size of queue is 7Process Consumer : item 152 popped from by consumer-2Process Consumer : item 213 popped from by consumer-2Process Consumer : item 35 popped from by consumer-2Process Consumer : item 218 popped from by consumer-2Process Consumer : item 175 popped from by consumer-2Process Consumer : item 140 popped from by consumer-2Process Consumer : item 241 popped from by consumer-2the queue is empty ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7.3 解释 我们使用 multiprocessing 类在主程序中创建了 Queue 的实例： if __name__ == '__main__': queue = multiprocessing.Queue() 然后我们创建了两个进程，生产者和消费者， Queue 对象作为一个属性。 process_producer = Producer(queue)process_consumer = Consumer(queue) 生产者类负责使用 put() 方法放入10个item： for i in range(10): item = random.randint(0, 256) self.queue.put(item) 消费者进程负责使用 get() 方法从队列中移除item，并且确认队列是否为空，如果为空，就执行 break 跳出 while 循环： def run(self): while True: if self.queue.empty(): print(\"the queue is empty\") break else: time.sleep(2) item = self.queue.get() print('Process Consumer : item %dpopped from by %s\\n' % (item, self.name)) time.sleep(1) ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:3","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8. 进程池 多进程库提供了 Pool 类来实现简单的多进程任务。 Pool 类有以下方法： apply(): 直到得到结果之前一直阻塞。 apply_async(): 这是 apply() 方法的一个变体，返回的是一个result对象。这是一个异步的操作，在所有的子类执行之前不会锁住主进程。 map(): 这是内置的 map() 函数的并行版本。在得到结果之前一直阻塞，此方法将可迭代的数据的每一个元素作为进程池的一个任务来执行。 map_async(): 这是 map() 方法的一个变体，返回一个result对象。如果指定了回调函数，回调函数应该是callable的，并且只接受一个参数。当result准备好时会自动调用回调函数（除非调用失败）。回调函数应该立即完成，否则，持有result的进程将被阻塞。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:0","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.1 代码 下面的例子展示了如果通过进程池来执行一个并行应用。我们创建了有4个进程的进程池，然后使用 map() 方法进行一个简单的计算。 import multiprocessingdef function_square(data): result = data*data return resultif __name__ == '__main__': inputs = list(range(100)) pool = multiprocessing.Pool(processes=4) pool_outputs = pool.map(function_square, inputs) pool.close() pool.join() print ('Pool :', pool_outputs) 计算的结果如下： $ python poll.py('Pool :', [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6889, 7056, 7225, 7396, 7569, 7744, 7921, 8100, 8281, 8464, 8649, 8836, 9025, 9216, 9409, 9604, 9801]) ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:1","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.2 解释 multiprocessing.Pool 方法在输入元素上应用 function_square 方法来执行简单的计算。并行的进程数量是4： pool = multiprocessing.Pool(processes=4) pool.map 方法将一些独立的任务提交给进程池： pool_outputs = pool.map(function_square, inputs) input 是一个从 0 到 100 的list： inputs = list(range(100)) 计算的结果存储在 pool_outputs 中。最后的结果打印出来： print ('Pool :', pool_outputs) 需要注意的是， pool.map() 方法的结果和Python内置的 map() 结果是相同的，不同的是 pool.map() 是通过多个并行进程计算的。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:2","tags":["python高性能编程"],"title":"基于进程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"1. 线程介绍 目前，在软件应用中使用最广泛的并发编程范例是多线程。通常，一个应用有一个进程，分成多个独立的线程，并行运行、互相配合，执行不同类型的任务。 主要特点： 线程是独立的处理流程，可以和系统的其他线程并行或并发地执行。 多线程可以共享数据和资源，利用所谓的共享内存空间。 同一进程的多个不同的线程可以共享相同的资源。相比而言，进程之间不会共享资源。 每一个线程基本上包含3个元素：程序计数器，寄存器和栈。与同一进程的其他线程共享的资源基本上包括数据和系统资源。每一个线程也有自己的运行状态，可以和其他线程同步，这点和进程一样。线程的状态大体上可以分为ready,running,blocked。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:1:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"2. python线程模块介绍 Python通过标准库的 threading 模块来管理线程。这个模块提供了很多不错的特性，让线程变得无比简单。实际上，线程模块提供了几种同时运行的机制，实现起来非常简单。 线程模块的主要组件如下： 线程对象 Lock对象 RLock对象 信号对象 条件对象 事件对象 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:2:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3. 定义一个python线程 使用线程最简单的一个方法是，用一个目标函数实例化一个Thread然后调用 start() 方法启动它。Python的threading模块提供了 Thread() 方法在不同的线程中运行函数或处理过程等。 class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}) 上面的代码中： group: 一般设置为 None ，这是为以后的一些特性预留的 target: 当线程启动的时候要执行的函数 name: 线程的名字，默认会分配一个唯一名字 Thread-N args: 传递给 target 的参数，要使用tuple类型 kwargs: 同上，使用字典类型dict 创建线程的方法非常实用，通过target参数arg和kwarg告诉线程应该做什么。下面这个例子传递一个数字给线程（这个数字正好等于线程号码），目标函数会打印出这个数字。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"3.1 代码举例 import threading def function(i): print (\"function called by thread %i\\n\" % i) return threads = [] for i in range(5): # 线程对象 t = threading.Thread(target=function , args=(i, )) threads.append(t) t.start() # 加入主线程队列 t.join() 输出 ✔ python -u thread_simple.py function called by thread 0 function called by thread 1 function called by thread 2 function called by thread 3 function called by thread 4 导入内置threading模块，简单地使用python命令就可以了： import threading 在主程序中，我们使用目标函数 function 初始化了一个线程对象 Thread 。同时还传入了用于打印的一个参数： t = threading.Thread(target=function , args=(i, )) 线程被创建之后并不会马上运行，需要手动调用 start() ， join() 让调用它的线程一直等待直到执行结束（即阻塞调用它的主线程， t 线程执行结束，主线程才会继续执行）： t.start() t.join() ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:3:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"4. 确定线程运行状态 threading模块提供了一些比较实用的方法或者属性 import urllib.request import threading import logging import os logging.basicConfig(level=logging.DEBUG, format='%(asctime)s-%(levelname)s-%(message)s') logger = logging.getLogger(__name__) sites = [ '\u003chttps://www.yahoo.com/\u003e', '\u003chttp://www.cnn.com\u003e', '\u003chttp://www.python.org\u003e', '\u003chttp://www.jython.org\u003e', '\u003chttp://www.pypy.org\u003e', '\u003chttp://www.perl.org\u003e', '\u003chttp://www.cisco.com\u003e', '\u003chttp://www.facebook.com\u003e', '\u003chttp://www.twitter.com\u003e', \"\u003chttps://www.youtube.com/\u003e\", '\u003chttp://arstechnica.com/\u003e', '\u003chttp://www.reuters.com/\u003e', '\u003chttp://abcnews.go.com/\u003e', '\u003chttp://www.cnbc.com/\u003e', ] def getHtml(url): page = urllib.request.urlopen(url).read() print(url, len(page)) for url in sites: threading.Thread(target=getHtml, args=(url,)).start() logger.info(f'Process ID: {os.getpid()}') logger.info(f\"Main thread {threading.main_thread()}\") logger.info(f'Thread Count: {threading.active_count()}') for thread in threading.enumerate(): logger.info(thread) 运行结果： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"给线程命名 使用参数来确认或命名线程是笨拙且没有必要的。每一个 Thread 实例创建的时候都有一个带默认值的名字，并且可以修改。在服务端通常一个服务进程都有多个线程服务，负责不同的操作，这时候命名线程是很实用的 import threading import time def first_function(): print(threading.currentThread().getName() + str(' is Starting ')) time.sleep(2) print (threading.currentThread().getName() + str(' is Exiting ')) return def second_function(): print(threading.currentThread().getName() + str(' is Starting ')) time.sleep(2) print (threading.currentThread().getName() + str(' is Exiting ')) return def third_function(): print(threading.currentThread().getName() + str(' is Starting ')) time.sleep(2) print(threading.currentThread().getName() + str(' is Exiting ')) return if __name__ == \"__main__\": t1 = threading.Thread(name='first_function', target=first_function) t2 = threading.Thread(name='second_function', target=second_function) t3 = threading.Thread(name='third_function', target=third_function) t1.start() t2.start() t3.start() 运行结果: ✔ python -u thread_simple.pyfirst_function is Starting second_function is Starting third_function is Starting first_function is Exiting second_function is Exiting third_function is Exiting ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"解析 我们使用目标函数实例化线程。同时，我们传入 name 参数作为线程的名字，如果不传这个参数，将使用默认的参数： t1 = threading.Thread(name='first_function', target=first_function)t2 = threading.Thread(name='second_function', target=second_function)t3 = threading.Thread(target=third_function) （译者注：这里的代码和上面的不一样，可能作者本意是第三个线程不加参数来测试默认的行为，如果改为这里的代码，那么线程3将会输出的是 Thread-1 is Starting 以及 Thread-1 is Exiting ，读者可以自行尝试） 最后调用 start() 和 join() 启动它们。 t1.start()t2.start()t3.start()t1.join()t2.join()t3.join() ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:4:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"5. 自己动手实现一个线程 使用threading模块实现一个新的线程，需要下面3步： 定义一个 Thread 类的子类 重写 __init__(self [,args]) 方法，可以添加额外的参数 最后，需要重写 run(self, [,args]) 方法来实现线程要做的事情 当你创建了新的 Thread 子类的时候，你可以实例化这个类，调用 start() 方法来启动它。线程启动之后将会执行 run() 方法。 import threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print(\"Starting \" + self.name) print_time(self.name, self.counter, 5) print(\"Exiting \" + self.name)def print_time(threadName, delay, counter): while counter: if exitFlag: # 译者注：原书中使用的thread，但是Python3中已经不能使用thread，以_thread取代，因此应该 # import _thread # _thread.exit() thread.exit() time.sleep(delay) print(\"%s: %s\" % (threadName, time.ctime(time.time()))) counter -= 1# Create new threadsthread1 = myThread(1, \"Thread-1\", 1)thread2 = myThread(2, \"Thread-2\", 2)# Start new Threadsthread1.start()thread2.start()# 以下两行为译者添加，如果要获得和图片相同的结果，# 下面两行是必须的。疑似原作者的疏漏thread1.join()thread2.join()print(\"Exiting Main Thread\") 结果： ✔ python -u thread_run.pyStarting Thread-1Starting Thread-2Thread-1: Thu Jun 24 09:31:43 2021Thread-2: Thu Jun 24 09:31:44 2021Thread-1: Thu Jun 24 09:31:44 2021Thread-1: Thu Jun 24 09:31:45 2021Thread-1: Thu Jun 24 09:31:46 2021Thread-2: Thu Jun 24 09:31:46 2021Thread-1: Thu Jun 24 09:31:47 2021Exiting Thread-1Thread-2: Thu Jun 24 09:31:48 2021Thread-2: Thu Jun 24 09:31:50 2021Thread-2: Thu Jun 24 09:31:52 2021Exiting Thread-2Exiting Main Thread 解释： threading 模块是创建和管理线程的首选形式。每一个线程都通过一个继承 Thread 类，重写 run() 方法来实现逻辑，这个方法是线程的入口。在主程序中，我们创建了多个 myThread 的类型实例，然后执行 start() 方法启动它们。调用 Thread.__init__ 构造器方法是必须的，通过它我们可以给线程定义一些名字或分组之类的属性。调用 start() 之后线程变为活跃状态，并且持续直到 run() 结束，或者中间出现异常。所有的线程都执行完成之后，程序结束。 join() 命令控制主线程的终止。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:5:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6. 线程锁🔒 当两个或以上对共享内存的操作发生在并发线程中，并且至少有一个可以改变数据，又没有同步机制的条件下，就会产生竞争条件，可能会导致执行无效代码、bug、或异常行为。 竞争条件最简单的解决方法是使用锁。锁的操作非常简单，当一个线程需要访问部分共享内存时，它必须先获得锁才能访问。此线程对这部分共享资源使用完成之后，该线程必须释放锁，然后其他线程就可以拿到这个锁并访问这部分资源了。 然而，在实际使用的过程中，我们发现这个方法经常会导致一种糟糕的死锁现象。当不同的线程要求得到一个锁时，死锁就会发生，这时程序不可能继续执行，因为它们互相拿着对方需要的锁。使用锁来解决同步问题是一个可行却存在潜在问题的方案。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.1 代码解释 # -*- coding: utf-8 -*-import threadingshared_resource_with_lock = 0shared_resource_with_no_lock = 0COUNT = 100000shared_resource_lock = threading.Lock()# 有锁的情况def increment_with_lock(): global shared_resource_with_lock for i in range(COUNT): shared_resource_lock.acquire() shared_resource_with_lock += 1 shared_resource_lock.release()def decrement_with_lock(): global shared_resource_with_lock for i in range(COUNT): shared_resource_lock.acquire() shared_resource_with_lock -= 1 shared_resource_lock.release()# 没有锁的情况def increment_without_lock(): global shared_resource_with_no_lock for i in range(COUNT): shared_resource_with_no_lock += 1def decrement_without_lock(): global shared_resource_with_no_lock for i in range(COUNT): shared_resource_with_no_lock -= 1if __name__ == \"__main__\": t1 = threading.Thread(target=increment_with_lock) t2 = threading.Thread(target=decrement_with_lock) t3 = threading.Thread(target=increment_without_lock) t4 = threading.Thread(target=decrement_without_lock) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() print (\"the value of shared variable with lock management is %s\" % shared_resource_with_lock) print (\"the value of shared variable with race condition is %s\" % shared_resource_with_no_lock) 运行结果： ✔ python -u thread_lock.pythe value of shared variable with lock management is 0the value of shared variable with race condition is 67058 可以看出，如果有锁来管理线程的话，我们会得到正确的结果。这里要注意，没有锁的情况下并不一定会得到错误的结果，但是重复执行多次，总会出现错误的结果。而有锁的情况结果总会是正确的。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.2 代码解释 在主程序中，我们有以下步骤： t1 = threading.Thread(target=increment_with_lock)t2 = threading.Thread(target=decrement_with_lock) 启动线程： t1.start()t2.start() 然后阻塞主线程直到所有线程完成： t1.join()t2.join() 在 increment_with_lock() 函数和 decrement_with_lock() 函数中，可以看到我们使用了lock语句。当你需要使用资源的时候，调用 acquire() 拿到锁（如果锁暂时不可用，会一直等待直到拿到），最后调用 release(): shared_resource_lock.acquire()shared_resource_with_lock -= 1shared_resource_lock.release() 让我们总结一下： 锁有两种状态： locked（被某一线程拿到）和unlocked（可用状态） 我们有两个方法来操作锁： acquire() 和 release() 需要遵循以下规则： 如果状态是unlocked， 可以调用 acquire() 将状态改为locked 如果状态是locked， acquire() 会被block直到另一线程调用 release() 释放锁 如果状态是unlocked， 调用 release() 将导致 RuntimError 异常 如果状态是locked， 可以调用 release() 将状态改为unlocked ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"6.3. 线程弊端 尽管理论上行得通，但是锁的策略不仅会导致有害的僵持局面。还会对应用程序的其他方面产生负面影响。这是一种保守的方法，经常会引起不必要的开销，也会限制程序的可扩展性和可读性。更重要的是，有时候需要对多进程共享的内存分配优先级，使用锁可能和这种优先级冲突。最后，从实践的经验来看，使用锁的应用将对debug带来不小的麻烦。所以，最好使用其他可选的方法确保同步读取共享内存，避免竞争条件。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:6:3","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"7. 递归锁RLOCK RLock其实叫做“Reentrant Lock”，就是可以重复进入的锁，也叫做“递归锁”。这种锁对比Lock有是三个特点：1. 谁拿到谁释放。如果线程A拿到锁，线程B无法释放这个锁，只有A可以释放；2. 同一线程可以多次拿到该锁，即可以acquire多次；3. acquire多少次就必须release多少次，只有最后一次release才能改变RLock的状态为unlocked 如果是一把互斥锁（threading.Lock()），那么下面的代码会发生堵塞： import threadinglock = threading.Lock()lock.acquire() for i in range(10): print('获取第二把锁') lock.acquire() print(f'test.......{i}') lock.release() lock.release() 同样的代码，如果换成（threading.RLock()），则不会发生堵塞： import threadinglock = threading.RLock()lock.acquire() for i in range(10): print('获取第二把锁') lock.acquire() print(f'test.......{i}') lock.release() lock.release() RLock其实底层维护了一个互斥锁和一个计数器 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:7:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8. 信号量 信号量也是一把锁，用来控制线程并发数的。BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。 计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念) 类名：BoundedSemaphore。这种锁允许一定数量的线程同时更改数据，它不是互斥锁。比如地铁安检，排队人很多，工作人员只允许一定数量的人进入安检区，其它的人继续排队。 同样的，在threading模块中，信号量的操作有两个函数，即 acquire() 和 release() ，解释如下： 每当线程想要读取关联了信号量的共享资源时，必须调用 acquire() ，此操作减少信号量的内部变量, 如果此变量的值非负，那么分配该资源的权限。如果是负值，那么线程被挂起，直到有其他的线程释放资源。 当线程不再需要该共享资源，必须通过 release() 释放。这样，信号量的内部变量增加，在信号量等待队列中排在最前面的线程会拿到共享资源的权限。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.1 代码 import timeimport threadingdef run(n, se): se.acquire() print(\"run the thread: %s\" % n) time.sleep(1) se.release()# 设置允许5个线程同时运行semaphore = threading.BoundedSemaphore(5)for i in range(20): t = threading.Thread(target=run, args=(i, semaphore)) t.start() 运行结果： ​ ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"8.2 消费者模型的信号量使用 # -*- coding: utf-8 -*-\"\"\"Using a Semaphore to synchronize threads\"\"\"import threadingimport timeimport random# The optional argument gives the initial value for the internal# counter;# it defaults to 1.# If the value given is less than 0, ValueError is raised.semaphore = threading.Semaphore(0)def consumer(): print(\"consumer is waiting.\") # Acquire a semaphore semaphore.acquire() # The consumer have access to the shared resource print(\"Consumer notify : consumed item number %s \" % item)def producer(): global item time.sleep(10) # create a random item item = random.randint(0, 1000) print(\"producer notify : produced item number %s\" % item) # Release a semaphore, incrementing the internal counter by one. # When it is zero on entry and another thread is waiting for it # to become larger than zero again, wake up that thread. semaphore.release()if __name__ == '__main__': for i in range (0,5) : t1 = threading.Thread(target=producer) t2 = threading.Thread(target=consumer) t1.start() t2.start() t1.join() t2.join() print(\"program terminated\") 我们使用生产者-消费者模型展示通过信号量的同步。当生产者生产出item，便释放信号量。然后消费者拿到资源进行消费。 运行结果： ↵ python -u thread_semaphore.pyconsumer is waiting.producer notify : produced item number 328Consumer notify : consumed item number 328 consumer is waiting.producer notify : produced item number 230Consumer notify : consumed item number 230 consumer is waiting.producer notify : produced item number 174Consumer notify : consumed item number 174 consumer is waiting.producer notify : produced item number 573Consumer notify : consumed item number 573 consumer is waiting.producer notify : produced item number 286Consumer notify : consumed item number 286 program terminated ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:8:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"9. 条件线程设置 条件指的是应用程序状态的改变。这是另一种同步机制，其中某些线程在等待某一条件发生，其他的线程会在该条件发生的时候进行通知。一旦条件发生，线程会拿到共享资源的唯一权限。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:9:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"9.1 代码 from threading import Thread, Conditionimport timeitems = []condition = Condition()class consumer(Thread): def __init__(self): Thread.__init__(self) def consume(self): global condition global items condition.acquire() if len(items) == 0: condition.wait() print(\"Consumer notify : no item to consume\") items.pop() print(\"Consumer notify : consumed 1 item\") print(\"Consumer notify : items to consume are \" + str(len(items))) condition.notify() condition.release() def run(self): for i in range(0, 20): time.sleep(2) self.consume()class producer(Thread): def __init__(self): Thread.__init__(self) def produce(self): global condition global items condition.acquire() if len(items) == 10: condition.wait() print(\"Producer notify : items producted are \" + str(len(items))) print(\"Producer notify : stop the production!!\") items.append(1) print(\"Producer notify : total items producted \" + str(len(items))) condition.notify() condition.release() def run(self): for i in range(0, 20): time.sleep(1) self.produce()if __name__ == \"__main__\": producer = producer() consumer = consumer() producer.start() consumer.start() producer.join() consumer.join() 运行结果： (译者在这里添加一段。乍一看这段代码好像会死锁，因为 condition.acquire() 之后就在 .wait() 了，好像会一直持有锁。其实 .wait() 会将锁释放，然后等待其他线程 .notify() 之后会重新尝试获得锁。但是要注意 .notify() 并不会自动释放锁，所以代码中有两行，先 .notify() 然后再 .release() 。 译者画了一张图，方便大家理解。这里的过程应该是这样子的（注意 wait() 里面实际有一个释放锁重新获得锁的过程）： 译者的私货完毕，建议看一下官方文档： https://docs.python.org/3/library/threading.html ) 消费者通过拿到锁来修改共享的资源 items[] ： condition.acquire() 如果list的长度为0，那么消费者就进入等待状态： if len(items) == 0: condition.wait() 否则就通过 pop 操作消费一个item： items.pop() 然后，消费者的状态被通知给生产者，同时共享资源释放： condition.notify()condition.release() 生产者拿到共享资源，然后确认缓冲队列是否已满（在我们的这个例子中，最大可以存放10个item），如果已经满了，那么生产者进入等待状态，直到被唤醒： condition.acquire()if len(items) == 10: condition.wait() 如果队列没有满，就生产1个item，通知状态并释放资源： condition.notify()condition.release() ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:9:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"10. 事件进行线程同步 事件是线程之间用于通讯的对象。有的线程等待信号，有的线程发出信号。基本上事件对象都会维护一个内部变量，可以通过 set() 方法设置为 true ，也可以通过 clear() 方法设置为 false 。 wait() 方法将会阻塞线程，直到内部变量为 true 。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:10:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"10.1 代码 import timefrom threading import Thread, Eventimport randomitems = []event = Event()class consumer(Thread): def __init__(self, items, event): Thread.__init__(self) self.items = items self.event = event def run(self): while True: time.sleep(2) self.event.wait() item = self.items.pop() print('Consumer notify : %dpopped from list by %s' % (item, self.name))class producer(Thread): def __init__(self, items, event): Thread.__init__(self) self.items = items self.event = event def run(self): global item for i in range(100): time.sleep(2) item = random.randint(0, 256) self.items.append(item) print('Producer notify : item N° %dappended to list by %s' % (item, self.name)) print('Producer notify : event set by %s' % self.name) self.event.set() print('Produce notify : event cleared by %s'% self.name) self.event.clear()if __name__ == '__main__': t1 = producer(items, event) t2 = consumer(items, event) t1.start() t2.start() t1.join() t2.join() 线程t1在list最后添加值，然后设置event来通知消费者。消费者通过 wait() 阻塞，直到收到信号的时候从list中取出元素消费。 运行结果： 解释： producer 类初始化时定义了item的list和 Event ，与条件对象时候的例子不同，这里的list并不是全局的，而是通过参数传入的： class consumer(Thread): def __init__(self, items, event): Thread.__init__(self) self.items = items self.event = event 在run方法中，每当item创建， producer 类将新item添加到list末尾然后发出事件通知。使用事件有两步，第一步： self.event.set() 第二步： self.event.clear() consumer 类初始化时也定义了item的list和 Event() 。当item进来的时候，它将其取出： def run(self): while True: time.sleep(2) self.event.wait() item = self.items.pop() print('Consumer notify : %d popped from list by %s' % (item, self.name)) 下图可以帮我们认识 producer 和 consumer ： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:10:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"11. 线程中的with语句 Python从2.5版本开始引入了 with 语法。此语法非常实用，在有两个相关的操作需要在一部分代码块前后分别执行的时候，可以使用 with 语法自动完成。同事，使用 with 语法可以在特定的地方分配和释放资源，因此， with 语法也叫做“上下文管理器”。在threading模块中，所有带有 acquire() 方法和 release() 方法的对象都可以使用上下文管理器。 也就是说，下面的对象可以使用 with 语法： Lock RLock Condition Semaphore ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:11:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"11.1 代码 import threadingimport logginglogging.basicConfig(level=logging.DEBUG, format='(%(threadName)-10s) %(message)s',)def threading_with(statement): with statement: logging.debug('%sacquired via with' % statement)def threading_not_with(statement): statement.acquire() try: logging.debug('%sacquired directly' % statement ) finally: statement.release()if __name__ == '__main__': # let's create a test battery lock = threading.Lock() rlock = threading.RLock() condition = threading.Condition() mutex = threading.Semaphore(1) threading_synchronization_list = [lock, rlock, condition, mutex] # in the for cycle we call the threading_with e threading_no_with function for statement in threading_synchronization_list : t1 = threading.Thread(target=threading_with, args=(statement,)) t2 = threading.Thread(target=threading_not_with, args=(statement,)) t1.start() t2.start() t1.join() t2.join() 运行结果: ↵ python -u thread_with.py(Thread-1 ) \u003clocked _thread.lock object at 0x1019a1450\u003e acquired via with(Thread-2 ) \u003clocked _thread.lock object at 0x1019a1450\u003e acquired directly(Thread-3 ) \u003clocked _thread.RLock object owner=123145583611904 count=1 at 0x1019a1420\u003e acquired via with(Thread-4 ) \u003clocked _thread.RLock object owner=123145583611904 count=1 at 0x1019a1420\u003e acquired directly(Thread-5 ) \u003cCondition(\u003clocked _thread.RLock object owner=123145583611904 count=1 at 0x1019a19c0\u003e, 0)\u003e acquired via with(Thread-6 ) \u003cCondition(\u003clocked _thread.RLock object owner=123145600401408 count=1 at 0x1019a19c0\u003e, 0)\u003e acquired directly(Thread-7 ) \u003cthreading.Semaphore object at 0x101818910\u003e acquired via with(Thread-8 ) \u003cthreading.Semaphore object at 0x101818910\u003e acquired directly ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:11:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"10.2 解释 在主程序中，我们定义了一个list， threading_synchronization_list ，包含要测试的线程同步使用的对象： lock = threading.Lock()rlock = threading.RLock()condition = threading.Condition()mutex = threading.Semaphore(1)threading_synchronization_list = [lock, rlock, condition, mutex] 定义之后，我们可以在 for 循环中测试每一个对象： for statement in threading_synchronization_list : t1 = threading.Thread(target=threading_with, args=(statement,)) t2 = threading.Thread(target=threading_not_with, args=(statement,)) 最后，我们有两个目标函数，其中 threading_with 测试了 with 语法： def threading_with(statement): with statement: logging.debug('%s acquired via with' % statement) ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:11:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"12. 使用队列进行线程通信 当线程之间如果要共享资源或数据的时候，可能变的非常复杂。如你所见，Python的threading模块提供了很多同步原语，包括信号量，条件变量，事件和锁。如果可以使用这些原语的话，应该优先考虑使用这些，而不是使用queue（队列）模块。队列操作起来更容易，也使多线程编程更安全，因为队列可以将资源的使用通过单线程进行完全控制，并且允许使用更加整洁和可读性更高的设计模式。 Queue常用的方法有以下四个： put(): 往queue中放一个item get(): 从queue删除一个item，并返回删除的这个item task_done(): 每次item被处理的时候需要调用这个方法 join(): 所有item都被处理之前一直阻塞 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:12:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"12.2 代码 from threading import Thread, Eventfrom queue import Queueimport timeimport randomclass producer(Thread): def __init__(self, queue): Thread.__init__(self) self.queue = queue def run(self) : for i in range(10): item = random.randint(0, 256) self.queue.put(item) print('Producer notify: item N° %dappended to queue by %s' % (item, self.name)) time.sleep(1)class consumer(Thread): def __init__(self, queue): Thread.__init__(self) self.queue = queue def run(self): while True: item = self.queue.get() print('Consumer notify : %dpopped from queue by %s' % (item, self.name)) self.queue.task_done()if __name__ == '__main__': queue = Queue() t1 = producer(queue) t2 = consumer(queue) t3 = consumer(queue) t4 = consumer(queue) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() 运行结果： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:12:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"12.2 解释 首先，我们创建一个生产者类。由于我们使用队列存放数字，所以不需要用来存放数字的list了。 class producer(Thread): def __init__(self, queue): Thread.__init__(self) self.queue = queue producer 类生产整数，然后通过一个 for 循环将整数放到队列中： def run(self) : for i in range(10): item = random.randint(0, 256) self.queue.put(item) print('Producer notify: item N° %d appended to queue by %s' % (item, self.name)) time.sleep(1) 生产者使用 Queue.put(item [,block[, timeout]]) 来往queue中插入数据。Queue是同步的，在插入数据之前内部有一个内置的锁机制。 可能发生两种情况： 如果 block 为 True ， timeout 为 None （这也是默认的选项，本例中使用默认选项），那么可能会阻塞掉，直到出现可用的位置。如果 timeout 是正整数，那么阻塞直到这个时间，就会抛出一个异常。 如果 block 为 False ，如果队列有闲置那么会立即插入，否则就立即抛出异常（ timeout 将会被忽略）。本例中， put() 检查队列是否已满，然后调用 wait() 开始等待。 消费者从队列中取出整数然后用 task_done() 方法将其标为任务已处理。 消费者使用 Queue.get([block[, timeout]]) 从队列中取回数据，queue内部也会经过锁的处理。如果队列为空，消费者阻塞。 最后，在主程序中，我们创建线程t作为生产者，t1, t2, t3作为消费者： if __name__ == '__main__': queue = Queue() t1 = producer(queue) t2 = consumer(queue) t3 = consumer(queue) t4 = consumer(queue) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() 生产者和消费者之间的操作可以用下图来描述： ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:12:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13. 评估多线程应用的性能 在本节中，我们将验证GIL的影响，评估多线程应用的性能。前文已经介绍过，GIL是CPython解释器引入的锁，GIL在解释器层面阻止了真正的并行运行。解释器在执行任何线程之前，必须等待当前正在运行的线程释放GIL。事实上，解释器会强迫想要运行的线程必须拿到GIL才能访问解释器的任何资源，例如栈或Python对象等。这也正是GIL的目的——阻止不同的线程并发访问Python对象。这样GIL可以保护解释器的内存，让垃圾回收工作正常。但事实上，这却造成了程序员无法通过并行执行多线程来提高程序的性能。如果我们去掉CPython的GIL，就可以让多线程真正并行执行。GIL并没有影响多处理器并行的线程，只是限制了一个解释器只能有一个线程在运行。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:13:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13.1 代码 下面的代码是用来评估多线程应用性能的简单工具。下面的每一个测试都循环调用函数100次，重复执行多次，取速度最快的一次。在 for 循环中，我们调用 non_threaded 和 threaded 函数。同时，我们会不断增加调用次数和线程数来重复执行这个测试。我们会尝试使用1，2，3，4和8线程数来调用线程。在非线程的测试中，我们顺序调用函数与对应线程数一样多的次数。为了保持简单，度量的指标使用Python的内建模块timer。 代码如下： from threading import Threadclass threads_object(Thread): def run(self): function_to_run()class nothreads_object(object): def run(self): function_to_run()def non_threaded(num_iter): funcs = [] for i in range(int(num_iter)): funcs.append(nothreads_object()) for i in funcs: i.run()def threaded(num_threads): funcs = [] for i in range(int(num_threads)): funcs.append(threads_object()) for i in funcs: i.start() for i in funcs: i.join()def function_to_run(): passdef show_results(func_name, results): print(\"%-23s%4.6fseconds\" % (func_name, results))if __name__ == \"__main__\": import sys from timeit import Timer repeat = 100 number = 1 num_threads = [1, 2, 4, 8] print('Starting tests') for i in num_threads: t = Timer(\"non_threaded(%s)\" % i, \"from __main__ import non_threaded\") best_result = min(t.repeat(repeat=repeat, number=number)) show_results(\"non_threaded (%siters)\" % i, best_result) t = Timer(\"threaded(%s)\" % i, \"from __main__ import threaded\") best_result = min(t.repeat(repeat=repeat, number=number)) show_results(\"threaded (%sthreads)\" % i, best_result) print('Iterations complete') ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:13:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13.2. 解释 我们一共进行了四次测试(译者注：原文是three，我怀疑原作者不识数，原文的3个线程数也没有写在代码里），每一次都会使用不同的function进行测试，只要改变 function_to_run() 就可以了。 测试用的机器是 Core 2 Duo CPU – 2.33Ghz。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第一次测试 在第一次测试中，我们使用了一个简单的空函数： def function_to_run(): pass 下图展示了我们测试的每个机制的运行速度： 通过结果可以发现，使用线程的开销要比不使用线程的开销大的多。特别的，我们发现随着线程的数量增加，带来的开销是成比例的。4个线程的运行时间是0.000162秒，8个线程的运行时间是0.000316秒。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:1","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第二次测试 多线程比较常用的一个用途是处理数字，下面的测试计算斐波那契数列，注意这个例子中没有共享的资源，只是测试生成数字数列： def function_to_run(): a, b = 0, 1 for i in range(10000): a, b = b, a + b 输出如下： 在输出中可以看到，提高线程的数量并没有带来收益。因为GIL和线程管理代码的开销，多线程运行永远不可能比函数顺序执行更快。再次提醒一下：GIL只允许解释器一次执行一个线程。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:2","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第三次测试 下面的测试是读1kb的数据1000次，测试用的函数如下： def function_to_run(): fh=open(\"C:\\\\CookBookFileExamples\\\\test.dat\",\"rb\") size = 1024 for i in range(1000): fh.read(size) 测试的结果如下： 我们终于看到多线程比非多线程跑的好的情况了，而且多线程只用了一半的时间。这给我们的启示是，多线程并不是一个标准。一般，我们将会将多线程放入一个队列中，将它们放到一边，执行其他任务。使用多线程执行同一个相同的任务有时候很有用，但用到的时候很少，除非需要大量处理数据输入。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:3","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"第四次测试 在最后的测试中，我们使用 urllib.request 测试，这是一个Python模块，可以发送URL请求。此模块基于 socket ，使用C语言编写并且是线程安全的。 下面的代码尝试读取 https://www.packpub.com 的主页并且读取前1k的数据： def function_to_run(): import urllib.request for i in range(10): with urllib.request.urlopen(\"https://www.packtpub.com/\")as f: f.read(1024) 运行结果如下： 可以看到，在 I/O 期间，GIL释放了。多线程执行比单线程快的多。鉴于大多数应用需要很多I/O操作，GIL并没有限制程序员在这方面使用多线程对程序进行性能优化。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:14:4","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"13.3. 了解更多 你应该记住，增加线程并不会提高应用启动的时间，但是可以支持并发。例如，一次性创建一个线程池，并重用worker会很有用。这可以让我们切分一个大的数据集，用同样的函数处理不同的部分（生产者消费者模型）。上面这些测试并不是并发应用的模型，只是尽量简单的测试。那么GIL会成为试图发挥多线程应用潜能的纯Python开发的瓶颈吗？是的。线程是编程语言的架构，CPython解释器是线程和操作系统的桥梁。这就是为什么Jython，IronPython没有GIL的原因（译者注：Pypy也没有），因为它不是必要的。 ","date":"2021-07-27","objectID":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/:15:0","tags":["python高性能编程"],"title":"基于线程的并行","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"},{"categories":["python"],"content":"Createitv","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"1. 简介 解决一个大问题的一般方法是，将其拆分成若干小的、独立的问题，然后分别解它们。并行的程序也是使用这种方法，用多个处理器同时工作，来完成同一个任务。每一个处理器都做自己的那部分工作（独立的部分）。而且计算过程中处理器之间可能需要交换数据。如果，软件应用要求越来越高的计算能力。提高计算能力有两种思路：提高处理器的时钟速度或增加芯片上的核心数。提高时钟速度就必然会增加散热，然后每瓦特的性能就会降低，甚至可能要求特殊的冷却设备。提高芯片的核心数是更可行的一种方案，因为能源的消耗和散热，第一种方法必然有上限，而且计算能力提高没有特别明显。 为了解决这个问题，计算机硬件供应商的选择是多核心的架构，就是在同一个芯片上放两个或者多个处理器（核心）。GPU制造商也逐渐引进了这种基于多处理器核心的硬件架构。事实上，今天的计算机几乎都是各种多核、异构的计算单元组成的，每一个单元都有多个处理核心。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:1:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2. 并行计算的内存架构 根据指令的同时执行和数据的同时执行，计算机系统可以分成以下四类： 单处理器，单数据 (SISD) 单处理器，多数据 (SIMD) 多处理器，单数据 (MISD) 多处理器，多数据 (MIMD) 这种分类方法叫做“费林分类”: ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.1. SISD 单处理器单数据就是“单CPU的机器”，它在单一的数据流上执行指令。在SISD中，指令被顺序地执行。 对于每一个“CPU时钟”，CPU按照下面的顺序执行： Fetch: CPU 从一片内存区域中（寄存器）获得数据和指令 Decode: CPU对指令进行解码 Execute: 该执行在数据上执行，将结果保存在另一个寄存器中 当Execute阶段完成之后，CPU回到步骤1准备执行下一个时钟循环。 运行在这些计算机上的算法是顺序执行的（连续的），不存在任何并行。只有一个CPU的硬件系统就是SISD的例子。 这种架构（冯·诺依曼体系）的主要元素有以下： 中心内存单元：存储指令和数据 CPU：用于从内存单元获得指令/数据，对指令解码并顺序执行它们 I/O系统：程序的输入和输出流 传统的单处理器计算机都是经典的SISD系统。下图表述了CPU在Fetch、Decode、Execute的步骤中分别用到了哪些单元： ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.2. MISD 这种模型中，有n个处理器，每一个都有自己的控制单元，共享同一个内存单元。在每一个CPU时钟中，从内存获得的数据会被所有的处理器同时处理，每一个处理器按照自己的控制单元发送的指令处理。在这种情况下，并行实际上是指令层面的并行，多个指令在相同的数据上操作。能够合理利用这种架构的问题模型比较特殊，例如数据加密等。因此，MISD在现实中并没有很多用武之地，更多的是作为一个抽象模型的存在。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:2","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.3. SIMD SIMD计算机包括多个独立的处理器，每一个都有自己的局部内存，可以用来存储数据。所有的处理器都在单一指令流下工作；具体说，就是有n个数据流，每个处理器处理一个。所有的处理器同时处理每一步，在不同的数据上执行相同的指令。这是一个数据并行的例子。SIMD架构比MISD架构要实用的多。很多问题都可以用SIMD计算机的架构来解决。这种架构另一个有趣的特性是，这种架构的算法非常好设计，分析和实现。限制是，只有可以被分解成很多个小问题（小问题之间要独立，可以不分先后顺序被相同的指令执行）的问题才可以用这种架构解决。很多超级计算机就是使用这架构设计出来的。例如Connection Machine（1985年的 Thinking Machine)和MPP（NASA-1983）.我们在第六章 GPU Python编程中会接触到高级的现代图形处理器（GPU），这种处理器就是内置了很多个SIMD处理单元，使这种架构在今天应用非常广泛。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:3","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"2.4. MIMD 在费林分类中，这种计算机是最广泛使用、也是最强大的一个种类。这种架构有n个处理器，n个指令流，n个数据流。每一个处理器都有自己的控制单元和局部内存，让MIMD架构比SIMD架构的计算能力更强。每一个处理器都在独立的控制单元分配的指令流下工作；因此，处理器可以在不同的数据上运行不同的程序，这样可以解决完全不同的子问题甚至是单一的大问题。在MIMD中，架构是通过线程或进程层面的并行来实现的，这也意味着处理器一般是异步工作的。这种类型的计算机通常用来解决那些没有统一结构、无法用SIMD来解决的问题。如今，很多计算机都应用了这中间架构，例如超级计算机，计算机网络等。然而，有一个问题不得不考虑：异步的算法非常难设计、分析和实现。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:2:4","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"3. 内存管理 内存管理是并行架构需要考虑的另一方面，确切来说是获得数据的方式。无论处理单元多快，如果内存提供指令和数据的速度跟不上，系统性能也不会得到提升。制约内存达到处理器速度级别的响应时间的主要因素是内存存取周期。所谓存取周期就是连续启动两次读或写操作所需间隔的最小时间。处理器的周期通常比内存周期短得多。当处理器传送数据到内存或从内存中获取数据时，内存依旧在一个周期中，其他任何设备（I/O控制器，处理器）都不能使用内存，因为内存必须先对上一个请求作出响应。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:3:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"3.1. 共享内存 下图展示了共享内存多处理器系统的架构，这里只展示了各部件之间简单的物理连接。总线结构允许任意数量的设备共享一个通道。总线协议最初设计是让单处理器，一个或多个磁盘和磁带控制器通过共享内存进行通讯。可以注意到处理器拥有各自的Cache，Cache中保存着局部内存中有可能被处理器使用的指令或数据。可以想象一下，当一个处理器修改了内存中的数据，同时另外一个处理器正在使用这个数据时，就会出现问题。已修改的值会从处理器的Cache传递到共享内存中，接着，新值会传递到其他处理器的Cache中，其它处理器就不可以使用旧值进行计算。这就是人们所熟知的Cache一致性问题，是内存一致性问题的一种特殊情况，要解决这个问题需要硬件能像多进程编程一样实现处理并发问题 和同步控制 。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:3:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"3.2. 分布式内存 在使用分布式内存的系统中，各个处理器都有其各自的内存，而且每个处理器只能处理属于自己的内存。某些学者把这类系统称为“多计算机系统”，这个名字很真实地反映了组成这类系统的元素能够独立作为一个具有内存和处理器的微型系统，如下图所示： 这种内存管理方式有几个好处。第一，总线和开关级别的的通讯不会发生冲突。每个处理器都可以无视其他处理器的干扰而充分利用局部内存的带宽；第二，没有通用总线意味着没有处理器数量的限制，系统的规模只局限于连接处理器的网络带宽；第三，没有Cache一致性问题的困扰。每个处理器只需要处理属于自己的数据而无须关心上传数据副本的问题。但最大的缺点是，很难实现处理器之间的通讯。如果一个处理器需要其他处理器的数据，这两个处理器必须要通过消息传递协议来交换消息。这样进行通讯会导致速度降低，原因有两个，首先，从一个处理器创建和发送消息到另外一个处理器需要时间；其次，任何处理器都需要停止工作，处理来自其他处理器的消息。面向分布式内存机器的程序必须按照尽量相互独立的任务来组织，任务之间通过消息进行通讯。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:3:2","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4. 并行编程模型 并行编程模型是作为对硬件和内存架构的抽象而存在的。事实上，这些模式不是特定的，而且和机器的类型或内存的架构无关。他们在理论上能在任何类型的机器上实现。相对于前面的架构细分，这些编程模型会在更高的层面上建立，用于表示软件执行并行计算时必须实现的方式。为了访问内存和分解任务，每一个模型都以它独自的方式和其他处理器共享信息。 需要明白的是没有最好的编程模型，模型的效果如何很大程度上取决于实际的问题。使用范围最广的并行编程模型有： 共享内存模型 多线程模型 分布式内存/消息传递模型 数据并行模型 在这节中，会描述这些编程模型的概览。在下一章会更加准确的描述这些编程模型，并会介绍Python中实现这些模型的相应模块。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.1. 共享内存模型 在这个编程模型中所有任务都共享一个内存空间，对共享资源的读写是 异步的。系统提供一些机制，如锁和信号量，来让程序员控制共享内存的访问权限。使用这个编程模型的优点是，程序员不需要清楚任务之间通讯的细节。但性能方面的一个重要缺点是,了解和管理数据区域变得更加困难;将数据保存在处理器本地才可以节省内存访问，缓存刷新以及多处理器使用相同数据时发生的总线流量。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.2. 多线程模型 在这个模型中，单个处理器可以有多个执行流程，例如，创建了一个顺序执行任务之后，会创建一系列可以并行执行的任务。通常情况下，这类模型会应用在共享内存架构中。由于多个线程会对共享内存进行操作，所以进行线程间的同步控制是很重要的，作为程序员必须防止多个线程同时修改相同的内存单元。现代的CPU可以在软件和硬件上实现多线程。POSIX 线程就是典型的在软件层面上实现多线程的例子。Intel 的超线程 (Hyper-threading) 技术则在硬件层面上实现多线程，超线程技术是通过当一个线程在停止或等待I/O状态时切换到另外一个线程实现的。使用这个模型即使是非线性的数据对齐也能实现并行性。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:2","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.3. 消息传递模型 消息传递模型通常在分布式内存系统（每一个处理器都有独立的内存空间）中应用。更多的任务可以驻留在一台或多台物理机器上。程序员需要确定并行和通过消息产生的数据交换。实现这个数据模型需要在代码中调用特定的库。于是便出现了大量消息传递模型的实现，最早的实现可以追溯到20世纪80年代，但直到90年代中期才有标准化的模型——实现了名为MPI (the Message Passing Interface, 消息传递接口)的事实标准。MPI 模型是专门为分布式内存设计的，但作为一个并行编程模型，也可以在共享内存机器上跨平台使用。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:3","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"4.4. 数据并行模型 在这个模型中，有多个任务需要操作同一个数据结构，但每一个任务操作的是数据的不同部分。在共享内存架构中，所有任务都通过共享内存来访问数据；在分布式内存架构中则会将数据分割并且保存到每个任务的局部内存中。为了实现这个模型，程序员必须指定数据的分配方式和对齐方式。现代的GPU在数据已对齐的情况下运行的效率非常高。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:4:4","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"5. python的并行计算 作为一种解释型的语言，Python的速度并不算慢。如果对速度有很高的要求的话，可以选择用更快的语言实现，比如C或C++，然后用Python调用。Python的一种常见应用场景是实现高级的逻辑。Python的解释器就是用C语言写的，即CPython。解释器将Python转换成一种中间语言，叫做Python字节码，类似于汇编语言，但是包含一些更高级的指令。当一个运行一个Python程序的时候，评估循环不断将Python字节码转换成机器码。解释型语言的好处是方便编程和调试，但是程序的运行速度慢。其中的一种解决办法是，用C语言实现一些第三方的库，然后在Python中使用。另一种方法是使用即时编译器来替换Cpython，例如PyPy，PyPy对代码生成和Python的运行速度做了优化。但是在本书中，我们将研究第三种方法。Python提供了很多可以利用并行的模块，在后面的章节中，我们将着重讨论这些并行编程的模块。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:5:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"6. 线程与进程 来源： 进程与线程的一个简单解释，看过最通俗易懂的解释 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫“互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做“信号量”（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:6:0","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["python"],"content":"7. python中的线程和进程 基于线程的并行是编写并行程序的标准方法。然而，Python解释器并不完全是线程安全的。为了支持多线程的Python程序，CPython使用了一个叫做全局解释器锁（Global Interpreter Lock， GIL）的技术。这意味着同一时间只有一个线程可以执行Python代码；执行某一个线程一小段时间之后，Python会自动切换到下一个线程。GIL并没有完全解决线程安全的问题，如果多个线程试图使用共享数据，还是可能导致未确定的行为。 # To use threads you need import Thread using the following code: from threading import Thread # Also we use the sleep function to make the thread \"sleep\" from time import sleep # To create a thread in Python you'll want to make your class work as a thread. # For this, you should subclass your class from the Thread class class CookBook(Thread): def __init__(self): Thread.__init__(self) self.message = \"Hello Parallel Python CookBook!!\\n\" # this method prints only the message def print_message(self): print(self.message) # The run method prints ten times the message def run(self): print(\"Thread Starting\\n\") x = 0 while (x \u003c 10): self.print_message() sleep(2) x += 1 print(\"Thread Ended\\n\") # start the main process print(\"Process Started\") # create an instance of the HelloWorld class hello_Python = CookBook() # print the message...starting the thread hello_Python.start() # end the main process print(\"Process Ended\") 输出 可以看到主进程先结束，子线程还在继续运行知道完毕才结束。 ","date":"2021-07-27","objectID":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/:6:1","tags":["python高性能编程"],"title":"认识并行计算","uri":"/posts/%E8%AE%A4%E8%AF%86%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"categories":["设计模式"],"content":"Createitv","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"简介 工厂模式三姐妹：简单工厂模式（小妹妹）、工厂方法模式（妹妹）、抽象工厂模式（姐姐）。这三种模式可以理解为同一种编程思想的三个版本，从简单到高级不断升级。 简单工厂：只有一个工厂类 SimpleFactory，类中有一个静态的创建方法createProduct，该方法根据参数传递过来的类型值（type）或名称（name）来创建具体的产品（子类）对象。 **工厂方法模式：**工厂方法模式是简单工厂模式的一个升级版本，为解决简单工厂模式不符合“开放-封闭”原则的问题，对 SimpleFactory 进行了一个拆分，抽象出一个父类 Factory，并增加多个子类分别负责创建不同的具体产品 **抽象工厂模式：**抽象工厂模式是工厂方法模式的升级版本，工厂方法模式不能解决具有二级分类的产品的创建问题，抽象工厂模式就是用来解决这一问题的。提供一个创建一系列相关或相互依赖的对象的接口，而无须指定它们的具体类。 ","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用步骤 创建抽象产品类 \u0026 定义具体产品的公共接口； 创建具体产品类（继承抽象产品类） \u0026 定义生产的具体产品； 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例； 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例 #!/Users/tnt/Documents/虚拟环境/Django/bin/python3 # -*- encoding: utf-8 -*- # Time : 2021/06/05 17:34:24 # Theme : 简单工厂设计模式,工厂是创建其他产品类型的类 # ---------例子一:简单工厂模式--------------- class Mercedes(): def __repr__(self): return \"Mercedes-Benz\" class Bmw(): def __repr__(self): return \"BMW\" class Audi(): def __repr__(self): return \"Audi A8\" class SimpleCarFactory(): \"\"\"简单工厂 \"\"\" @staticmethod def product_car(name): if name == \"mb\": return Mercedes() elif name == \"bmw\": return Bmw() elif name == \"audi\": return Audi() def test(): c1 = SimpleCarFactory.product_car(\"mb\") c2 = SimpleCarFactory.product_car(\"bmw\") c3 = SimpleCarFactory.product_car(\"audi\") print(c1, c2, c3) # -----------例子2 工厂方法模式-------------------- from abc import ABCMeta, abstractmethod class Operation(metaclass=ABCMeta): \"\"\"抽象产品角色\"\"\" def __init__(self, first_num, second_num): self.first_num = first_num self.second_num = second_num @abstractmethod def getResult(self): pass class Add(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): return self.first_num + self.second_num class Sub(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): return self.first_num - self.second_num class Mul(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): return self.first_num * self.second_num class Div(Operation): \"\"\"具体产品角色\"\"\" def getResult(self): try: return 1.0 * self.first_num / self.second_num except ZeroDivisionError: raise class OperationFactory(object): \"\"\"产品工厂角色\"\"\" def __init__(self, operation): self.op = operation def chooseOpertator(self): if self.op == \"+\": return Add elif self.op == \"-\": return Sub elif self.op == \"*\": return Mul elif self.op == \"/\": return Div def test(): operator = OperationFactory(\"*\").chooseOpertator() # operator.first_num = 4 # operator.second_num = 5 # print(operator == Add()) print(operator(3, 4).getResult()) test() # ---------------例子3 工厂方法模式------------------ class Coffee(metaclass=ABCMeta): \"\"\"咖啡类,抽象产品\"\"\" def __init__(self, name): self.__name = name def getName(self): return self.__name @abstractmethod def getTaste(self): pass class LatteCaffe(Coffee): \"\"\"拉铁咖啡, 具体产品\"\"\" def __init__(self, name): super().__init__(name) def getTaste(self): return \"轻柔而香纯\" class MochaCoffee(Coffee): \"\"\"摩卡咖啡, 具体产品\"\"\" def __init__(self, name): super().__init__(name) def getTaste(self): return \"丝滑与醇厚\" class Coffeemaker: \"\"\"咖啡机\"\"\" @staticmethod def makeCoffee(coffeeBean): \"通过staticmethod装饰器修饰来定义一个静态方法\" if(coffeeBean == \"拿铁咖啡豆\"): coffee = LatteCaffe(\"拿铁咖啡\") elif(coffeeBean == \"摩卡咖啡豆\"): coffee = MochaCoffee(\"摩卡咖啡\") else: raise ValueError(\"不支持的参数：%s\" % coffeeBean) return coffee def testCoffeeMaker(): latte = Coffeemaker.makeCoffee(\"拿铁咖啡豆\") print(\"%s已为您准备好了，口感：%s。请慢慢享用！\" % (latte.getName(), latte.getTaste())) mocha = Coffeemaker.makeCoffee(\"摩卡咖啡豆\") print(\"%s已为您准备好了，口感：%s。请慢慢享用！\" % (mocha.getName(), mocha.getTaste())) testCoffeeMaker() 抽象工厂方法举例一 from __future__ import annotations from abc import ABC, abstractmethod class AbstractFactory(ABC): \"\"\" The Abstract Factory interface declares a set of methods that return different abstract products. These products are called a family and are related by a high-level theme or concept. Products of one family are usually able to collaborate among themselves. A family of products may have several variants, but the products of one variant are incompatible with products of another. \"\"\" @abstractmethod def create_product_a(self) -\u003e AbstractProductA: pass @abstractmethod def create_product_b(self) -\u003e AbstractProductB: pass class ConcreteFactory1(AbstractFactory): \"\"\" Concrete Factories produce a family of products that belong to a single variant. The factory guarantees that resulting products are compatible. Note that signatures of the Concrete Factory's methods return an abstract product, while inside the method a concrete product is instantiated. \"\"\" def create_product_a(self) -\u003e AbstractProductA: return ConcreteProductA1() def create_product","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"抽象方法举例二 #!/usr/bin/env python # -*- coding: utf-8 -*- # http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/ \"\"\"Implementation of the abstract factory pattern\"\"\" import abc import random class Solider(object): def __init__(self, gun, buttle): self.gun = gun self.buttle = buttle def fire(self): self.gun.pong() self.buttle.pa() class Gunfactory(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def get_gun(self): pass @abc.abstractmethod def get_bullet(self): pass class Gun(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def pong(self): pass class Bullet(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def pa(self): pass class Rifle(Gun): def pong(self): print \"Rifle fire,pong!\" class Handgun(Gun): def pong(self): print \"Handgun fire,pong,pong,pong\" class RifleBullet(Bullet): def pa(self): print \"Rifle buttle,pa!\" class HandgunBullet(Bullet): def pa(self): print \"Handgun buttle,pa,pa,pa\" class RifleFactory(Gunfactory): def get_gun(self): return Rifle() def get_bullet(self): return RifleBullet() class HandgunFactory(object): def get_gun(self): return Handgun() def get_bullet(self): return HandgunBullet() if __name__ == \"__main__\": rifle_factory = RifleFactory() handgun_factory = HandgunFactory() factories = [rifle_factory, handgun_factory] for i in range(4): factory = random.choice(factories) gun = factory.get_gun() bullet = factory.get_bullet() solider = Solider(gun, bullet) solider.fire() print(\"=\" * 20) ### OUTPUT ### # Rifle fire,pong! # Rifle buttle,pa! # ==================== # Handgun fire,pong,pong,pong # Handgun buttle,pa,pa,pa # ==================== # Handgun fire,pong,pong,pong # Handgun buttle,pa,pa,pa # ==================== # Rifle fire,pong! # Rifle buttle,pa! # ==================== ","date":"2021-06-08","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:1","tags":[],"title":"工厂模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["python"],"content":"Createitv","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"3种编程范式 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"命令式编程 Procedural programming is the most basic form of coding. Code is structured hierarchically into blocks (such as if statements, loops, and functions). It is arguably the simplest form of coding. However, it can be difficult to write and maintain large and complex software due to its lack of enforced structure. def add_values(any_list): sum = 0 for x in any_list: sum += x return sum my_list = [1,2,3,4] print(add_values(my_list)) ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:1","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"面向对象编程 Object-oriented programming (OOP) structures code into objects. An object typically represents a real item in the program, such as a file or a window on the screen, and it groups all the data and code associated with that item within a single software structure. Software is structured according to the relationships and interactions between different objects. Since objects are encapsulated, with well-defined behavior, and capable of being tested independently, it is much easier to write complex systems using OOP. class ListOperations(object): def __init__(self, any_list): self.any_list = any_list def add_values(self): self.sum = sum(self.any_list) my_list = [1,2,3,4] sum_values = ListOperations(my_list) sum_values.add_values() print(sum_values.sum) ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:2","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"函数式编程 Functional programming (FP) uses functions as the main building blocks. Unlike procedural programming, the functional paradigm treats functions as objects that can be passed as parameters, allowing new functions to be built dynamically as the program executes. Functional programming tends to be more declarative than imperative – your code defines what you want to happen, rather than stating exactly how the code should do it. Some FP languages don’t even contain constructs, such as loops or if statements. However, Python is more general-purpose and allows you to mix programming styles very easily. import functools my_list = [1, 2, 3, 4] # We will look at the functools library later on sum = functools.reduce(lambda x, y: x + y, my_list) print(sum) ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:3","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"函数式编程特点 纯函数 没有副作用 函数是第一等公民 偏爱不可变对象 迭代器胜过不可迭代序列 惰性计算 避免循环和判断语句 递归代替循环 高阶函数 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"函数式编程的优缺点 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:3:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"优点 代码更少 易读 Bug更少，更好debug Code is potentially mathematically provable 易于并行计算多线程 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:3:2","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["python"],"content":"缺点 不可能完全纯函数 学习曲线高 效率较低，递归消耗大 ","date":"2021-06-03","objectID":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:4:0","tags":["函数式编程"],"title":"Python函数式编程","uri":"/posts/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["算法"],"content":"Createitv","date":"2021-05-26","objectID":"/posts/adt_date_type/","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"Abstract Data Types Abstract Data type (ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations. The definition of ADT only mentions what operations are to be performed but not how these operations will be implemented. It does not specify how data will be organized in memory and what algorithms will be used for implementing the operations. It is called “abstract” because it gives an implementation-independent view. The process of providing only the essentials and hiding the details is known as abstraction. The user of data type does not need to know how that data type is implemented, for example, we have been using Primitive values like int, float, char data types only with the knowledge that these data type can operate and be performed on without any idea of how they are implemented. So a user only needs to know what a data type can do, but not how it will be implemented. Think of ADT as a black box which hides the inner structure and design of the data type. Now we’ll define three ADTs namely List ADT, Stack ADT, Queue ADT. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:0","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"List ADT The data is generally stored in key sequence in a list which has a head structure consisting of count,pointers and address of compare function needed to compare the data in the list. The data node contains the pointer to a data structure and a self-referential pointer which points to the next node in the list. //List ADT Type Definitions typedef struct node { void *DataPtr; struct node *link; } Node; typedef struct { int count; Node *pos; Node *head; Node *rear; int (*compare) (void *argument1, void *argument2) } LIST; The List ADT Functions is given below: A list contains elements of the same type arranged in sequential order and following operations can be performed on the list. get() – Return an element from the list at any given position. insert() – Insert an element at any position of the list. remove() – Remove the first occurrence of any element from a non-empty list. removeAt() – Remove the element at a specified location from a non-empty list. replace() – Replace an element at any position by another element. size() – Return the number of elements in the list. isEmpty() – Return true if the list is empty, otherwise return false. isFull() – Return true if the list is full, otherwise return false. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:1","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"Stack ADT In Stack ADT Implementation instead of data being stored in each node, the pointer to data is stored. The program allocates memory for the date and address is passed to the stack ADT. The head node and the data nodes are encapsulated in the ADT. The calling function can only see the pointer to the stack. The stack head structure also contains a pointer to top and count of number of entries currently in stack. //Stack ADT Type Definitions typedef struct node { void *DataPtr; struct node *link; } StackNode; typedef struct { int count; StackNode *top; } STACK; A Stack contains elements of the same type arranged in sequential order. All operations take place at a single end that is top of the stack and following operations can be performed: push() – Insert an element at one end of the stack called top. pop() – Remove and return the element at the top of the stack, if it is not empty. peek() – Return the element at the top of the stack without removing it, if the stack is not empty. size() – Return the number of elements in the stack. isEmpty() – Return true if the stack is empty, otherwise return false. isFull() – Return true if the stack is full, otherwise return false. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:2","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["算法"],"content":"Queue ADT The queue abstract data type (ADT) follows the basic design of the stack abstract data type. Each node contains a void pointer to the data and the link pointer to the next element in the queue. The program’s responsibility is to allocate memory for storing the data. //Queue ADT Type Definitions typedef struct node { void *DataPtr; struct node *next; } QueueNode; typedef struct { QueueNode *front; QueueNode *rear; int count; } QUEUE; A Queue contains elements of the same type arranged in sequential order. Operations take place at both ends, insertion is done at the end and deletion is done at the front. Following operations can be performed: enqueue() – Insert an element at the end of the queue. dequeue() – Remove and return the first element of the queue, if the queue is not empty. peek() – Return the element of the queue without removing it, if the queue is not empty. size() – Return the number of elements in the queue. isEmpty() – Return true if the queue is empty, otherwise return false. isFull() – Return true if the queue is full, otherwise return false. From these definitions, we can clearly see that the definitions do not specify how these ADTs will be represented and how the operations will be carried out. There can be different ways to implement an ADT, for example, the List ADT can be implemented using arrays, or singly linked list or doubly linked list. Similarly, stack ADT and Queue ADT can be implemented using arrays or linked lists. ","date":"2021-05-26","objectID":"/posts/adt_date_type/:0:3","tags":[],"title":"抽象数据类型(转)","uri":"/posts/adt_date_type/"},{"categories":["前端","Javascript"],"content":"Createitv","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"数组常用方法总结 01_数组常用方法1.html =\u003e 数组基础方法 =\u003e push() =\u003e pop() =\u003e unshift() =\u003e shift() 02_数组常用方法2.html =\u003e ES3.0, IE 6 7 8 可以是使用 =\u003e reverse() =\u003e sort() =\u003e splice() =\u003e join() =\u003e slice() =\u003e concat() 03_数组常用方法3.html =\u003e ES5.0, IE 6 7 8 不好使了 =\u003e indexOf() =\u003e lastIndexOf() =\u003e forEach() =\u003e map() =\u003e fliter() =\u003e every() =\u003e some() 04_数组常用方法4.html =\u003e ES2015(ES6) 以后, 标准浏览器, IE 10 以上 =\u003e fill() =\u003e copyWithin() =\u003e includes() =\u003e flat() =\u003e flatMap() =\u003e find() =\u003e findIndex() ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:0:1","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"push, pop, unshift ,shift // -----------pop----------- const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato']; console.log(plants.pop()); // expected output: \"tomato\" console.log(plants); // expected output: Array [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"] plants.pop(); console.log(plants); // expected output: Array [\"broccoli\", \"cauliflower\", \"cabbage\"] // -----------push----------- const animals = ['pigs', 'goats', 'sheep']; const count = animals.push('cows'); console.log(count); // expected output: 4 console.log(animals); // expected output: Array [\"pigs\", \"goats\", \"sheep\", \"cows\"] animals.push('chickens', 'cats', 'dogs'); console.log(animals); // expected output: Array [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"] // -----------unshift----------- // unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 const array1 = [1, 2, 3]; console.log(array1.unshift(4, 5)); // expected output: 5 console.log(array1); // expected output: Array [4, 5, 1, 2, 3] // -----------shift----------- //shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 const array1 = [1, 2, 3]; const firstElement = array1.shift(); console.log(array1); // expected output: Array [2, 3] console.log(firstElement); // expected output: 1 ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:1:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"reverse, sort, splice, join, slice, concat // -----------reverse----------- // reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。 const array1 = ['one', 'two', 'three']; console.log('array1:', array1); // expected output: \"array1:\" Array [\"one\", \"two\", \"three\"] const reversed = array1.reverse(); console.log('reversed:', reversed); // expected output: \"reversed:\" Array [\"three\", \"two\", \"one\"] // Careful: reverse is destructive -- it changes the original array. console.log('array1:', array1); // expected output: \"array1:\" Array [\"three\", \"two\", \"one\"] // -----------sort----------- // sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 const months = ['March', 'Jan', 'Feb', 'Dec']; months.sort(); console.log(months); // expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // expected output: Array [1, 100000, 21, 30, 4] // ----------sort()比大小------- var numbers = [4, 2, 5, 1, 3]; numbers.sort(function(a, b) { return a - b; }); console.log(numbers); 也可以写成： var numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =\u003e a - b); console.log(numbers); // [1, 2, 3, 4, 5] // -----------splice----------- // splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组 const months = ['Jan', 'March', 'April', 'June']; months.splice(1, 0, 'Feb'); // inserts at index 1 console.log(months); // expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"] months.splice(4, 1, 'May'); // replaces 1 element at index 4 console.log(months); // expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"] // 从第 2 位开始删除 0 个元素，插入“drum” var myFish = [\"angel\", \"clown\", \"mandarin\", \"sturgeon\"]; var removed = myFish.splice(2, 0, \"drum\"); // 运算后的 myFish: [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"] // 被删除的元素: [], 没有元素被删除 // -----------join------------- // join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 const elements = ['Fire', 'Air', 'Water']; console.log(elements.join()); // expected output: \"Fire,Air,Water\" console.log(elements.join('')); // expected output: \"FireAirWater\" console.log(elements.join('-')); // expected output: \"Fire-Air-Water\" // -----------slice------------ // slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 const animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice(2)); // expected output: Array [\"camel\", \"duck\", \"elephant\"] console.log(animals.slice(2, 4)); // expected output: Array [\"camel\", \"duck\"] console.log(animals.slice(1, 5)); // expected output: Array [\"bison\", \"camel\", \"duck\", \"elephant\"] // -----------concat----------- // concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 const array1 = ['a', 'b', 'c']; const array2 = ['d', 'e', 'f']; const array3 = array1.concat(array2); console.log(array3); // expected output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:2:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"indexOf, lastIndexOf, forEach, map, filter, every, some // -------------------indexOf-------------------- // indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 const beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 // start from index 2 console.log(beasts.indexOf('bison', 2)); // expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 // -------------------lastIndexOf-------------------- // lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo']; console.log(animals.lastIndexOf('Dodo')); // expected output: 3 console.log(animals.lastIndexOf('Tiger')); // expected output: 1 // -------------------forEach-------------------- // forEach() 方法对数组的每个元素执行一次给定的函数。返回undefined const array1 = ['a', 'b', 'c']; array1.forEach(element =\u003e console.log(element)); // expected output: \"a\" // expected output: \"b\" // expected output: \"c\" // -------------------map-------------------- // map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x =\u003e x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] // -------------------filter-------------------- // filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter(word =\u003e word.length \u003e 6); console.log(result); // expected output: Array [\"exuberant\", \"destruction\", \"present\"] // -------------------every-------------------- // every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 const isBelowThreshold = (currentValue) =\u003e currentValue \u003c 40; const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true // 检测数组中的所有元素是否都大于 10。 function isBigEnough(element, index, array) { return element \u003e= 10; } [12, 5, 8, 130, 44].every(isBigEnough); // false [12, 54, 18, 130, 44].every(isBigEnough); // true // -------------------some-------------------- // some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 const array = [1, 2, 3, 4, 5]; // checks whether an element is even const even = (element) =\u003e element % 2 === 0; console.log(array.some(even)); // expected output: true //下面的例子检测在数组中是否有元素大于 10。 function isBiggerThan10(element, index, array) { return element \u003e 10; } [2, 5, 8, 1, 4].some(isBiggerThan10); // false [12, 5, 8, 1, 4].some(isBiggerThan10); // true ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:3:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["前端","Javascript"],"content":"fill, copyWithin, includes, flat, flatMap, find, findIndex // -------------------fill-------------------- // fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 const array1 = [1, 2, 3, 4]; // fill with 0 from position 2 until position 4 console.log(array1.fill(0, 2, 4)); // expected output: [1, 2, 0, 0] // fill with 5 from position 1 console.log(array1.fill(5, 1)); // expected output: [1, 5, 5, 5] console.log(array1.fill(6)); // expected output: [6, 6, 6, 6] // -------------------copyWithin-------------------- // copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 const array1 = ['a', 'b', 'c', 'd', 'e']; // copy to index 0 the element at index 3 console.log(array1.copyWithin(0, 3, 4)); // expected output: Array [\"d\", \"b\", \"c\", \"d\", \"e\"] // copy to index 1 all elements from index 3 to the end console.log(array1.copyWithin(1, 3)); // expected output: Array [\"d\", \"d\", \"e\", \"d\", \"e\"] // -------------------includes-------------------- // includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 const array1 = [1, 2, 3]; console.log(array1.includes(2)); // expected output: true const pets = ['cat', 'dog', 'bat']; console.log(pets.includes('cat')); // expected output: true console.log(pets.includes('at')); // expected output: false // -------------------flat-------------------- // flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 const arr1 = [0, 1, 2, [3, 4]]; console.log(arr1.flat()); // expected output: [0, 1, 2, 3, 4] const arr2 = [0, 1, 2, [[[3, 4]]]]; console.log(arr2.flat(2)); // expected output: [0, 1, 2, [3, 4]] // -------------------flatMap-------------------- // flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 let arr1 = [\"it's Sunny in\", \"\", \"California\"]; arr1.map(x =\u003e x.split(\" \")); // [[\"it's\",\"Sunny\",\"in\"],[\"\"],[\"California\"]] arr1.flatMap(x =\u003e x.split(\" \")); // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"] // -------------------find-------------------- // find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 const array1 = [5, 12, 8, 130, 44]; const found = array1.find(element =\u003e element \u003e 10); console.log(found); // expected output: 12 // -------------------findIndex-------------------- // findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 const array1 = [5, 12, 8, 130, 44]; const isLargeNumber = (element) =\u003e element \u003e 13; console.log(array1.findIndex(isLargeNumber)); // expected output: 3 ","date":"2021-05-21","objectID":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/:4:0","tags":[],"title":"JS数组操作","uri":"/posts/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["浏览器"],"content":"Createitv","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"浏览器特性 现代浏览器的特性主要包含如下几部分： 网络 浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。 资源管理 浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。 网页浏览 浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。 多页面管理 浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。 插件和扩展 现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。 账户和同步 现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。 安全机制 现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。 开发者工具 开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。 浏览器结构 目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构： 浏览器的抽象分层结构图中将浏览器分成了以下8个子系统： 用户界面（User Interface） 用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。 用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。 浏览器引擎（Browser Engine） 浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。 浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。 浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。 浏览器引擎还允许查询/修改渲染引擎设置。 渲染引擎（Rendering Engine） 渲染引擎为指定的URI生成可视化的表示。 渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。 渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。 渲染引擎内部包含HTML解析器。 网络（Networking） 网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。 JavaScript解释器（JavaScript Interpreter） JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。 XML解析器（XML Parser） XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。 显示后端（Display Backend） 显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。 数据持久层（Data Persistence） 数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。 这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？ 原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。 渲染引擎 浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用： 渲染引擎 浏览器 Trident IE、Edge Gecko Firefox WebKit Safari、Chromium/Chrome ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:0:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"渲染引擎工作流程 如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。 Parsing HTML to Construct DOM Tree 渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。 同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。 Render Tree construction 渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。 渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 Layout of Render Tree 渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 Painting Render Tree 渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。 ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:1:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["浏览器"],"content":"渲染引擎组成模块 下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 从图中可以看出，渲染引擎主要包含（或调用）的模块有： HTML（XML）解析器 解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。 CSS解析器 将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。 JavaScript解释器 使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。 布局 DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。 绘图 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。 ","date":"2021-05-16","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/:2:0","tags":[],"title":"浏览器的基本组成","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"},{"categories":["python"],"content":"Createitv","date":"2021-05-15","objectID":"/posts/intermediatepython/","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"IntermediatePython ","date":"2021-05-15","objectID":"/posts/intermediatepython/:1:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"*args和**kwargs 并不是必须写成*args 和**kwargs。 只有变量前面的 *(星号)才是必须的. 你也可以写成*var 和**vars. 而写成*args 和**kwargs只是一个通俗的命名约定。 *args的用法 args和**kwargs用于函数不定数量的参数传递，在函数使用者不知道会传递多少个参数下可使用 def test_var_args(f_arg, *argv): print(\"first normal arg:\", f_arg) for arg in argv: print(\"another arg through *argv:\", arg) \u003e\u003e\u003etest_var_args('yasoob', 'python', 'eggs', 'test') first normal arg: yasoob another arg through *argv: python another arg through *argv: eggs another arg through *argv: test **kwargs的用法 **kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 def greet_me(**kwargs): for key, value in kwargs.items(): print(\"{0}=={1}\".format(key, value)) \u003e\u003e\u003egreet_me(name='yasoob') name == yasoob 使用args和**kwargs来调用函数 def test_args_kwargs(arg1, arg2, arg3): print(\"arg1:\", arg1) print('arg2:', arg2) print(\"arg3:\", arg3) # 首先使用*args \u003e\u003e\u003eargs = (\"two\", 3, 5) \u003e\u003e\u003etest_args_kwargs(**kwargs) arg1: two arg2: 3 arg3: 5 #再使用**kwargs \u003e\u003e\u003e kwargs = {\"arg3\": 3, \"arg2\": \"two\", \"arg1\": 5} \u003e\u003e\u003e test_args_kwargs(**kwargs) arg1: 5 arg2: two arg3: 3 标准参数、缺省参数、*args、**kwargs在使用时候的顺序 some_function(argument, argument=' ', *args, **kwargs ) 什么时候使用 根据需求而定：最常见在装饰起之中捕获修饰函数的不定参数 def use_logging(func): def wrapper(*args, **kwargs): # Look this logging.warn(\"%sis running\" % func.__name__) return func(*args) return wrapper @use_logging def foo(): print(\"i am foo\") @use_logging def bar(): print(\"i am bar\") bar() ","date":"2021-05-15","objectID":"/posts/intermediatepython/:2:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"调试Debugging 利用好调试，能大大提高你捕捉代码Bug的。大部分新人忽略了Python debugger(pdb)的重要性。 从命令行启动 $ python -m pdb my_script.py 从脚本内部启动 import pdb def make_bread(): pdb.set_trace() #设置断点 return \"I don't have time\" print(make_bread()) 命令列表： c: 继续执行 w: 显示当前正在执行的代码行的上下文信息 a: 打印当前函数的参数列表 s: 执行当前代码行，并停在第一个能停的地方（相当于单步进入） n: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过） ","date":"2021-05-15","objectID":"/posts/intermediatepython/:3:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"生成器Generators 迭代器(iterators)是一个让程序员可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。 可迭代对象(Iterable)——形容词 迭代器(Iterator)——名词 迭代(Iteration)——动词 可迭代对象(Iterable) Python中任意的对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。 迭代器(Iterator) 任意对象，只要定义了next(Python2) 或者__next__方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration) 迭代(Iteration) 从某个地方（比如一个列表）不断取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。 生成器(Generators) 生成器也是一种迭代器，一次只能迭代一次，类似版本迭代更新。在python中并没有直接把所有数据写入内存中，而是在运行时生成值。可以通过遍历来访问他们，大多数时候通过函数来实现。而且并不返回一个值而是yield一个值。 斐波那契数列生成器 # generator version(减少资源消耗) def fibon(n): a = b = 1 for i in range(n): yield a a, b = b, a + b for x in fibon(1000000): print(x) #faction version def fibon(n): a = b = 1 result = [] for i in range(n): result.append(a) a, b = b, a + b return result ","date":"2021-05-15","objectID":"/posts/intermediatepython/:4:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"高阶函数(Map，Filter，Reduce) Map函数 Map会将一个函数映射到一个输入列表的所有元素上 map(function_to_apply, list_of_inputs) # 对比举例 items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.appedn(i**2) # 等同于 items = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, items)) # 在python2中map直接返回列表，但在python3中返回迭代器 # 因此为了兼容python3, 需要list转换一下 Filter函数 filter过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True number_list = range(-5, 5)less_than_zero = filter(lambda x:x \u003c0, number_list)print(list(less_than_zero)) filter类似于一个for循环，但它是一个内置函数，并且更快。 注意：map和filter相对不那么优雅,推导式的可读性更好。 Reduce函数 reduce() 函数会对参数序列中元素进行累积 reduce(function, iterable[, initializer]) #语法from functools import reduceproduct = reduce( (lambda x, y: x * y), [1, 2, 3, 4] )# Output: 24 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:5:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"Set数据集合 set(集合)是一个非常有用的数据结构。它与列表(list)的行为类似，区别在于set不能包含重复的值。 # 查看重复元素some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']duplicates = []for value in some_list: if some_list.count(value) \u003e 1: if value not in duplicates: duplicates.append(value)print(duplicates)### 输出: ['b', 'n'] 更简单更优雅的解决方案，那就是使用集合(sets) some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']duplicates = set([x for x in some_list if some_list.count(x) \u003e 1])print(duplicates)### 输出: set(['b', 'n']) 交集 对比两个集合的交集（两个集合中都有的数据） valid = set(['yellow', 'red', 'blue', ' green', 'black'])input_set = set(['red', 'brown'])print(input_set.interserction(valid))### 输出:set(['red']) 差集 用差集(difference)找出无效的数据，相当于用一个集合减去另一个集合的数据 valid = set(['yellow', 'red', 'blue', 'green', 'black'])input_set = set(['red', 'brown'])print(input_set.difference(valid))### 输出:set(['brown']) 你也可以用{}符号来创建集合 a_set = {'red', 'blue', 'green'}print(type(a_set))### 输出: \u003ctype 'set'\u003e ","date":"2021-05-15","objectID":"/posts/intermediatepython/:6:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"三元运算符 三元运算符通常在Python里被称为条件表达式，这些表达式基于真(true)/假(false)的条件判断 伪代码 #如果条件为真，返回真 否则返回假condition_is_true if condition else condition_is_false 举例 number = 3flag = '单数' if number % 2 != 0 else '双数'print(flag)### 输出:单数 另外一种超级晦涩的语法 #(返回假，返回真)[真或假](if_test_is_false, if_test_is_true)[test]fat = Truefitness = (\"skinny\", \"fat\")[fat]print(\"Ali is\", fitness)#输出: Ali is fat ","date":"2021-05-15","objectID":"/posts/intermediatepython/:7:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"装饰器 修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿），新手跨越必备。 函数也是对象 def hi(name=\"yasoob\"): return \"hi \" + nameprint(hi())# output: 'hi yasoob'# 我们甚至可以将一个函数赋值给一个变量，比如greet = hi# 我们这里没有在使用小括号，因为我们并不是在调用hi函数# 而是在将它放在greet变量里头。我们尝试运行下这个print(greet())# output: 'hi yasoob'# 如果我们删掉旧的hi函数，看看会发生什么！del hiprint(hi())#outputs: NameErrorprint(greet())#outputs: 'hi yasoob' 函数中定义函数 def hi(name=\"yasoob\"): print(\"now you are inside the hi() function\") def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" print(greet()) print(welcome()) print(\"now you are back in the hi() function\")hi()#output:now you are inside the hi() function# now you are in the greet() function# now you are in the welcome() function# now you are back in the hi() function# 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。# 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：greet()#outputs: NameError: name 'greet' is not defined 从函数中返回函数 def hi(name=\"yasoob\"): def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" if name == \"yasoob\": return greet else: return welcomea = hi()print(a)#outputs: \u003cfunction greet at 0x7f2143c01500\u003e#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数#现在试试这个print(a())#outputs: now you are in the greet() function 将函数作为参数传给另一个函数 def hi(): return \"hi yasoob!\"def doSomethingBeforeHi(func): print(\"I am doing some boring work before executing hi()\") print(func())doSomethingBeforeHi(hi)#outputs:I am doing some boring work before executing hi()# hi yasoob! 装饰器应用 def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunctiondef a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\")a_function_requiring_decoration()#outputs: \"I am the function which needs some decoration to remove my foul smell\"a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)#now a_function_requiring_decoration is wrapped by wrapTheFunction()a_function_requiring_decoration()#outputs:I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func() 装饰起语法糖 @a_new_decoratordef a_function_requiring_decoration(): \"\"\"Hey you! Decorate me!\"\"\" print(\"I am the function which needs some decoration to \" \"remove my foul smell\")a_function_requiring_decoration()#outputs: I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func()#the @a_new_decorator is just a short way of saying:a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 使用场景 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中 from functools import wrapsdef requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated ","date":"2021-05-15","objectID":"/posts/intermediatepython/:8:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"slots魔法 在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这非常有用，因为它允许我们在运行时去设置任意的新属性。 然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象（我指的是成千上万个），它会消耗掉很多内存。 不过还是有一个方法来规避这个问题。这个方法需要使用__slots__来告诉Python不要使用字典，而且只给一个固定集合的属性分配空间。 不使用__slots__: class MyClass(object): def __init__(self, name, identifier): self.name = name self.identifier = identifier self.set_up() 使用__slots__ class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self.name = name self.identifier = identifier self.set_up() 第二段代码会为你的内存减轻负担。通过这个技巧，有些人已经看到内存占用率几乎40%~50%的减少。 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:9:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"虚拟环境Virtualenv 什么是虚拟环境？ Virtualenv 是一个工具，它能够帮我们创建一个独立(隔离)的Python环境。想象你有一个应用程序，依赖于版本为2的第三方模块，但另一个程序依赖的版本是3，请问你如何使用和开发这些应用程序？ 如果你把一切都安装到了/usr/lib/python2.7/site-packages（或者其它平台的标准位置），那很容易出现某个模块被升级而你却不知道的情况。 在另一种情况下，想象你有一个已经开发完成的程序，但是你不想更新它所依赖的第三方模块版本；但你已经开始另一个程序，需要这些第三方模块的版本。 虚拟环境安装 pip install virtualenv 虚拟环境启动 $ virtualenv myproject $ source myproject/bin/activate 执行第一个命令在myproject文件夹创建一个隔离的virtualenv环境，第二个命令激活这个隔离的环境(virtualenv)。 如果你想让你的virtualenv使用系统全局模块，请使用--system-site-packages 虚拟环境关闭 $ deactivate 小工具 smartcd你可以使用smartcd来帮助你管理你的环境，当你切换目录时，它可以帮助你激活（activate）和退出（deactivate）你的virtualenv ","date":"2021-05-15","objectID":"/posts/intermediatepython/:10:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"容器(collections) defaultdict defaultdict与dict类型不同，你不需要检查key是否存在，所以能这样做 from collections import defaultdictcolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'),)favourite_colours = defaultdict(list)for name, colour in colours: favourite_colours[name].append(colour)print(favourite_colours)# defaultdict(\u003ctype 'list'\u003e,# {'Arham': ['Green'],# 'Yasoob': ['Yellow', 'Red'],# 'Ahmed': ['Silver'],# 'Ali': ['Blue', 'Black']# }) 当你在一个字典中对一个键进行嵌套赋值时，如果这个键不存在，会触发keyError异常。 defaultdict允许我们用一个聪明的方式绕过这个问题。 首先我分享一个使用dict触发KeyError的例子，然后提供一个使用defaultdict的解决方案 some_dict = {}some_dict['colours']['favourite'] = \"yellow\"## 异常输出：KeyError: 'colours'import collectionstree = lambda: collections.defaultdict(tree)some_dict = tree()some_dict['colours']['favourite'] = \"yellow\"## 运行正常 counter counter是一个计数器，帮助我们对数据进行计数 from collections import Countercolours = ( ('Yasoob', 'Yellow'), ('Ali', 'Blue'), ('Arham', 'Green'), ('Ali', 'Black'), ('Yasoob', 'Red'), ('Ahmed', 'Silver'),)favs = Counter(name for name, colour in colours)print(favs)## 输出:## Counter({## 'Yasoob': 2,## 'Ali': 2,## 'Arham': 1,## 'Ahmed': 1## }) 我们也可以在利用它统计一个文件 with open('filename', 'rb') as f: line_count = Counter(f)print(line_count) deque deque提供了一个双端队列，你可以从头和尾两端添加或者删除元素。 from collections import dequed = deque()d.append('1')d.append('2')d.append('3')print(len(d))# output:3print(d[0])# output:'1'print(d[-1])# output:'3' 从两端取出(pop)数据： d = deque(range(5))print(len(d))## 输出: 5d.popleft()## 输出: 0d.pop()## 输出: 4print(d)## 输出: deque([1, 2, 3]) namedtuple enum.Enum ","date":"2021-05-15","objectID":"/posts/intermediatepython/:11:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"枚举Enumerate 枚举(enumerate)是Python内置函数 my_list = ['apple', 'banana', 'grapes', 'pear']for c, value in enumerate(my_list, 1): print(c, value)# 输出:(1, 'apple')(2, 'banana')(3, 'grapes')(4, 'pear') ","date":"2021-05-15","objectID":"/posts/intermediatepython/:12:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"对象自省 自省(introspection)，在计算机编程领域里，是指在运行时来判断一个对象的类型的能力。它是Python的强项之一。Python中所有一切都是一个对象，而且我们可以仔细勘察那些对象。Python还包含了许多内置函数和模块来帮助我们。 dir 返回一个列表，列出了一个对象所拥有的属性和方法。自省给了我们一个列表对象的所有方法的名字。当你没法回忆起一个方法的名字，这会非常有帮助。 my_list = [1, 2, 3]dir(my_list)# Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',# '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',# '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',# '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',# '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',# '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',# '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',# 'remove', 'reverse', 'sort'] type和id type函数返回一个对象的类型 print(type(''))# Output: \u003ctype 'str'\u003eprint(type([]))# Output: \u003ctype 'list'\u003eprint(type({}))# Output: \u003ctype 'dict'\u003eprint(type(dict))# Output: \u003ctype 'type'\u003eprint(type(3))# Output: \u003ctype 'int'\u003e id()函数返回任意不同种类对象的唯一ID name = \"Yasoob\"print(id(name))# Output: 139972439030304 inspect模块 inspect模块也提供了许多有用的函数，来获取活跃对象的信息。 import inspectprint(inspect.getmembers(str))# Output: [('__add__', \u003cslot wrapper '__add__' of ... ... ","date":"2021-05-15","objectID":"/posts/intermediatepython/:13:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"推导式 推导式（又称解析式）是Python的一种独有特性，推导式可以从一个数据序列构建另外一个数据序列的结构体。 列表推导式 字典推导式 集合推导式 List Comprehension 列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。 它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以if和for语句为上下文的表达式运行完成之后产生。 variable = [out_exp for out_exp in input_list if out_exp == 2] Dictionary Comprehension mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}mcase_frequency = { k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()}# mcase_frequency == {'a': 17, 'z': 3, 'b': 34} 快速对换一个字典的键和值 {v: k for k, v in some_dict.items()} Set Comprehension 它们跟列表推导式也是类似的。 唯一的区别在于它们使用大括号{} squared = {x**2 for x in [1, 1, 2]}print(squared) ","date":"2021-05-15","objectID":"/posts/intermediatepython/:14:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"异常 异常处理是一种艺术，一旦你掌握，会授予你无穷的力量 try: file = open('test.txt', 'rb')except IOError as e: print(\"An IOError occurred. {}\".format(e.args[-1])) 处理多个异常 第一种方法需要把所有可能发生的异常放到一个元组里。像这样： try: file = open('test.txt', 'rb')except (IOError, EOFError) as e: print(\"An error occurred. {}\".format(e.args[-1])) 另外一种方式是对每个单独的异常在单独的except语句块中处理。我们想要多少个except语句块都可以。 try: file = open('test.txt', 'rb')except EOFError as e: print(\"An EOF error occurred.\") raise eexcept IOError as e: print(\"An error occurred.\") raise e 捕获所有异常 try: file = open(\"test.txt\", 'rb')except Exception: # 打印一些异常日志，如果你想要的话 raise finally 从句 包裹到finally从句中的代码不管异常是否触发都将会被执行。这可以被用来在脚本执行之后做清理工作。 try: file = open(\"test.txt\", 'rb')except IOError as e: print(\"An IOError occurred.{}\".format(e.args[-1]))finally: print(\"This would be printed wheher or not an exception occurred!\") try / else从句 else可以用在不触发异常的情况下执行一些代码 try: print('I am sure no exception is going to occur!')except Exception: print('exception')else: # 这里的代码只会在try语句里没有触发异常时运行, # 但是这里的异常将 *不会* 被捕获 print('This would only run if no exception occurs. And an error here ' 'would NOT be caught.')finally: print('This would be printed in every case.')# Output: I am sure no exception is going to occur!# This would only run if no exception occurs.# This would be printed in every case. ","date":"2021-05-15","objectID":"/posts/intermediatepython/:15:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"lambda表达式 它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式 原型 lambda 参数:操作(参数) 例子 add = lambda x, y: x + yprint(add(3, 5))# Output: 8 列表排序 a = [(1, 2), (4 ,1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1])print(a)# Output: [(13, -3), (4, 1), (1, 2), (9, 10)] ","date":"2021-05-15","objectID":"/posts/intermediatepython/:16:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"一行式 简易Web Server 你是否想过通过网络快速共享文件？好消息，Python为你提供了这样的功能。 # Python 2python -m SimpleHTTPServer# Python 3python -m http.server 漂亮的打印 你可以在Python REPL漂亮的打印出列表和字典。这里是相关的代码： from pprint import pprintmy_dict = {'name': 'Yasoob', 'age': 'undefined', 'personality': 'awesome'} pprint(my_dict) 想快速漂亮的从文件打印出json数据，那么你可以这么做 cat file.json | python -m json.tool 脚本性能分析 这可能在定位你的脚本中的性能瓶颈时 python -m cProfile my_scripy.py CSV转换为json python -c \"import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))\" 一行式的构造器 class A(object): def __init__(self, a, b, c, d, e, f): self.__dict__.update({k: v for k, v in locals().items() if k != 'self'}) ","date":"2021-05-15","objectID":"/posts/intermediatepython/:17:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"For-else else从句会在循环正常结束时执行。这意味着，循环没有遇到任何break 有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使用break来中断这个循环。有两个场景会让循环停下来。 第一个是当一个元素被找到，break被触发。 第二个场景是循环结束。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n / x) break else: # loop fell through without finding a factor print(n , 'is a prime number') ","date":"2021-05-15","objectID":"/posts/intermediatepython/:18:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"使用C扩展 开发者有三种方法可以在自己的Python代码中来调用C编写的函数-ctypes，SWIG，Python/C API。每种方式也都有各自的利弊。 要在Python中调用C？原因如下： 你要提升代码的运行速度，而且你知道C要比Python快50倍以上 C语言中有很多传统类库，而且有些正是你想要的，但你又不想用Python去重写它们 想对从内存到文件接口这样的底层资源进行访问 不需要理由，就是想这样做 Ctypes Python中的ctypes模块可能是Python调用C方法中最简单的一种。ctypes模块提供了和C语言兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。也正是如此奠定了这种方法的简单性。 SWIG SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种方法。在这个方法中，开发人员必须编写一个额外的接口文件来作为SWIG(终端工具)的入口。 Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。 Python/C API Python/C API可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。 ","date":"2021-05-15","objectID":"/posts/intermediatepython/:19:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["python"],"content":"函数缓存 函数缓存允许我们将一个函数对于给定参数的返回值缓存起来。 当一个I/O密集的函数被频繁使用相同的参数调用的时候，函数缓存可以节约时间。 在Python 3.2版本以前我们只有写一个自定义的实现。在Python 3.2以后版本，有个lru_cache的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存。 python3.2+ 实现一个斐波那契计算器，并使用lru_cache ","date":"2021-05-15","objectID":"/posts/intermediatepython/:20:0","tags":[],"title":"IntermediatePython","uri":"/posts/intermediatepython/"},{"categories":["前端"],"content":"Createitv","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Lecture 0 Introduction Web Programming HTML (Hypertext Markup Language) Document Object Model (DOM) More HTML Elements Forms CSS (Cascading Style Sheets) Responsive Design Bootstrap Sass (Syntactically Awesome Style Sheets) ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:0:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Introduction In this course, we’re picking up where CS50 left off and diving into the design and creation of web applications. We’ll build our web-design skills by working on a number of projects throughout the course, including an open-ended final project where you’ll have the chance to create a website of your own! In this course, you’ll need a text editor where you can write code locally on your computer. Some popular ones include Visual Studios Code, Sublime Text, Atom, and Vim, but there are many more to choose from! ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:1:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Web Programming Course Topics: We’ll go into more detail later, but here’s a brief overview of what we’ll be working on during this course: HTML and CSS (a markup language used to outline a webpage, and a procedure for making our sites more visually appealing) Git (used for version control and collaboration) Python (a widely-used programming language we’ll use to make our sites more dynamic) Django (a popular web framework we’ll use for the backend of our sites) SQL, Models, and Migrations (a language used for storing and retrieving data, and Django-specific methods that make it easier to interact with SQL databases) JavaScript (a programming language used to make websites faster and more interactive) User Interfaces (methods used to make a website as easy to use as possible) Testing, CI, CD (learning about different methods used to make sure updates to web pages proceed smoothly) Scalability and Security (making sure our websites can be accessed by many users at once, and that they are safe from malicious intent) ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:2:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"HTML (Hypertext Markup Language) HTML is a markup language that defines the structure of a web page. It is interpreted by your web browser (Safari, Google Chrome, Firefox, etc.) in order to display content on your screen. Let’s get started by writing a simple HTML file! \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e When we open up this file in our browser, we get: Now, let’s take some time to talk about the file we just wrote, which seems to be pretty complicated for such a simple page. In the first line, we are declaring (to the web browser) that we are writing the document in the latest version of HTML: HTML5. After that, the page consists of nested HTML elements (such as html and body), each with an opening and closing tag marked with either \u003celement\u003e for an opening and \u003c/element\u003e for a closing. Notice how each of the inner elements is indented just a bit further than the last. While this is not necessarily required by the browser, it will be very helpful to keep this up in your own code. HTML elements can include attributes, which give the browser extra information about the element. For example, when we include lang=\"en\" in our initial tag, we are telling the browser that we are using English as our primary language. Inside the HTML element, we typically want to include both a head and a body tag. The head element will include information about your page that is not necessarily displayed, and the body element will contain what is actually visible to users who visit the site. Within the head, we have included a title for our webpage, which you’ll notice is displayed in the tab at the top of our web browser. Finally, we’ve included the text “Hello, world!” in the body, which is the visible part of our page. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Document Object Model (DOM) The DOM is a convenient way of visualizing the way HTML elements relate to each other using a tree-like structure. Above is an example of the DOM layout for the page we just wrote. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:1","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"More HTML Elements There are many HTML elements you may want to use to customize your page, including headings, lists, and bolded sections. In this next example, we’ll see a few of of these in action. One more thing to note: \u003c!-- --\u003e gives us a comment in HTML, so we’ll use that below to explain some of the elements. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHTML Elements\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- We can create headings using h1 through h6 as tags. --\u003e \u003ch1\u003eA Large Heading\u003c/h1\u003e \u003ch2\u003eA Smaller Heading\u003c/h2\u003e \u003ch6\u003eThe Smallest Heading\u003c/h6\u003e \u003c!-- The strong and i tags give us bold and italics respectively. --\u003e A \u003cstrong\u003ebold\u003c/strong\u003e word and an \u003ci\u003eitalicized\u003c/i\u003e word! \u003c!-- We can link to another page (such as cs50's page) using a. --\u003e View the \u003ca href=\"https://cs50.harvard.edu/\"\u003eCS50 Website\u003c/a\u003e! \u003c!-- We used ul for an unordered list and ol for an ordered one. both ordered and unordered lists contain li, or list items. --\u003e An unordered list: \u003cul\u003e \u003cli\u003efoo\u003c/li\u003e \u003cli\u003ebar\u003c/li\u003e \u003cli\u003ebaz\u003c/li\u003e \u003c/ul\u003e An ordered list: \u003col\u003e \u003cli\u003efoo\u003c/li\u003e \u003cli\u003ebar\u003c/li\u003e \u003cli\u003ebaz\u003c/li\u003e \u003c/ol\u003e \u003c!-- Images require a src attribute, which can be either the path to a file on your computer or the link to an image online. It also includes an alt attribute, which gives a description in case the image can't be loaded. --\u003e An image: \u003cimg src=\"../../images/duck.jpeg\" alt=\"Rubber Duck Picture\"\u003e \u003c!-- We can also see above that for some elements that don't contain other ones, closing tags are not necessary. --\u003e \u003c!-- Here, we use a br tag to add white space to the page. --\u003e \u003cbr/\u003e \u003cbr/\u003e \u003c!-- A few different tags are necessary to create a table. --\u003e \u003ctable\u003e \u003cthead\u003e \u003cth\u003eOcean\u003c/th\u003e \u003cth\u003eAverage Depth\u003c/th\u003e \u003cth\u003eMaximum Depth\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003ePacific\u003c/td\u003e \u003ctd\u003e4280 m\u003c/td\u003e \u003ctd\u003e10911 m\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAtlantic\u003c/td\u003e \u003ctd\u003e3646 m\u003c/td\u003e \u003ctd\u003e8486 m\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003chtml\u003e This page, when rendered, looks something like this: In case you’re worried about it, know that you’ll never have to memorize these elements. It’s very easy to simply search something like “image in HTML” to find the img tag. One resource that’s especially helpful for learning about these elements is W3 Schools. ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:2","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Forms Another set of elements that is really important when creating a website is how to collect information from users. You can allow users to enter information using an HTML form, which can contain several different types of input. Later in the course, we’ll learn about how to handle information once a form has been submitted. Just as with other HTML elements, there’s no need to memorize these, and W3 Schools is a great resource for learning about them! \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eForms\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform\u003e \u003cinput type=\"text\" placeholder=\"First Name\" name=\"first\"\u003e \u003cinput type=\"password\" placeholder=\"Password\" name=\"password\"\u003e \u003cdiv\u003e Favorite Color: \u003cinput name=\"color\" type=\"radio\" value=\"blue\"\u003e Blue \u003cinput name=\"color\" type=\"radio\" value=\"green\"\u003e Green \u003cinput name=\"color\" type=\"radio\" value=\"yellow\"\u003e Yellow \u003cinput name=\"color\" type=\"radio\" value=\"red\"\u003e Red \u003c/div\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:3:3","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"CSS (Cascading Style Sheets) CSS is used to customize the appearance of a website. While we’re just getting, started, we can add a style attribute to any HTML element in order to apply some CSS to it. We change style by altering the CSS properties of an element, writing something like color: blue or text-align: center In this example below, we make a slight change to our very first file to give it a colorful heading: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"color: blue; text-align: center;\"\u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e If we style an outer element, all of the inner elements automatically take on that style. We can see this if we move the styling we just applied from the header tag to the body tag: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody style=\"color: blue; text-align: center;\"\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003chtml\u003e While we can style our web page as we’ve done above, to achieve better design, we should be able to move our styling away from the individual lines. One way of doing this is to add your styling between \u003cstyle\u003e tags in the head. Inside these tags, we write which types of elements we want to be style, and the styling we wish to apply to them. For example: \u003chtml lang=\"en\"\u003e \u003c!DOCTYPE html\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003cstyle\u003e h1 { color: blue; text-align: center; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003c/html\u003e Another way is to include in a \u003clink\u003e element in your head with a link to a styles.css file that contains some styling. This means the HTML file would look like: \u003chtml lang=\"en\"\u003e \u003c!DOCTYPE html\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 \u003eA Colorful Heading!\u003c/h1\u003e Hello, world! \u003c/body\u003e \u003c/html\u003e And our file called styles.css would look like: h1 { color: blue; text-align: center; } There are far too many CSS properties to go over here, but just like HTML elements, it’s typically easy to Google something along the lines of “change font to blue CSS” to get the result. Some of the most common ones though are: color: the color of text text-align: where elements are placed on the page background-color: can be set to any color width: in pixels or percent of a page height: in pixels or percent of a page padding: how much space should be left inside an element margin: how much space should be left outside an element font-family: type of font for text on page font-size: in pixels border: size type (solid, dashed, etc) color Let’s use some of what we just learned to improve upon our oceans table from above. Here’s some HTML to start us off: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eNicer Table\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003cthead\u003e \u003cth\u003eOcean\u003c/th\u003e \u003cth\u003eAverage Depth\u003c/th\u003e \u003cth\u003eMaximum Depth\u003c/th\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003ePacific\u003c/td\u003e \u003ctd\u003e4280 m\u003c/td\u003e \u003ctd\u003e10911 m\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAtlantic\u003c/td\u003e \u003ctd\u003e3646 m\u003c/td\u003e \u003ctd\u003e8486 m\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003chtml\u003e The above looks a lot like what we had before, but now, either by including a style tag or a link to a stylesheet in the head element, we add the following css: table { border: 1px solid black; border-collapse: collapse; } td { border: 1px solid black; padding: 2px; } th { border: 1px solid black; padding: 2px; } Which leaves us with this nicer-looking table: You may already be thinking that there’s some needless repetition in our CSS at the moment, as td and th have the same styling. We can (and should) condense this down to the following code, using a comma to show the styling should apply to more than one element type. table { border: 1px solid black; border-collapse: collapse; } td, th { border: 1px solid black; padding: 2px; } This is a good introduction into what are known as CSS selectors . There are many ways to determine which HTML elements you are styling, some of which we’ll mention here: element type: this is what we’ve been doing so far: styli","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:4:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Responsive Design Today, many people view websites on devices other than computers, such as smartphones and tablets. It’s important to make sure your website is readable to people on all devices. One way we can achieve this is through knowledge of the viewport. The viewport is the part of the screen that is actually visible to the user at any given time. By default, many webpages assume that the viewport is the same on any device, which is what leads to many sites (especially older ones) being difficult to interact with on mobile devices. One simple way to improve the appearance of a site on a mobile device is to add the following line in the head of our HTML files. This line tells the mobile device to use a viewport that is the same width as that of the device you’re using rather than a much larger one. \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e Another way we can deal with different devices is through media queries. Media queries are ways of changing the style of a page based on how the page is being viewed. For an example of a media query, let’s try to simply change the color of the screen when it shrinks down to a certain size. We signal a media query by typing @media followed by the type of query in parentheses: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eScreen Size\u003c/title\u003e \u003cstyle\u003e @media (min-width: 600px) { body { background-color: red; } } @media (max-width: 599px) { body { background-color: blue; } } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to the page!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e Another way to deal with differing screen size is using a new CSS attribute known as a flexbox. This allows us to easily have elements wrap around to the next line if they don’t fit horizontally. We do this by putting all of our elements in a div that we’ll call our container. We then add some styling to that div specifying that we want to use a flexbox display for the elements inside of it. We’ve also added some additional styling to the inner divs to better illustrate the wrapping that’s occuring here. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eScreen Size\u003c/title\u003e \u003cstyle\u003e #container { display: flex; flex-wrap: wrap; } #container \u003e div { background-color: green; font-size: 20px; margin: 20px; padding: 20px; width: 200px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"container\"\u003e \u003cdiv\u003eSome text 1!\u003c/div\u003e \u003cdiv\u003eSome text 2!\u003c/div\u003e \u003cdiv\u003eSome text 3!\u003c/div\u003e \u003cdiv\u003eSome text 4!\u003c/div\u003e \u003cdiv\u003eSome text 5!\u003c/div\u003e \u003cdiv\u003eSome text 6!\u003c/div\u003e \u003cdiv\u003eSome text 7!\u003c/div\u003e \u003cdiv\u003eSome text 8!\u003c/div\u003e \u003cdiv\u003eSome text 9!\u003c/div\u003e \u003cdiv\u003eSome text 10!\u003c/div\u003e \u003cdiv\u003eSome text 11!\u003c/div\u003e \u003cdiv\u003eSome text 12!\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Another popular way of styling a page is using an HTML grid. In this grid, we can specify style attributes such as column widths and gaps between columns and rows, as demonstrated below. Note that when we specify column widths, we say the third one is auto, meaning it should fill the rest of the page. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cstyle\u003e .grid { background-color: green; display: grid; padding: 20px; grid-column-gap: 20px; grid-row-gap: 10px; grid-template-columns: 200px 200px auto; } .grid-item { background-color: white; font-size: 20px; padding: 20px; text-align: center; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"grid\"\u003e \u003cdiv class=\"grid-item\"\u003e1\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e2\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e3\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e4\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e5\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e6\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e7\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e8\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e9\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e10\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e11\u003c/div\u003e \u003cdiv class=\"grid-item\"\u003e12\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:5:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Bootstrap It turns out that there are many libraries that other people have already written that can make the styling of a webpage even simpler. One popular library that we’ll use throughout the course is known as bootstrap. We can include bootstrap in our code by adding a single line to the head of our HTML file: \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"\u003e Next, we can look at some of bootstrap’s features by navigating to the documentation portion of their website. On this page, you’ll find many examples of classes you can add to elements that allow them to be styled with bootstrap. One popular bootstrap feature is their grid system. Bootstrap automatically splits a page into 12 columns, and we can decide how many columns an element takes up by adding the class col-x where x is a number between 1 and 12. For example, in the following page, we have a row of columns of equal width, and then a row where the center column is larger: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"\u003e \u003cstyle\u003e .row \u003e div { padding: 20px; background-color: teal; border: 2px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-4\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-4\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-4\"\u003e This is a third section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cbr/\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-3\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-6\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-3\"\u003e This is a third section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e To improve mobile-responsiveness, bootstrap also allows us to specify column sizes that differ depending on the screen size. In the following example, we use col-lg-3 to show that an element should take up 3 columns on a large screen, and col-sm-6 to show an element should take up 6 columns when the screen is small: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003ctitle\u003eMy Web Page!\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"\u003e \u003cstyle\u003e .row \u003e div { padding: 20px; background-color: teal; border: 2px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is another section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a third section. \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-sm-6\"\u003e This is a fourth section. \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:6:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["前端"],"content":"Sass (Syntactically Awesome Style Sheets) So far, we’ve found a few ways to eliminate redundancy in CSS such as moving it to separate files or using bootstrap, but there are still quite a few places where we can still make improvements. For example, what if we want several elements to have different styles, but for all of them to be the same color? If we decide later we want to change the color, then we would have to change it within several different elements. Sass is a language that allows us to write CSS more efficiently in several ways, one of which is by allowing us to have variables, as in the following example. When writing in Sass, we create a new file with the extension filename.scss. In this file, we can create a new variable by adding a $ before a name, then a colon, then a value. For example, we would write $color: red to set the variable color to the value red. We then access that variable using $color. Here’s an example of our variables.scss file: $color: red; ul { font-size: 14px; color: $color; } ol { font-size: 18px; color: $color; } Now, in order to link this styling to our HTML file, we can’t just link to the .scss file because most web browsers only recognize .css files. To deal with this problem, we have to download a program called Sass onto our computers. Then, in our terminal, we write sass variables.scss:variables.css This command will compile a .scss file named variables.scss into a .css file named variables.css, to which you can add a link in your HTML page. To speed up this process, we can use the command sass --watch variables.scss:variables.css which automatically changes the .css file every time a change is detected in the .scss file. While using Sass, we can also physically nest our styling rather than use the CSS selectors we talked about earlier. For example, if we want to apply some styling only to paragraphs and unordered lists within a div, we can write the following: div { font-size: 18px; p { color: blue; } ul { color: green; } } Once compiled into CSS, we would get a file that looks like: div { font-size: 18px; } div p { color: blue; } div ul { color: green; } One more feature that Sass gives us is known as inheritance. This allows us to create a basic set of styling that can be shared by several different elements. We do this by adding a % before a name of a class, adding some styling, and then later adding the line @extend %classname to the beginning of some styling. For example, the following code applies the styling within the message class to each of the different classes below, resulting in a webpage that looks like the one below. %message { font-family: sans-serif; font-size: 18px; font-weight: bold; border: 1px solid black; padding: 20px; margin: 20px; } .success { @extend %message; background-color: green; } .warning { @extend %message; background-color: orange; } .error { @extend %message; background-color: red; } That wraps up our content for today! ","date":"2021-05-14","objectID":"/posts/cs50_html_and_css/:7:0","tags":["CS50web"],"title":"Cs50_html_and_css","uri":"/posts/cs50_html_and_css/"},{"categories":["总结"],"content":" 求证的合群，不如自证的孤独 本月主题 ： python爬虫， ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"读书记录 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:1:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"python编程之美 爬虫Request库作者所书，难度适中，封面美丽。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:1:1","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"学习 这个月学习主题多有涉及：vim编辑器、算法复杂度、队列、爬虫解析xpath，re，Bs4、代理爬虫。主要是涉及了爬虫爬虫比我想象中要难，尤其是各种验证码识别，反爬虫破解。已经做到可以爬取豆瓣电影Top250，拉勾网招聘爬虫，小有收获。python csv，json，sql数据库还不太熟悉。4月份打算放一放scrapy先耍耍Django，再回头。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:2:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"投资 耐心等待周期 ☞第一，不要去追求“银弹”，即所谓的低风险甚至无风险的高收益。因为，这种“银弹”会引诱人们动用杠杆或是一把梭，结果可能会有不错的收益，但也有可能出现一系列极其糟糕的结果，而后者在市场里出现的概率更为普遍。当重大损失发生后，而后市场又刚好出现好机会，那么此时的机会必然与自身擦肩而过。 ☞第二，面对市场低迷期，在确定标的长期可持续增长的情况下，持续买入。因为，你耐心地持有，周期的力量会让它的内在价值和价格趋于一致。 ☞第三，持续的学习，只有持续的学习，并习得独立思考判断的能力，才能在耐心等待过程中，识别出机会并抓住它。 ","date":"2021-04-02","objectID":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:3:0","tags":[],"title":"三月的总结","uri":"/posts/%E4%B8%89%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":" 正月已过，重新启程。先做正确的事情，再把事情做对 本月主题 ： 区块链技术入门，密西根Python3 Programming， 如何销售 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"读书记录 区块链革命 没想道会有Apple II之父沃兹尼亚克推荐，可见比特币和区块链技术已经成为了硅谷共识，不得不关注。这本书居区块链入门书籍中高阶部分，所以不像其他区块链通识书籍，阅读起来较为困难，导致豆瓣评分不高。上阵父子兵，没想到写书还有父子兵。Coursera还有两位作者一起创作的Mooc，也以本书为参考教材。本书涉及区块链设计原则较多，而非区块链底层原理。 数字黄金 区块链小白书，豆瓣评分也明显偏高。涉及比特币原理：区块链技术、密码箱原理、分布式账本、挖矿、共识机制。 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:1","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"学习 不得不说国外的Mooc是真TM贴心，云环境，网页编辑器，课本、视频、练习、作业、考核、评论。完全跨过操作系统限制、环境配置、网络，能够体会到背后的用心，这也是我喜欢靠自己自学的原因。课程质量高一圈，体贴程度也是高一圈。下一步玩玩爬虫，做个蜘蛛侠，也巩固下学习内容。 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:2","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"销售 不得不吹一下Box定投践行群，第一期销售训练营也都是实打实的分享，基本上都在我主动边界以外的内容，不加群根本不知道还可以这样做销售，销售也只有一个理念，价值服务。 销售的不是产品，是你自己 过滤你的顾客 顾客买的不是产品，买的为什么 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:3","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"投资 开年以来交易日均值回归，📉跌幅尽在射程范围以内。从预计年化101%直接到20%，我的目标是年化15%足矣。此外张坤的易方达中小盘今年分红竟然有9%，赚钱只有一个姿势：躺 ","date":"2021-03-01","objectID":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/:0:4","tags":[],"title":"二月的总结","uri":"/posts/%E4%BA%8C%E6%9C%88%E7%9A%84%E6%80%BB%E7%BB%93/"}]