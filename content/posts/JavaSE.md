---
title: "JavaSE"
subtitle: ""
date: 2021-07-27T11:17:29+08:00
lastmod: 2021-07-27T11:17:29+08:00
draft: true
author: "Createitv"
description: "Createitv"

page:
    theme: "classic"

upd: ""
authorComment: ""

tags: ["JavaSE"]
categories: ["JAVA"]

hiddenFromHomePage: false
hiddenFromSearch: false

resources:
- name: "featured-image"
  src: "featured-image.jpg"
- name: featured-image-preview
  src: featured-image-preview.jpg

featuredImage: ""
featuredImagePreview: ""
images: [""]
---

## 1.Java 概述

Java 编程语言是一种通用的、并行的、基于类的、面向对象的语言。它被设计得非常简单，这样程序员可以在该语言上流畅的交流。Java 编程语言与 C 和 C++ 有关联，但组织却截然不同，其中也省略了其他语言的一些用法，比如指针。它的目的是作为一个生产性语言，而不是一个研究性语言，因此，在设计上避免了包括新的和未经考验的功能。

Java 编程语言是强类型和静态类型，可以在编译时检测到编译时错误。编译时间通常由翻译程序到与机器无关的字节码表示的。运行时的活动包括加载和执行程序，可选机器代码生成和程序的动态优化所需的类的交联，和实际执行程序。

Java 编程语言是一个比较高层次的语言，在机器表示的细节是无法通过该语言的。它包括自动存储管理，通常使用垃圾收集器，以避免明确释放的安全问题（就像 C 语言的 free 或 C++ 的 delete）。高性能垃圾回收的实现可具有有界的停顿，以支持系统的编程和实时应用。语言不包括任何不安全的结构，如没有索引检查的数组访问，因为这种不安全的结构会导致不可预知的程序行为。

### 语言起源

　　 Java平台和语言最开始只是SUN公司在1990年12月开始研究的一个内部项目。SUN公司的一个叫做帕特里克·诺顿的工程师被自己开发的C和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth计划”的项目的机会。

“Stealth计划”后来改名为“Green计划”，JGosling（詹姆斯·高斯林）和麦克·舍林丹也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，SUN公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C语言，但是很多成员包括SUN的首席科学家比尔·乔伊，发现C和可用的API在某些方面存在很大问题。

工作小组使用的是内嵌类型平台，可以用的资源极其有限。很多成员发现C太复杂以至很多开发者经常错误使用。他们发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。 　　 根据可用的资金，比尔·乔伊决定开发一种集C语言和Mesa语言搭成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议SUN公司的工程师应该在C的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C的功能，他自己称这种新语言为C--，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的树而命名。 　　 就像很多开发新技术的秘密的工程一样，工作小组没日没夜地工作到了1992年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库，和其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。 　　 同年11月，Green计划被转化成了“FirstPerson有限公司”，一个SUN公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度互动的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Requestforproposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多地控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司再并回SUN公司。 　　 1994年6、7月间，在经历了一场历时三天的头脑风暴的讨论之后，约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·斯库米，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。同年，Oak改名为Java。商标搜索显示，Oak已被一家显卡制造商注册，因此团队找到了一个新名字。这个名字是在很多成员常去的本地咖啡馆中杜撰出来的。名字是不是首字母缩写还不清楚，很大程度上来说不是。虽然有人声称是开发人员名字的组合：JamesGosling（詹姆斯·高斯林）ArthurVanHoff（阿瑟·凡·霍夫）AndyBechtolsheim（安迪·贝克托克姆），或“JustAnotherVagueAcronym”（只是另外一个含糊的缩写）。还有一种比较可信的说法是这个名字是出于对咖啡的喜爱，所以以Java咖啡来命名。类文件的前四个字节如果用十六进制阅读的话，分别为“CAFEBABE”，就会拼出两个单词“CAFEBABE”（咖啡宝贝）。

　　 1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年5月23日SunWorld大会上进行的。SUN公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，Sun公司成立了Java业务集团，专门开发Java技术。

### 发展简史

- 1995年5月23日，Java语言诞生
- 1996年1月，第一个JDK-JDK1.0诞生
- 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术
- 1996年9月，约8.3万个网页应用了JAVA技术来制作
- 1997年2月18日，JDK1.1发布
- 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录
- 1997年9月，JavaDeveloperConnection社区成员超过十万
- 1998年2月，JDK1.1被下载超过2,000,000次
- 1998年12月8日，JAVA2企业平台J2EE发布
- 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）
- 2000年5月8日，JDK1.3发布
- 2000年5月29日，JDK1.4发布
- 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机
- 2001年9月24日，J2EE1.3发布
- 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升
- 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为JavaSE5.0
- 2005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME
- 2006年12月，SUN公司发布JRE6.0
- 2009年4月7日GoogleAppEngine开始支持Java
- 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。
- 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。
- 2011年7月28日，甲骨文发布java7.0的正式版。
- 2014年3月19日，甲骨文公司发布java8.0的正式版。

### Java 语言与 Java 虚拟机的关系

#### 什么是 Java 虚拟机

Java 虚拟机(Java Virtual Machine,简称 JVM) 是整个 Java 平台的基石，实现硬件与操作系统无关，编译代码后生成出极小体积，保障用户机器免于恶意代码损害。

JVM 可以看作是一台抽象的计算机。跟真实的计算机一样，它有自己的指令集以及各种运行时内存区域。使用虚拟机来实现一门程序设计语言有许多合理的理由，业界中流传最为久远的虚拟机可能是 UCSD Pascal 的 P-Code 虚拟机。

第一个 JVM 的原型机是由 Sun 公司实现的，它被用在一种类似 PDA（Personal Digital Assistant，俗称掌上电脑）的手持设备上仿真实现 JVM 指令集。时至今日，Oracle 已有许多 JVM 实现应用于移动设备、桌面电脑、服务器等领域。JVM 并不局限于特定的实现技术、主机硬件和操作系统。它不强求使用解释器来执行程序，也可以通过把自己的指令集编译为实际 CPU 的指令来实现，它可以通过微代码来实现，或者甚至直接实现在 CPU 中。

#### Java 语言与 JVM 的关系

JVM 与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 class 文件格式所关联。class 文件中包含了 JVM 指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。

基于安全方面的考虑，JVM 要求在 class 文件中使用了许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 JVM 接收的有效的 class 文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将 JVM 作为他们语言的产品交付媒介。

![img](https://docs.kilvn.com/essential-java/images/overview/jvm.jpg)

如上图所示，在 Java 编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把 Java 的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。当你写好一个 Java 程序后，源语言的语句将由Java 编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel 的 Pentium 微处理器或 IBM 的 System/390 处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。



## 2.变量、数据类型和运算符

- 定义格式

```
// 数据类型 变量名 = 初始化值; （声明、赋值）int num1 = 123;
```

- 使用注意
  - **同一作用域内**同一变量不可重复声明
  - 变量**必须初始化后才能使用**（即必须有值才能使用），否则编译报错
  - 变量的值可在同一类型不断变化
  - 变量命名符合标识符规范，使用驼峰命名法，`首字母小写`
  - 就近原则

### 变量的分类及作用域

[![变量分类](https://static.sitestack.cn/projects/sdky-java-note/aa0422a30107384abbe4ac7218e09c09.png)](https://sdky.gitee.io/img/变量分类.png)
图 1 变量分类

[![不同数据类型的成员变量的初始值](https://static.sitestack.cn/projects/sdky-java-note/7d2f3a4656d8a50812bd55dcb2741c5c.png)](https://sdky.gitee.io/img/不同数据类型的成员变量的初始值.png)
图 2 不同数据类型的成员变量的初始值

- 成员变量/全局变量/字段：**直接**定义在**类中**，**方法外**的变量
  - 类变量 使用 static 修饰的字段 **方法区**
  - 实例变量 没有使用 static 修饰的字段 **堆**
  - 默认是有初始值的，可以先在方法中使用后定义
  - 作用域是整个类
- 局部变量
  - 方法的形参；2. 方法内中的变量；3.代码块中的变量
  - 没有初始值，必须显式初始化后才能使用
  - 定义局部变量后，系统并未分配内存空间，直到程序为这个变量**赋值**时，系统才会在**所在方法的的栈内存**中为局部变量分配内存，并将初始值（基本类型的值或者对象的引用）保存在该内存中
  - 从 **定义的位置** 开始到所在结束的花括号

### 数据类型的分类

![数据类型分类](https://static.sitestack.cn/projects/sdky-java-note/0e022c80dfbbd9c647889474658477c2.png)
图 3 数据类型分类

[![基本数据类型范围](https://static.sitestack.cn/projects/sdky-java-note/bb49b135af69eb91a992cad3c14fbb07.png)](https://sdky.gitee.io/img/Java基本数据类型范围.png)
图 4 基本数据类型范围

[![基本类型](https://static.sitestack.cn/projects/sdky-java-note/ff6730bb794905891da147581c776794.jpeg)](https://sdky.gitee.io/img/Java的基本类型.jpg)

图 5 基本类型

### boolean 类型

- 常量值只能是 true 或 false

```java
boolean isMan = true;
```

### 字符类型

- char 16 位 Unicode 字符集，编码方式为 UTF-16BE

- UTF-16 使用 2 或者 4 字节表示一个字符，在 65536 以内的占两个字节，而基本上所有汉字的 Unicode 编码[在 19968 到 40869 之间](http://www.chi2ko.com/tool/CJK.htm)，所以一个 char 类型可以存储一个汉字

- 使用`' '`

  括起来

  - 49'1'; 65 'A'; 97 'a'

```java
// 表示形式
char c1 = 'A'; // 使用单个字符
char c2 = 65; // 使用十进制的整数（Unicode 值），[0, 65535]
char c3 = '\u0061'; // 使用十六进制的整数，格式'\uXXXX'，('\u0000'~'\u00FF')
```

### 运算符

```java
// 算数运算符
+ - * / % ++ -- 
// 比较运算符  
== != < > <= >= instanceof
// 三目运算符
String ret = number % 2 == 0 ? "偶数" : "奇数";
// 逻辑运算符
&& || ^ !
// 位运算符
& | ~ << >> >>>
```

#### 自增 ++ 自减 —

- 自增、自减操作都是直接修改变量的值（读、改、写），不经过操作数栈
- 前置 ( ++i )：**局部变量表**中的 i 先自增，再把 i 的值压入**操作数栈**
- 后置 ( i++ )：先把局部变量表中的 i 压入操作数栈，再自增

```java
int i = 1;i = ++i;System.out.println(i); // 2int j = 1;j = j++;System.out.println(j); // 1
```

## 3.流程控制

#### `if-else` 语句

```java
if (boolean 表达式 或 boolean 变量) {
    条件执行体 1 // 为 true 时执行 
} else {
    条件执行体 2 // 为 false 时执行
}
```

#### `while` 语句

```java
while (boolean 表达式) {
    循环体;
    迭代语句; // 自增或自减，用于对循环次数的控制
}
```

#### `for`循环

```java
for (初始化语句; boolean 表达式; 迭代语句) {
    循环体;
}
```

##### 循环控制

- `break`：**结束**当前 break 所在的整个循环
- `continue`：**跳过** continue 所在的**本次循环**剩下语句，开始下一次循环

## 4.方法

#### 格式

```java
[修饰符] 返回值类型 方法名([参数类型 形参 1, 参数类型 形参 2, ...]) {
    // 方法体;
    [return 返回值]; // 当方法需要给调用者返回值时
}
```

- 当方法无返回值时，**必须**给出返回类型 `void`
- 参数列表 / 参数清单，包含参数的个数、参数类型、 参数顺序
- **方法签名**：方法名 + 方法参数列表，判断是否是同一个方法的标准
- 在同一个类中，**方法签名是唯一的**，否则编译报错
- 考虑当调用者传入数据的**范围**不合理时，该如何处理（进行参数校验）

## 5.数组

#### 声明

```java
int[] arr; // 数组元素类型[] 数组名;
int arr[]; // 数组元素类型 数组名[]; // 不推荐
```

#### 初始化

```java
// 静态初始化
// 数组名 = new 数组元素类型[] {元素 1, 元素 2, ...};
// 在堆空间开辟一块内存区域来存储数组的元素（new）
// 将 该内存区域的地址值 赋值给 该数组的引用变量 arr（引用）
int[] arr = new int[] {1, 2, 3};
// 简单写法，必须声明的同时作初始化
// 数组元素类型[] 数组名 = {元素 1, 元素 2, ...};
int[] arr = {1, 2, 3};
// 动态初始化，系统自动为数组元素分配初始值
// 数组名 = new 数组元素类型[length];
int[] arr = new int[3]; // [0, 0, 0]
```

- 变量**必须初始化后才能使用**
- 数组是定长的：数组一旦初始化完成，数组的长度就固定了，不能更改，除非重新做初始化
- 数组是引用数据类型，可以赋值为 null，表示没有引用任何内存空间
- **new** 关键字：在堆空间开辟一块内存区域，用来存储数据
- 操作数组常见异常：NullPointerException：空指针异常（没有引用地址值）ArrayIndexOutOfBoundsException：数组的索引越界异常

#### 基本操作

```java
int[] arr = new int[] {1, 2, 3};
// 访问数组元素  数组变量[索引值]
int len = arr.length;  // 数组长度，length 是属性，索引范围 [0, arr.length - 1]
int num = arr[0];
arr[0] = 11;
// 遍历
// 普通 for 循环
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
// 增强 for 循环（for-each）
// 只能访问数组元素，不能赋值，不关心数组的索引时使用
// 当数组元素是引用类型时，不建议使用（需要先知道值不为 null 的元素个数）
for (int ele : arr) {
    System.out.println(ele);
}
// 反编译后
int ai[] = arr;
int k = ai.length;
for (int j = 0; j < k; j++) {
    int i = ai[j]; // 使用循环迭代出数组中的每一个元素并赋值给 i
    System.out.println(i); // 操作 i
}
// 打印数组元素
// 直接打印数组名时，打印出来是数组对应的 hashCode 值，如 [I@15db9742, [D@15db9742, [Ljava.lang.String;@15db9742
static String toString(int[] arr) {
    // 判断数组是否为空
    if (arr == null) {
        return "null"; // 结束方法
    }
    if (arr.length == 0) {
        return "[]";
    }
    String ret = "["; // 先拼接"["
    for (int index = 0; index < arr.length; index++) {
        // 如果不是最后一个元素，拼接 元素 + ", "，否则拼接 元素 + "]"
        ret = (index != arr.length - 1) 
            ? ret + arr[index] + ", " 
            : ret + arr[index] + "]";
    }
    return ret;
}
```

##### 二分查找

```java
// 从有序数组中查找 key 第一次出现的位置
// 二分搜索法/二分查找法/折半查找
// 前提：数组的元素是有序排列的
// 区间位置：如果 arr[mid] != key，下一次是以 mid + 1 作为下一个起始位置，或者 mid - 1 作为下一个结束位置
// 退出循环的条件：low > high
static int binarySearch(int[] arr, int key) {
    int low = 0;
    int high = arr.length - 1;
    while (low <= high) {
        int mid = (low + high) >> 1;
        if (arr[mid] < key) {
            low = mid + 1;
        } else if (arr[mid] > key) {
            high = mid - 1;
        } else {
            while (mid - 1 >= 0 && arr[mid -1] == key) {
                mid--;
            }
            return mid;
        }
    }
    return -1;
}
```

#### Arrays

java.util.Arrays 中的类方法：

- `String toString(Object[] arr)`：将 a 数组转换成一个字符串，括在方括号（"[]"）中，相邻元素用字符 ", "（逗号加空格）分隔
- `void sort(Object[] a)`：根据元素的自然顺序对指定对象数组按升序进行排序，数组中的所有元素都必须实现 Comparable 接口（对于原始数据类型，使用所谓双轴快速排序（Dual-Pivot QuickSort），对于对象数据类型，使用 TimSort）
- `void sort(T[] a, Comparator<? super T> c)`：根据指定比较器产生的顺序对指定对象数组进行排序
- `void parallelSort(Object[] a)`：以并发的方式对 a 数组的数组元素进行排序
- `void setAll(T[] array, IntFunction<T> generator)`：使用提供的函数计算每一个元素的值，对指定数组中的所有元素进行设置
- `void parallelSetAll(T[] array, IntFunction<T> generator)`：以并发的方式，使用提供的函数计算每一个元素的值，对指定数组中的所有元素进行设置
- `type binarySearch(Object[] a, type key)`：使用二分法査询 key 元素值在 a 数组中出现的索引，如果 a 数组不包含 key 元素值，则返回 -(low + 1)（调用该方法时要求数组中元素已经按升序排列）
- `boolean equals(Object[] a, Object[] a2)`：如果 a 数组和 a2 数组的长度相等，且 a 数组和 a2 数组的数组元素也一一相同，该方法将返回 true
- `Object[] copyOf(Object[] original, int newLength)`：复制 original 数组，截取或用 0（数值类型）、false（布尔类型）或者 null（引用类型）填充，以使新数组的长度为 newLength
- `List<T> asList(T… a)`：把一个**引用类型的数组**或**指定个数的对象**转换成**固定长度**的 List（Arrays.ArrayList），只能遍历访问该集合里的元素，**不可增加、删除**该集合里的元素，否则会引发 UnsupportedOperationException 

## 6.java修饰符

[![修饰符适用范围](https://static.sitestack.cn/projects/sdky-java-note/57686dd161ac811168d3eccbd278a411.jpeg)](https://sdky.gitee.io/img/修饰符适用范围.jpg)
图 1 修饰符适用范围

#### 访问权限修饰符

- 用于控制一个类的**成员**是否可以在其它类中**访问**，不能修饰局部变量

  [![访问权限修饰符](https://static.sitestack.cn/projects/sdky-java-note/aa405519b878117576c6190a54abedea.png)](https://sdky.gitee.io/img/访问权限修饰符.png)
  图 2 访问权限修饰符

- `private`（当前类访问权限）：在同一类内可见，只能被所属类访问
- ` `（包访问权限）：不使用任何修饰符时，在同一包内可见
- `protected`（子类访问权限）：对同一包内的任何其它类和不同包中的子类可见，不能修饰接口中的成员变量和成员方法（注意：在**不同包中的子类**只能通过**该子类**访问父类中 `protected` 成员，通过其它子类或父类都无法访问）
- `public`（公共访问权限）：对所有类可见

#### 非访问修饰符

- `static` 用来创建类方法和类变量，类方法**不能访问**的实例变量
- `final` 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不可修改
- `abstract` 用来创建抽象类、抽象方法
- `synchronized` 修饰的方法、代码块在同一时间只能被一个线程访问，不能修饰构造器、成员变量等
- `volatile` 修饰的**成员变量**在**每次**被线程访问时，都强迫从**共享内存**中重读该成员变量的值；并且，当成员变量发生变化时，强迫线程将变化值回写到共享内存（保证了线程操作时变量的**可见性**，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的）（只能保证内存可见性，无法保证操作的原子性）
- `transient` 序列化的对象包含被 transient 修饰的实例变量时，JVM 跳过该特定的变量
- `native` 修饰的方法通常采用 C/C++ 语言来实现

#### volatile 的实现原理

- 如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到内存，这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效
- 缓存一致性协议（如 Intel 的 MESI 协议）：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里

#### final 修饰符

- 表示最终的类，**不可被继承的类**
- java 里 `final` 修饰的类有很多，比如八大基本数据类型包装类和 String 类，也是不可变类（当创建它们的实例后，其实例的实例变量不可改变）

#### final 修饰的方法

- 最终的方法，该方法子类可以调用，但**不允许被子类覆盖**
- 构造方法不能使用 `final` 修饰

#### final 修饰的变量

- 最终的变量，常量，该变量**只能被赋值一次**
- `final` 修饰的**成员变量**必须**显式**指定初始值（定义时、初始化块或构造器中指定），系统不会为 final 字段初始化；**静态常量**的单词**全部大写**，单词间使用下划线隔开 `final int MAX_VALUE = …;`
- `final` 是唯一可以修饰局部变量的修饰符
- `final` 修饰基本类型的变量，表示该变量不能被重新赋值
- `final` 修饰引用类型的变量，表示该变量**所引用的地址**不能变，而所引用对象的内容可以改变

- 可执行“宏替换”的 final 变量：当定义 final 变量时就为该变量**指定了初始值**，编译器会把程序中所有用到该变量的地方直接替换成该变量的值（在编译阶段能确定的内容只能来自于**常量池**中）

## 7.类与对象

#### 定义

- 对象是类的实例，类是对象的抽象
- 类可被认为是一种**自定义的数据类型**，可以使用类来定义变量
- 类中的成员：字段（成员变量）、构造器、方法、初始化块、内部类（包括接口、枚举）
- **外部类**只能有两种访问控制级别：public 和 缺省
- 定义类的语法格式

```java
[修饰符] class 类名 {
    0-N 成员变量（字段） // 描述类具有的特性，对象的状态
    0-N 构造器定义
    0-N 方法            // 描述类具有的功能，对象的行为
}
```

